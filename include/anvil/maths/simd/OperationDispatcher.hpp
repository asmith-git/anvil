//Copyright 2017 Adam G. Smith
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http ://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FMA> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fma_
		} else if (S >= 64 && _simd_f64x64_fma_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x32_fma_
		} else if (S >= 32 && _simd_f64x32_fma_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x16_fma_
		} else if (S >= 16 && _simd_f64x16_fma_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x8_fma_
		} else if (S >= 8 && _simd_f64x8_fma_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x4_fma_
		} else if (S >= 4 && _simd_f64x4_fma_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x2_fma_
		} else if (S >= 2 && _simd_f64x2_fma_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FMS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fms_
		} else if (S >= 64 && _simd_f64x64_fms_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x32_fms_
		} else if (S >= 32 && _simd_f64x32_fms_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x16_fms_
		} else if (S >= 16 && _simd_f64x16_fms_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x8_fms_
		} else if (S >= 8 && _simd_f64x8_fms_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x4_fms_
		} else if (S >= 4 && _simd_f64x4_fms_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f64x2_fms_
		} else if (S >= 2 && _simd_f64x2_fms_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ADD> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_add_
		} else if (S >= 64 && _simd_f64x64_add_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_add_
		} else if (S >= 32 && _simd_f64x32_add_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_add_
		} else if (S >= 16 && _simd_f64x16_add_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_add_
		} else if (S >= 8 && _simd_f64x8_add_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_add_
		} else if (S >= 4 && _simd_f64x4_add_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_add_
		} else if (S >= 2 && _simd_f64x2_add_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SUB> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sub_
		} else if (S >= 64 && _simd_f64x64_sub_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_sub_
		} else if (S >= 32 && _simd_f64x32_sub_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_sub_
		} else if (S >= 16 && _simd_f64x16_sub_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_sub_
		} else if (S >= 8 && _simd_f64x8_sub_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_sub_
		} else if (S >= 4 && _simd_f64x4_sub_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_sub_
		} else if (S >= 2 && _simd_f64x2_sub_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MUL> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_mul_
		} else if (S >= 64 && _simd_f64x64_mul_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_mul_
		} else if (S >= 32 && _simd_f64x32_mul_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_mul_
		} else if (S >= 16 && _simd_f64x16_mul_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_mul_
		} else if (S >= 8 && _simd_f64x8_mul_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_mul_
		} else if (S >= 4 && _simd_f64x4_mul_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_mul_
		} else if (S >= 2 && _simd_f64x2_mul_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_DIV> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_div_
		} else if (S >= 64 && _simd_f64x64_div_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_div_
		} else if (S >= 32 && _simd_f64x32_div_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_div_
		} else if (S >= 16 && _simd_f64x16_div_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_div_
		} else if (S >= 8 && _simd_f64x8_div_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_div_
		} else if (S >= 4 && _simd_f64x4_div_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_div_
		} else if (S >= 2 && _simd_f64x2_div_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_min_
		} else if (S >= 64 && _simd_f64x64_min_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_min_
		} else if (S >= 32 && _simd_f64x32_min_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_min_
		} else if (S >= 16 && _simd_f64x16_min_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_min_
		} else if (S >= 8 && _simd_f64x8_min_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_min_
		} else if (S >= 4 && _simd_f64x4_min_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_min_
		} else if (S >= 2 && _simd_f64x2_min_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MAX> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_max_
		} else if (S >= 64 && _simd_f64x64_max_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_max_
		} else if (S >= 32 && _simd_f64x32_max_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_max_
		} else if (S >= 16 && _simd_f64x16_max_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_max_
		} else if (S >= 8 && _simd_f64x8_max_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_max_
		} else if (S >= 4 && _simd_f64x4_max_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_max_
		} else if (S >= 2 && _simd_f64x2_max_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPEQ> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpeq_
		} else if (S >= 64 && _simd_f64x64_cmpeq_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmpeq_
		} else if (S >= 32 && _simd_f64x32_cmpeq_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmpeq_
		} else if (S >= 16 && _simd_f64x16_cmpeq_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmpeq_
		} else if (S >= 8 && _simd_f64x8_cmpeq_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmpeq_
		} else if (S >= 4 && _simd_f64x4_cmpeq_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmpeq_
		} else if (S >= 2 && _simd_f64x2_cmpeq_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPNE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpne_
		} else if (S >= 64 && _simd_f64x64_cmpne_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmpne_
		} else if (S >= 32 && _simd_f64x32_cmpne_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmpne_
		} else if (S >= 16 && _simd_f64x16_cmpne_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmpne_
		} else if (S >= 8 && _simd_f64x8_cmpne_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmpne_
		} else if (S >= 4 && _simd_f64x4_cmpne_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmpne_
		} else if (S >= 2 && _simd_f64x2_cmpne_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPLT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmplt_
		} else if (S >= 64 && _simd_f64x64_cmplt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmplt_
		} else if (S >= 32 && _simd_f64x32_cmplt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmplt_
		} else if (S >= 16 && _simd_f64x16_cmplt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmplt_
		} else if (S >= 8 && _simd_f64x8_cmplt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmplt_
		} else if (S >= 4 && _simd_f64x4_cmplt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmplt_
		} else if (S >= 2 && _simd_f64x2_cmplt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPGT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpgt_
		} else if (S >= 64 && _simd_f64x64_cmpgt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmpgt_
		} else if (S >= 32 && _simd_f64x32_cmpgt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmpgt_
		} else if (S >= 16 && _simd_f64x16_cmpgt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmpgt_
		} else if (S >= 8 && _simd_f64x8_cmpgt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmpgt_
		} else if (S >= 4 && _simd_f64x4_cmpgt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmpgt_
		} else if (S >= 2 && _simd_f64x2_cmpgt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPLE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmple_
		} else if (S >= 64 && _simd_f64x64_cmple_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmple_
		} else if (S >= 32 && _simd_f64x32_cmple_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmple_
		} else if (S >= 16 && _simd_f64x16_cmple_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmple_
		} else if (S >= 8 && _simd_f64x8_cmple_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmple_
		} else if (S >= 4 && _simd_f64x4_cmple_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmple_
		} else if (S >= 2 && _simd_f64x2_cmple_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPGE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpge_
		} else if (S >= 64 && _simd_f64x64_cmpge_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_cmpge_
		} else if (S >= 32 && _simd_f64x32_cmpge_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_cmpge_
		} else if (S >= 16 && _simd_f64x16_cmpge_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_cmpge_
		} else if (S >= 8 && _simd_f64x8_cmpge_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_cmpge_
		} else if (S >= 4 && _simd_f64x4_cmpge_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_cmpge_
		} else if (S >= 2 && _simd_f64x2_cmpge_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_AND> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_and_
		} else if (S >= 64 && _simd_f64x64_and_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_and_
		} else if (S >= 32 && _simd_f64x32_and_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_and_
		} else if (S >= 16 && _simd_f64x16_and_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_and_
		} else if (S >= 8 && _simd_f64x8_and_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_and_
		} else if (S >= 4 && _simd_f64x4_and_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_and_
		} else if (S >= 2 && _simd_f64x2_and_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_OR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_or_
		} else if (S >= 64 && _simd_f64x64_or_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_or_
		} else if (S >= 32 && _simd_f64x32_or_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_or_
		} else if (S >= 16 && _simd_f64x16_or_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_or_
		} else if (S >= 8 && _simd_f64x8_or_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_or_
		} else if (S >= 4 && _simd_f64x4_or_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_or_
		} else if (S >= 2 && _simd_f64x2_or_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_XOR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_xor_
		} else if (S >= 64 && _simd_f64x64_xor_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_xor_
		} else if (S >= 32 && _simd_f64x32_xor_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_xor_
		} else if (S >= 16 && _simd_f64x16_xor_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_xor_
		} else if (S >= 8 && _simd_f64x8_xor_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_xor_
		} else if (S >= 4 && _simd_f64x4_xor_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_xor_
		} else if (S >= 2 && _simd_f64x2_xor_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_lshift_
		} else if (S >= 64 && _simd_f64x64_lshift_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_lshift_
		} else if (S >= 32 && _simd_f64x32_lshift_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_lshift_
		} else if (S >= 16 && _simd_f64x16_lshift_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_lshift_
		} else if (S >= 8 && _simd_f64x8_lshift_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_lshift_
		} else if (S >= 4 && _simd_f64x4_lshift_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_lshift_
		} else if (S >= 2 && _simd_f64x2_lshift_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_RSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_rshift_
		} else if (S >= 64 && _simd_f64x64_rshift_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_rshift_
		} else if (S >= 32 && _simd_f64x32_rshift_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_rshift_
		} else if (S >= 16 && _simd_f64x16_rshift_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_rshift_
		} else if (S >= 8 && _simd_f64x8_rshift_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_rshift_
		} else if (S >= 4 && _simd_f64x4_rshift_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_rshift_
		} else if (S >= 2 && _simd_f64x2_rshift_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ATAN2> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_atan2_
		} else if (S >= 64 && _simd_f64x64_atan2_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x32_atan2_
		} else if (S >= 32 && _simd_f64x32_atan2_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x16_atan2_
		} else if (S >= 16 && _simd_f64x16_atan2_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x8_atan2_
		} else if (S >= 8 && _simd_f64x8_atan2_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x4_atan2_
		} else if (S >= 4 && _simd_f64x4_atan2_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f64x2_atan2_
		} else if (S >= 2 && _simd_f64x2_atan2_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_REFLECT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_reflect_
		} else if (S >= 64 && _simd_f64x64_reflect_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_reflect_
		} else if (S >= 32 && _simd_f64x32_reflect_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_reflect_
		} else if (S >= 16 && _simd_f64x16_reflect_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_reflect_
		} else if (S >= 8 && _simd_f64x8_reflect_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_reflect_
		} else if (S >= 4 && _simd_f64x4_reflect_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_reflect_
		} else if (S >= 2 && _simd_f64x2_reflect_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_NOT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_not_
		} else if (S >= 64 && _simd_f64x64_not_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_not_
		} else if (S >= 32 && _simd_f64x32_not_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_not_
		} else if (S >= 16 && _simd_f64x16_not_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_not_
		} else if (S >= 8 && _simd_f64x8_not_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_not_
		} else if (S >= 4 && _simd_f64x4_not_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_not_
		} else if (S >= 2 && _simd_f64x2_not_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ABS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_abs_
		} else if (S >= 64 && _simd_f64x64_abs_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_abs_
		} else if (S >= 32 && _simd_f64x32_abs_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_abs_
		} else if (S >= 16 && _simd_f64x16_abs_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_abs_
		} else if (S >= 8 && _simd_f64x8_abs_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_abs_
		} else if (S >= 4 && _simd_f64x4_abs_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_abs_
		} else if (S >= 2 && _simd_f64x2_abs_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_EXP> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_exp_
		} else if (S >= 64 && _simd_f64x64_exp_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_exp_
		} else if (S >= 32 && _simd_f64x32_exp_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_exp_
		} else if (S >= 16 && _simd_f64x16_exp_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_exp_
		} else if (S >= 8 && _simd_f64x8_exp_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_exp_
		} else if (S >= 4 && _simd_f64x4_exp_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_exp_
		} else if (S >= 2 && _simd_f64x2_exp_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log_
		} else if (S >= 64 && _simd_f64x64_log_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_log_
		} else if (S >= 32 && _simd_f64x32_log_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_log_
		} else if (S >= 16 && _simd_f64x16_log_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_log_
		} else if (S >= 8 && _simd_f64x8_log_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_log_
		} else if (S >= 4 && _simd_f64x4_log_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_log_
		} else if (S >= 2 && _simd_f64x2_log_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG2> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log2_
		} else if (S >= 64 && _simd_f64x64_log2_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_log2_
		} else if (S >= 32 && _simd_f64x32_log2_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_log2_
		} else if (S >= 16 && _simd_f64x16_log2_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_log2_
		} else if (S >= 8 && _simd_f64x8_log2_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_log2_
		} else if (S >= 4 && _simd_f64x4_log2_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_log2_
		} else if (S >= 2 && _simd_f64x2_log2_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG10> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log10_
		} else if (S >= 64 && _simd_f64x64_log10_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_log10_
		} else if (S >= 32 && _simd_f64x32_log10_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_log10_
		} else if (S >= 16 && _simd_f64x16_log10_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_log10_
		} else if (S >= 8 && _simd_f64x8_log10_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_log10_
		} else if (S >= 4 && _simd_f64x4_log10_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_log10_
		} else if (S >= 2 && _simd_f64x2_log10_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CEIL> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_ceil_
		} else if (S >= 64 && _simd_f64x64_ceil_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_ceil_
		} else if (S >= 32 && _simd_f64x32_ceil_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_ceil_
		} else if (S >= 16 && _simd_f64x16_ceil_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_ceil_
		} else if (S >= 8 && _simd_f64x8_ceil_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_ceil_
		} else if (S >= 4 && _simd_f64x4_ceil_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_ceil_
		} else if (S >= 2 && _simd_f64x2_ceil_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FLOOR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_floor_
		} else if (S >= 64 && _simd_f64x64_floor_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_floor_
		} else if (S >= 32 && _simd_f64x32_floor_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_floor_
		} else if (S >= 16 && _simd_f64x16_floor_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_floor_
		} else if (S >= 8 && _simd_f64x8_floor_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_floor_
		} else if (S >= 4 && _simd_f64x4_floor_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_floor_
		} else if (S >= 2 && _simd_f64x2_floor_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ROUND> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_round_
		} else if (S >= 64 && _simd_f64x64_round_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_round_
		} else if (S >= 32 && _simd_f64x32_round_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_round_
		} else if (S >= 16 && _simd_f64x16_round_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_round_
		} else if (S >= 8 && _simd_f64x8_round_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_round_
		} else if (S >= 4 && _simd_f64x4_round_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_round_
		} else if (S >= 2 && _simd_f64x2_round_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sin_
		} else if (S >= 64 && _simd_f64x64_sin_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_sin_
		} else if (S >= 32 && _simd_f64x32_sin_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_sin_
		} else if (S >= 16 && _simd_f64x16_sin_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_sin_
		} else if (S >= 8 && _simd_f64x8_sin_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_sin_
		} else if (S >= 4 && _simd_f64x4_sin_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_sin_
		} else if (S >= 2 && _simd_f64x2_sin_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_COS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cos_
		} else if (S >= 64 && _simd_f64x64_cos_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_cos_
		} else if (S >= 32 && _simd_f64x32_cos_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_cos_
		} else if (S >= 16 && _simd_f64x16_cos_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_cos_
		} else if (S >= 8 && _simd_f64x8_cos_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_cos_
		} else if (S >= 4 && _simd_f64x4_cos_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_cos_
		} else if (S >= 2 && _simd_f64x2_cos_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_TAN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_tan_
		} else if (S >= 64 && _simd_f64x64_tan_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_tan_
		} else if (S >= 32 && _simd_f64x32_tan_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_tan_
		} else if (S >= 16 && _simd_f64x16_tan_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_tan_
		} else if (S >= 8 && _simd_f64x8_tan_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_tan_
		} else if (S >= 4 && _simd_f64x4_tan_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_tan_
		} else if (S >= 2 && _simd_f64x2_tan_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ASIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_asin_
		} else if (S >= 64 && _simd_f64x64_asin_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_asin_
		} else if (S >= 32 && _simd_f64x32_asin_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_asin_
		} else if (S >= 16 && _simd_f64x16_asin_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_asin_
		} else if (S >= 8 && _simd_f64x8_asin_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_asin_
		} else if (S >= 4 && _simd_f64x4_asin_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_asin_
		} else if (S >= 2 && _simd_f64x2_asin_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ACOS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_acos_
		} else if (S >= 64 && _simd_f64x64_acos_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_acos_
		} else if (S >= 32 && _simd_f64x32_acos_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_acos_
		} else if (S >= 16 && _simd_f64x16_acos_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_acos_
		} else if (S >= 8 && _simd_f64x8_acos_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_acos_
		} else if (S >= 4 && _simd_f64x4_acos_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_acos_
		} else if (S >= 2 && _simd_f64x2_acos_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ATAN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_atan_
		} else if (S >= 64 && _simd_f64x64_atan_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_atan_
		} else if (S >= 32 && _simd_f64x32_atan_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_atan_
		} else if (S >= 16 && _simd_f64x16_atan_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_atan_
		} else if (S >= 8 && _simd_f64x8_atan_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_atan_
		} else if (S >= 4 && _simd_f64x4_atan_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_atan_
		} else if (S >= 2 && _simd_f64x2_atan_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SINH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sinh_
		} else if (S >= 64 && _simd_f64x64_sinh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_sinh_
		} else if (S >= 32 && _simd_f64x32_sinh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_sinh_
		} else if (S >= 16 && _simd_f64x16_sinh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_sinh_
		} else if (S >= 8 && _simd_f64x8_sinh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_sinh_
		} else if (S >= 4 && _simd_f64x4_sinh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_sinh_
		} else if (S >= 2 && _simd_f64x2_sinh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_COSH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cosh_
		} else if (S >= 64 && _simd_f64x64_cosh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_cosh_
		} else if (S >= 32 && _simd_f64x32_cosh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_cosh_
		} else if (S >= 16 && _simd_f64x16_cosh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_cosh_
		} else if (S >= 8 && _simd_f64x8_cosh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_cosh_
		} else if (S >= 4 && _simd_f64x4_cosh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_cosh_
		} else if (S >= 2 && _simd_f64x2_cosh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_TANH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_tanh_
		} else if (S >= 64 && _simd_f64x64_tanh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_tanh_
		} else if (S >= 32 && _simd_f64x32_tanh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_tanh_
		} else if (S >= 16 && _simd_f64x16_tanh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_tanh_
		} else if (S >= 8 && _simd_f64x8_tanh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_tanh_
		} else if (S >= 4 && _simd_f64x4_tanh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_tanh_
		} else if (S >= 2 && _simd_f64x2_tanh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SQRT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sqrt_
		} else if (S >= 64 && _simd_f64x64_sqrt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_sqrt_
		} else if (S >= 32 && _simd_f64x32_sqrt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_sqrt_
		} else if (S >= 16 && _simd_f64x16_sqrt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_sqrt_
		} else if (S >= 8 && _simd_f64x8_sqrt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_sqrt_
		} else if (S >= 4 && _simd_f64x4_sqrt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_sqrt_
		} else if (S >= 2 && _simd_f64x2_sqrt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CBRT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cbrt_
		} else if (S >= 64 && _simd_f64x64_cbrt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x32_cbrt_
		} else if (S >= 32 && _simd_f64x32_cbrt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x16_cbrt_
		} else if (S >= 16 && _simd_f64x16_cbrt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x8_cbrt_
		} else if (S >= 8 && _simd_f64x8_cbrt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x4_cbrt_
		} else if (S >= 4 && _simd_f64x4_cbrt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f64x2_cbrt_
		} else if (S >= 2 && _simd_f64x2_cbrt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f64x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FMA> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fma_
		} else if (S >= 64 && _simd_f32x64_fma_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x32_fma_
		} else if (S >= 32 && _simd_f32x32_fma_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x16_fma_
		} else if (S >= 16 && _simd_f32x16_fma_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x8_fma_
		} else if (S >= 8 && _simd_f32x8_fma_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x4_fma_
		} else if (S >= 4 && _simd_f32x4_fma_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x2_fma_
		} else if (S >= 2 && _simd_f32x2_fma_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FMS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fms_
		} else if (S >= 64 && _simd_f32x64_fms_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x32_fms_
		} else if (S >= 32 && _simd_f32x32_fms_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x16_fms_
		} else if (S >= 16 && _simd_f32x16_fms_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x8_fms_
		} else if (S >= 8 && _simd_f32x8_fms_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x4_fms_
		} else if (S >= 4 && _simd_f32x4_fms_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_f32x2_fms_
		} else if (S >= 2 && _simd_f32x2_fms_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ADD> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_add_
		} else if (S >= 64 && _simd_f32x64_add_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_add_
		} else if (S >= 32 && _simd_f32x32_add_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_add_
		} else if (S >= 16 && _simd_f32x16_add_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_add_
		} else if (S >= 8 && _simd_f32x8_add_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_add_
		} else if (S >= 4 && _simd_f32x4_add_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_add_
		} else if (S >= 2 && _simd_f32x2_add_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SUB> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sub_
		} else if (S >= 64 && _simd_f32x64_sub_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_sub_
		} else if (S >= 32 && _simd_f32x32_sub_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_sub_
		} else if (S >= 16 && _simd_f32x16_sub_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_sub_
		} else if (S >= 8 && _simd_f32x8_sub_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_sub_
		} else if (S >= 4 && _simd_f32x4_sub_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_sub_
		} else if (S >= 2 && _simd_f32x2_sub_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MUL> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_mul_
		} else if (S >= 64 && _simd_f32x64_mul_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_mul_
		} else if (S >= 32 && _simd_f32x32_mul_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_mul_
		} else if (S >= 16 && _simd_f32x16_mul_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_mul_
		} else if (S >= 8 && _simd_f32x8_mul_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_mul_
		} else if (S >= 4 && _simd_f32x4_mul_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_mul_
		} else if (S >= 2 && _simd_f32x2_mul_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_DIV> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_div_
		} else if (S >= 64 && _simd_f32x64_div_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_div_
		} else if (S >= 32 && _simd_f32x32_div_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_div_
		} else if (S >= 16 && _simd_f32x16_div_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_div_
		} else if (S >= 8 && _simd_f32x8_div_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_div_
		} else if (S >= 4 && _simd_f32x4_div_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_div_
		} else if (S >= 2 && _simd_f32x2_div_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_min_
		} else if (S >= 64 && _simd_f32x64_min_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_min_
		} else if (S >= 32 && _simd_f32x32_min_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_min_
		} else if (S >= 16 && _simd_f32x16_min_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_min_
		} else if (S >= 8 && _simd_f32x8_min_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_min_
		} else if (S >= 4 && _simd_f32x4_min_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_min_
		} else if (S >= 2 && _simd_f32x2_min_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MAX> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_max_
		} else if (S >= 64 && _simd_f32x64_max_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_max_
		} else if (S >= 32 && _simd_f32x32_max_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_max_
		} else if (S >= 16 && _simd_f32x16_max_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_max_
		} else if (S >= 8 && _simd_f32x8_max_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_max_
		} else if (S >= 4 && _simd_f32x4_max_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_max_
		} else if (S >= 2 && _simd_f32x2_max_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPEQ> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpeq_
		} else if (S >= 64 && _simd_f32x64_cmpeq_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmpeq_
		} else if (S >= 32 && _simd_f32x32_cmpeq_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmpeq_
		} else if (S >= 16 && _simd_f32x16_cmpeq_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmpeq_
		} else if (S >= 8 && _simd_f32x8_cmpeq_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmpeq_
		} else if (S >= 4 && _simd_f32x4_cmpeq_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmpeq_
		} else if (S >= 2 && _simd_f32x2_cmpeq_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPNE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpne_
		} else if (S >= 64 && _simd_f32x64_cmpne_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmpne_
		} else if (S >= 32 && _simd_f32x32_cmpne_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmpne_
		} else if (S >= 16 && _simd_f32x16_cmpne_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmpne_
		} else if (S >= 8 && _simd_f32x8_cmpne_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmpne_
		} else if (S >= 4 && _simd_f32x4_cmpne_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmpne_
		} else if (S >= 2 && _simd_f32x2_cmpne_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPLT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmplt_
		} else if (S >= 64 && _simd_f32x64_cmplt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmplt_
		} else if (S >= 32 && _simd_f32x32_cmplt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmplt_
		} else if (S >= 16 && _simd_f32x16_cmplt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmplt_
		} else if (S >= 8 && _simd_f32x8_cmplt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmplt_
		} else if (S >= 4 && _simd_f32x4_cmplt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmplt_
		} else if (S >= 2 && _simd_f32x2_cmplt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPGT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpgt_
		} else if (S >= 64 && _simd_f32x64_cmpgt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmpgt_
		} else if (S >= 32 && _simd_f32x32_cmpgt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmpgt_
		} else if (S >= 16 && _simd_f32x16_cmpgt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmpgt_
		} else if (S >= 8 && _simd_f32x8_cmpgt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmpgt_
		} else if (S >= 4 && _simd_f32x4_cmpgt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmpgt_
		} else if (S >= 2 && _simd_f32x2_cmpgt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPLE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmple_
		} else if (S >= 64 && _simd_f32x64_cmple_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmple_
		} else if (S >= 32 && _simd_f32x32_cmple_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmple_
		} else if (S >= 16 && _simd_f32x16_cmple_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmple_
		} else if (S >= 8 && _simd_f32x8_cmple_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmple_
		} else if (S >= 4 && _simd_f32x4_cmple_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmple_
		} else if (S >= 2 && _simd_f32x2_cmple_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPGE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpge_
		} else if (S >= 64 && _simd_f32x64_cmpge_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_cmpge_
		} else if (S >= 32 && _simd_f32x32_cmpge_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_cmpge_
		} else if (S >= 16 && _simd_f32x16_cmpge_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_cmpge_
		} else if (S >= 8 && _simd_f32x8_cmpge_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_cmpge_
		} else if (S >= 4 && _simd_f32x4_cmpge_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_cmpge_
		} else if (S >= 2 && _simd_f32x2_cmpge_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_AND> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_and_
		} else if (S >= 64 && _simd_f32x64_and_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_and_
		} else if (S >= 32 && _simd_f32x32_and_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_and_
		} else if (S >= 16 && _simd_f32x16_and_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_and_
		} else if (S >= 8 && _simd_f32x8_and_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_and_
		} else if (S >= 4 && _simd_f32x4_and_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_and_
		} else if (S >= 2 && _simd_f32x2_and_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_OR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_or_
		} else if (S >= 64 && _simd_f32x64_or_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_or_
		} else if (S >= 32 && _simd_f32x32_or_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_or_
		} else if (S >= 16 && _simd_f32x16_or_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_or_
		} else if (S >= 8 && _simd_f32x8_or_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_or_
		} else if (S >= 4 && _simd_f32x4_or_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_or_
		} else if (S >= 2 && _simd_f32x2_or_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_XOR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_xor_
		} else if (S >= 64 && _simd_f32x64_xor_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_xor_
		} else if (S >= 32 && _simd_f32x32_xor_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_xor_
		} else if (S >= 16 && _simd_f32x16_xor_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_xor_
		} else if (S >= 8 && _simd_f32x8_xor_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_xor_
		} else if (S >= 4 && _simd_f32x4_xor_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_xor_
		} else if (S >= 2 && _simd_f32x2_xor_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_lshift_
		} else if (S >= 64 && _simd_f32x64_lshift_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_lshift_
		} else if (S >= 32 && _simd_f32x32_lshift_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_lshift_
		} else if (S >= 16 && _simd_f32x16_lshift_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_lshift_
		} else if (S >= 8 && _simd_f32x8_lshift_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_lshift_
		} else if (S >= 4 && _simd_f32x4_lshift_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_lshift_
		} else if (S >= 2 && _simd_f32x2_lshift_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_RSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_rshift_
		} else if (S >= 64 && _simd_f32x64_rshift_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_rshift_
		} else if (S >= 32 && _simd_f32x32_rshift_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_rshift_
		} else if (S >= 16 && _simd_f32x16_rshift_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_rshift_
		} else if (S >= 8 && _simd_f32x8_rshift_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_rshift_
		} else if (S >= 4 && _simd_f32x4_rshift_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_rshift_
		} else if (S >= 2 && _simd_f32x2_rshift_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ATAN2> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_atan2_
		} else if (S >= 64 && _simd_f32x64_atan2_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x32_atan2_
		} else if (S >= 32 && _simd_f32x32_atan2_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x16_atan2_
		} else if (S >= 16 && _simd_f32x16_atan2_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x8_atan2_
		} else if (S >= 8 && _simd_f32x8_atan2_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x4_atan2_
		} else if (S >= 4 && _simd_f32x4_atan2_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_f32x2_atan2_
		} else if (S >= 2 && _simd_f32x2_atan2_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_REFLECT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_reflect_
		} else if (S >= 64 && _simd_f32x64_reflect_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_reflect_
		} else if (S >= 32 && _simd_f32x32_reflect_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_reflect_
		} else if (S >= 16 && _simd_f32x16_reflect_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_reflect_
		} else if (S >= 8 && _simd_f32x8_reflect_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_reflect_
		} else if (S >= 4 && _simd_f32x4_reflect_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_reflect_
		} else if (S >= 2 && _simd_f32x2_reflect_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_NOT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_not_
		} else if (S >= 64 && _simd_f32x64_not_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_not_
		} else if (S >= 32 && _simd_f32x32_not_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_not_
		} else if (S >= 16 && _simd_f32x16_not_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_not_
		} else if (S >= 8 && _simd_f32x8_not_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_not_
		} else if (S >= 4 && _simd_f32x4_not_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_not_
		} else if (S >= 2 && _simd_f32x2_not_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ABS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_abs_
		} else if (S >= 64 && _simd_f32x64_abs_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_abs_
		} else if (S >= 32 && _simd_f32x32_abs_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_abs_
		} else if (S >= 16 && _simd_f32x16_abs_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_abs_
		} else if (S >= 8 && _simd_f32x8_abs_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_abs_
		} else if (S >= 4 && _simd_f32x4_abs_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_abs_
		} else if (S >= 2 && _simd_f32x2_abs_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_EXP> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_exp_
		} else if (S >= 64 && _simd_f32x64_exp_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_exp_
		} else if (S >= 32 && _simd_f32x32_exp_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_exp_
		} else if (S >= 16 && _simd_f32x16_exp_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_exp_
		} else if (S >= 8 && _simd_f32x8_exp_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_exp_
		} else if (S >= 4 && _simd_f32x4_exp_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_exp_
		} else if (S >= 2 && _simd_f32x2_exp_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log_
		} else if (S >= 64 && _simd_f32x64_log_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_log_
		} else if (S >= 32 && _simd_f32x32_log_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_log_
		} else if (S >= 16 && _simd_f32x16_log_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_log_
		} else if (S >= 8 && _simd_f32x8_log_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_log_
		} else if (S >= 4 && _simd_f32x4_log_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_log_
		} else if (S >= 2 && _simd_f32x2_log_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG2> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log2_
		} else if (S >= 64 && _simd_f32x64_log2_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_log2_
		} else if (S >= 32 && _simd_f32x32_log2_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_log2_
		} else if (S >= 16 && _simd_f32x16_log2_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_log2_
		} else if (S >= 8 && _simd_f32x8_log2_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_log2_
		} else if (S >= 4 && _simd_f32x4_log2_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_log2_
		} else if (S >= 2 && _simd_f32x2_log2_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG10> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log10_
		} else if (S >= 64 && _simd_f32x64_log10_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_log10_
		} else if (S >= 32 && _simd_f32x32_log10_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_log10_
		} else if (S >= 16 && _simd_f32x16_log10_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_log10_
		} else if (S >= 8 && _simd_f32x8_log10_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_log10_
		} else if (S >= 4 && _simd_f32x4_log10_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_log10_
		} else if (S >= 2 && _simd_f32x2_log10_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CEIL> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_ceil_
		} else if (S >= 64 && _simd_f32x64_ceil_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_ceil_
		} else if (S >= 32 && _simd_f32x32_ceil_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_ceil_
		} else if (S >= 16 && _simd_f32x16_ceil_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_ceil_
		} else if (S >= 8 && _simd_f32x8_ceil_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_ceil_
		} else if (S >= 4 && _simd_f32x4_ceil_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_ceil_
		} else if (S >= 2 && _simd_f32x2_ceil_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FLOOR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_floor_
		} else if (S >= 64 && _simd_f32x64_floor_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_floor_
		} else if (S >= 32 && _simd_f32x32_floor_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_floor_
		} else if (S >= 16 && _simd_f32x16_floor_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_floor_
		} else if (S >= 8 && _simd_f32x8_floor_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_floor_
		} else if (S >= 4 && _simd_f32x4_floor_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_floor_
		} else if (S >= 2 && _simd_f32x2_floor_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ROUND> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_round_
		} else if (S >= 64 && _simd_f32x64_round_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_round_
		} else if (S >= 32 && _simd_f32x32_round_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_round_
		} else if (S >= 16 && _simd_f32x16_round_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_round_
		} else if (S >= 8 && _simd_f32x8_round_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_round_
		} else if (S >= 4 && _simd_f32x4_round_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_round_
		} else if (S >= 2 && _simd_f32x2_round_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sin_
		} else if (S >= 64 && _simd_f32x64_sin_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_sin_
		} else if (S >= 32 && _simd_f32x32_sin_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_sin_
		} else if (S >= 16 && _simd_f32x16_sin_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_sin_
		} else if (S >= 8 && _simd_f32x8_sin_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_sin_
		} else if (S >= 4 && _simd_f32x4_sin_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_sin_
		} else if (S >= 2 && _simd_f32x2_sin_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_COS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cos_
		} else if (S >= 64 && _simd_f32x64_cos_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_cos_
		} else if (S >= 32 && _simd_f32x32_cos_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_cos_
		} else if (S >= 16 && _simd_f32x16_cos_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_cos_
		} else if (S >= 8 && _simd_f32x8_cos_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_cos_
		} else if (S >= 4 && _simd_f32x4_cos_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_cos_
		} else if (S >= 2 && _simd_f32x2_cos_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_TAN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_tan_
		} else if (S >= 64 && _simd_f32x64_tan_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_tan_
		} else if (S >= 32 && _simd_f32x32_tan_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_tan_
		} else if (S >= 16 && _simd_f32x16_tan_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_tan_
		} else if (S >= 8 && _simd_f32x8_tan_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_tan_
		} else if (S >= 4 && _simd_f32x4_tan_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_tan_
		} else if (S >= 2 && _simd_f32x2_tan_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ASIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_asin_
		} else if (S >= 64 && _simd_f32x64_asin_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_asin_
		} else if (S >= 32 && _simd_f32x32_asin_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_asin_
		} else if (S >= 16 && _simd_f32x16_asin_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_asin_
		} else if (S >= 8 && _simd_f32x8_asin_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_asin_
		} else if (S >= 4 && _simd_f32x4_asin_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_asin_
		} else if (S >= 2 && _simd_f32x2_asin_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ACOS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_acos_
		} else if (S >= 64 && _simd_f32x64_acos_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_acos_
		} else if (S >= 32 && _simd_f32x32_acos_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_acos_
		} else if (S >= 16 && _simd_f32x16_acos_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_acos_
		} else if (S >= 8 && _simd_f32x8_acos_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_acos_
		} else if (S >= 4 && _simd_f32x4_acos_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_acos_
		} else if (S >= 2 && _simd_f32x2_acos_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ATAN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_atan_
		} else if (S >= 64 && _simd_f32x64_atan_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_atan_
		} else if (S >= 32 && _simd_f32x32_atan_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_atan_
		} else if (S >= 16 && _simd_f32x16_atan_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_atan_
		} else if (S >= 8 && _simd_f32x8_atan_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_atan_
		} else if (S >= 4 && _simd_f32x4_atan_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_atan_
		} else if (S >= 2 && _simd_f32x2_atan_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SINH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sinh_
		} else if (S >= 64 && _simd_f32x64_sinh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_sinh_
		} else if (S >= 32 && _simd_f32x32_sinh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_sinh_
		} else if (S >= 16 && _simd_f32x16_sinh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_sinh_
		} else if (S >= 8 && _simd_f32x8_sinh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_sinh_
		} else if (S >= 4 && _simd_f32x4_sinh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_sinh_
		} else if (S >= 2 && _simd_f32x2_sinh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_COSH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cosh_
		} else if (S >= 64 && _simd_f32x64_cosh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_cosh_
		} else if (S >= 32 && _simd_f32x32_cosh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_cosh_
		} else if (S >= 16 && _simd_f32x16_cosh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_cosh_
		} else if (S >= 8 && _simd_f32x8_cosh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_cosh_
		} else if (S >= 4 && _simd_f32x4_cosh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_cosh_
		} else if (S >= 2 && _simd_f32x2_cosh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_TANH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_tanh_
		} else if (S >= 64 && _simd_f32x64_tanh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_tanh_
		} else if (S >= 32 && _simd_f32x32_tanh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_tanh_
		} else if (S >= 16 && _simd_f32x16_tanh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_tanh_
		} else if (S >= 8 && _simd_f32x8_tanh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_tanh_
		} else if (S >= 4 && _simd_f32x4_tanh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_tanh_
		} else if (S >= 2 && _simd_f32x2_tanh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SQRT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sqrt_
		} else if (S >= 64 && _simd_f32x64_sqrt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_sqrt_
		} else if (S >= 32 && _simd_f32x32_sqrt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_sqrt_
		} else if (S >= 16 && _simd_f32x16_sqrt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_sqrt_
		} else if (S >= 8 && _simd_f32x8_sqrt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_sqrt_
		} else if (S >= 4 && _simd_f32x4_sqrt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_sqrt_
		} else if (S >= 2 && _simd_f32x2_sqrt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CBRT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cbrt_
		} else if (S >= 64 && _simd_f32x64_cbrt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x32_cbrt_
		} else if (S >= 32 && _simd_f32x32_cbrt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x16_cbrt_
		} else if (S >= 16 && _simd_f32x16_cbrt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x8_cbrt_
		} else if (S >= 8 && _simd_f32x8_cbrt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x4_cbrt_
		} else if (S >= 4 && _simd_f32x4_cbrt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_f32x2_cbrt_
		} else if (S >= 2 && _simd_f32x2_cbrt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_f32x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FMA> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fma_
		} else if (S >= 64 && _simd_s64x64_fma_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x32_fma_
		} else if (S >= 32 && _simd_s64x32_fma_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x16_fma_
		} else if (S >= 16 && _simd_s64x16_fma_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x8_fma_
		} else if (S >= 8 && _simd_s64x8_fma_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x4_fma_
		} else if (S >= 4 && _simd_s64x4_fma_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x2_fma_
		} else if (S >= 2 && _simd_s64x2_fma_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FMS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fms_
		} else if (S >= 64 && _simd_s64x64_fms_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x32_fms_
		} else if (S >= 32 && _simd_s64x32_fms_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x16_fms_
		} else if (S >= 16 && _simd_s64x16_fms_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x8_fms_
		} else if (S >= 8 && _simd_s64x8_fms_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x4_fms_
		} else if (S >= 4 && _simd_s64x4_fms_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s64x2_fms_
		} else if (S >= 2 && _simd_s64x2_fms_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ADD> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_add_
		} else if (S >= 64 && _simd_s64x64_add_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_add_
		} else if (S >= 32 && _simd_s64x32_add_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_add_
		} else if (S >= 16 && _simd_s64x16_add_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_add_
		} else if (S >= 8 && _simd_s64x8_add_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_add_
		} else if (S >= 4 && _simd_s64x4_add_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_add_
		} else if (S >= 2 && _simd_s64x2_add_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SUB> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sub_
		} else if (S >= 64 && _simd_s64x64_sub_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_sub_
		} else if (S >= 32 && _simd_s64x32_sub_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_sub_
		} else if (S >= 16 && _simd_s64x16_sub_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_sub_
		} else if (S >= 8 && _simd_s64x8_sub_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_sub_
		} else if (S >= 4 && _simd_s64x4_sub_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_sub_
		} else if (S >= 2 && _simd_s64x2_sub_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MUL> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_mul_
		} else if (S >= 64 && _simd_s64x64_mul_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_mul_
		} else if (S >= 32 && _simd_s64x32_mul_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_mul_
		} else if (S >= 16 && _simd_s64x16_mul_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_mul_
		} else if (S >= 8 && _simd_s64x8_mul_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_mul_
		} else if (S >= 4 && _simd_s64x4_mul_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_mul_
		} else if (S >= 2 && _simd_s64x2_mul_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_DIV> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_div_
		} else if (S >= 64 && _simd_s64x64_div_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_div_
		} else if (S >= 32 && _simd_s64x32_div_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_div_
		} else if (S >= 16 && _simd_s64x16_div_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_div_
		} else if (S >= 8 && _simd_s64x8_div_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_div_
		} else if (S >= 4 && _simd_s64x4_div_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_div_
		} else if (S >= 2 && _simd_s64x2_div_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_min_
		} else if (S >= 64 && _simd_s64x64_min_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_min_
		} else if (S >= 32 && _simd_s64x32_min_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_min_
		} else if (S >= 16 && _simd_s64x16_min_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_min_
		} else if (S >= 8 && _simd_s64x8_min_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_min_
		} else if (S >= 4 && _simd_s64x4_min_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_min_
		} else if (S >= 2 && _simd_s64x2_min_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MAX> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_max_
		} else if (S >= 64 && _simd_s64x64_max_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_max_
		} else if (S >= 32 && _simd_s64x32_max_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_max_
		} else if (S >= 16 && _simd_s64x16_max_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_max_
		} else if (S >= 8 && _simd_s64x8_max_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_max_
		} else if (S >= 4 && _simd_s64x4_max_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_max_
		} else if (S >= 2 && _simd_s64x2_max_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPEQ> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpeq_
		} else if (S >= 64 && _simd_s64x64_cmpeq_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmpeq_
		} else if (S >= 32 && _simd_s64x32_cmpeq_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmpeq_
		} else if (S >= 16 && _simd_s64x16_cmpeq_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmpeq_
		} else if (S >= 8 && _simd_s64x8_cmpeq_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmpeq_
		} else if (S >= 4 && _simd_s64x4_cmpeq_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmpeq_
		} else if (S >= 2 && _simd_s64x2_cmpeq_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPNE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpne_
		} else if (S >= 64 && _simd_s64x64_cmpne_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmpne_
		} else if (S >= 32 && _simd_s64x32_cmpne_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmpne_
		} else if (S >= 16 && _simd_s64x16_cmpne_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmpne_
		} else if (S >= 8 && _simd_s64x8_cmpne_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmpne_
		} else if (S >= 4 && _simd_s64x4_cmpne_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmpne_
		} else if (S >= 2 && _simd_s64x2_cmpne_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPLT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmplt_
		} else if (S >= 64 && _simd_s64x64_cmplt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmplt_
		} else if (S >= 32 && _simd_s64x32_cmplt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmplt_
		} else if (S >= 16 && _simd_s64x16_cmplt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmplt_
		} else if (S >= 8 && _simd_s64x8_cmplt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmplt_
		} else if (S >= 4 && _simd_s64x4_cmplt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmplt_
		} else if (S >= 2 && _simd_s64x2_cmplt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPGT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpgt_
		} else if (S >= 64 && _simd_s64x64_cmpgt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmpgt_
		} else if (S >= 32 && _simd_s64x32_cmpgt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmpgt_
		} else if (S >= 16 && _simd_s64x16_cmpgt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmpgt_
		} else if (S >= 8 && _simd_s64x8_cmpgt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmpgt_
		} else if (S >= 4 && _simd_s64x4_cmpgt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmpgt_
		} else if (S >= 2 && _simd_s64x2_cmpgt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPLE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmple_
		} else if (S >= 64 && _simd_s64x64_cmple_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmple_
		} else if (S >= 32 && _simd_s64x32_cmple_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmple_
		} else if (S >= 16 && _simd_s64x16_cmple_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmple_
		} else if (S >= 8 && _simd_s64x8_cmple_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmple_
		} else if (S >= 4 && _simd_s64x4_cmple_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmple_
		} else if (S >= 2 && _simd_s64x2_cmple_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPGE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpge_
		} else if (S >= 64 && _simd_s64x64_cmpge_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_cmpge_
		} else if (S >= 32 && _simd_s64x32_cmpge_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_cmpge_
		} else if (S >= 16 && _simd_s64x16_cmpge_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_cmpge_
		} else if (S >= 8 && _simd_s64x8_cmpge_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_cmpge_
		} else if (S >= 4 && _simd_s64x4_cmpge_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_cmpge_
		} else if (S >= 2 && _simd_s64x2_cmpge_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_AND> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_and_
		} else if (S >= 64 && _simd_s64x64_and_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_and_
		} else if (S >= 32 && _simd_s64x32_and_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_and_
		} else if (S >= 16 && _simd_s64x16_and_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_and_
		} else if (S >= 8 && _simd_s64x8_and_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_and_
		} else if (S >= 4 && _simd_s64x4_and_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_and_
		} else if (S >= 2 && _simd_s64x2_and_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_OR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_or_
		} else if (S >= 64 && _simd_s64x64_or_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_or_
		} else if (S >= 32 && _simd_s64x32_or_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_or_
		} else if (S >= 16 && _simd_s64x16_or_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_or_
		} else if (S >= 8 && _simd_s64x8_or_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_or_
		} else if (S >= 4 && _simd_s64x4_or_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_or_
		} else if (S >= 2 && _simd_s64x2_or_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_XOR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_xor_
		} else if (S >= 64 && _simd_s64x64_xor_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_xor_
		} else if (S >= 32 && _simd_s64x32_xor_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_xor_
		} else if (S >= 16 && _simd_s64x16_xor_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_xor_
		} else if (S >= 8 && _simd_s64x8_xor_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_xor_
		} else if (S >= 4 && _simd_s64x4_xor_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_xor_
		} else if (S >= 2 && _simd_s64x2_xor_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_lshift_
		} else if (S >= 64 && _simd_s64x64_lshift_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_lshift_
		} else if (S >= 32 && _simd_s64x32_lshift_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_lshift_
		} else if (S >= 16 && _simd_s64x16_lshift_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_lshift_
		} else if (S >= 8 && _simd_s64x8_lshift_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_lshift_
		} else if (S >= 4 && _simd_s64x4_lshift_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_lshift_
		} else if (S >= 2 && _simd_s64x2_lshift_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_RSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_rshift_
		} else if (S >= 64 && _simd_s64x64_rshift_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_rshift_
		} else if (S >= 32 && _simd_s64x32_rshift_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_rshift_
		} else if (S >= 16 && _simd_s64x16_rshift_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_rshift_
		} else if (S >= 8 && _simd_s64x8_rshift_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_rshift_
		} else if (S >= 4 && _simd_s64x4_rshift_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_rshift_
		} else if (S >= 2 && _simd_s64x2_rshift_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ATAN2> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_atan2_
		} else if (S >= 64 && _simd_s64x64_atan2_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x32_atan2_
		} else if (S >= 32 && _simd_s64x32_atan2_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x16_atan2_
		} else if (S >= 16 && _simd_s64x16_atan2_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x8_atan2_
		} else if (S >= 8 && _simd_s64x8_atan2_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x4_atan2_
		} else if (S >= 4 && _simd_s64x4_atan2_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s64x2_atan2_
		} else if (S >= 2 && _simd_s64x2_atan2_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_REFLECT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_reflect_
		} else if (S >= 64 && _simd_s64x64_reflect_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_reflect_
		} else if (S >= 32 && _simd_s64x32_reflect_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_reflect_
		} else if (S >= 16 && _simd_s64x16_reflect_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_reflect_
		} else if (S >= 8 && _simd_s64x8_reflect_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_reflect_
		} else if (S >= 4 && _simd_s64x4_reflect_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_reflect_
		} else if (S >= 2 && _simd_s64x2_reflect_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_NOT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_not_
		} else if (S >= 64 && _simd_s64x64_not_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_not_
		} else if (S >= 32 && _simd_s64x32_not_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_not_
		} else if (S >= 16 && _simd_s64x16_not_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_not_
		} else if (S >= 8 && _simd_s64x8_not_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_not_
		} else if (S >= 4 && _simd_s64x4_not_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_not_
		} else if (S >= 2 && _simd_s64x2_not_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ABS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_abs_
		} else if (S >= 64 && _simd_s64x64_abs_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_abs_
		} else if (S >= 32 && _simd_s64x32_abs_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_abs_
		} else if (S >= 16 && _simd_s64x16_abs_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_abs_
		} else if (S >= 8 && _simd_s64x8_abs_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_abs_
		} else if (S >= 4 && _simd_s64x4_abs_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_abs_
		} else if (S >= 2 && _simd_s64x2_abs_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_EXP> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_exp_
		} else if (S >= 64 && _simd_s64x64_exp_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_exp_
		} else if (S >= 32 && _simd_s64x32_exp_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_exp_
		} else if (S >= 16 && _simd_s64x16_exp_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_exp_
		} else if (S >= 8 && _simd_s64x8_exp_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_exp_
		} else if (S >= 4 && _simd_s64x4_exp_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_exp_
		} else if (S >= 2 && _simd_s64x2_exp_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log_
		} else if (S >= 64 && _simd_s64x64_log_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_log_
		} else if (S >= 32 && _simd_s64x32_log_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_log_
		} else if (S >= 16 && _simd_s64x16_log_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_log_
		} else if (S >= 8 && _simd_s64x8_log_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_log_
		} else if (S >= 4 && _simd_s64x4_log_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_log_
		} else if (S >= 2 && _simd_s64x2_log_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG2> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log2_
		} else if (S >= 64 && _simd_s64x64_log2_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_log2_
		} else if (S >= 32 && _simd_s64x32_log2_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_log2_
		} else if (S >= 16 && _simd_s64x16_log2_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_log2_
		} else if (S >= 8 && _simd_s64x8_log2_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_log2_
		} else if (S >= 4 && _simd_s64x4_log2_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_log2_
		} else if (S >= 2 && _simd_s64x2_log2_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG10> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log10_
		} else if (S >= 64 && _simd_s64x64_log10_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_log10_
		} else if (S >= 32 && _simd_s64x32_log10_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_log10_
		} else if (S >= 16 && _simd_s64x16_log10_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_log10_
		} else if (S >= 8 && _simd_s64x8_log10_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_log10_
		} else if (S >= 4 && _simd_s64x4_log10_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_log10_
		} else if (S >= 2 && _simd_s64x2_log10_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CEIL> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_ceil_
		} else if (S >= 64 && _simd_s64x64_ceil_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_ceil_
		} else if (S >= 32 && _simd_s64x32_ceil_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_ceil_
		} else if (S >= 16 && _simd_s64x16_ceil_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_ceil_
		} else if (S >= 8 && _simd_s64x8_ceil_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_ceil_
		} else if (S >= 4 && _simd_s64x4_ceil_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_ceil_
		} else if (S >= 2 && _simd_s64x2_ceil_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FLOOR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_floor_
		} else if (S >= 64 && _simd_s64x64_floor_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_floor_
		} else if (S >= 32 && _simd_s64x32_floor_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_floor_
		} else if (S >= 16 && _simd_s64x16_floor_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_floor_
		} else if (S >= 8 && _simd_s64x8_floor_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_floor_
		} else if (S >= 4 && _simd_s64x4_floor_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_floor_
		} else if (S >= 2 && _simd_s64x2_floor_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ROUND> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_round_
		} else if (S >= 64 && _simd_s64x64_round_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_round_
		} else if (S >= 32 && _simd_s64x32_round_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_round_
		} else if (S >= 16 && _simd_s64x16_round_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_round_
		} else if (S >= 8 && _simd_s64x8_round_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_round_
		} else if (S >= 4 && _simd_s64x4_round_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_round_
		} else if (S >= 2 && _simd_s64x2_round_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sin_
		} else if (S >= 64 && _simd_s64x64_sin_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_sin_
		} else if (S >= 32 && _simd_s64x32_sin_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_sin_
		} else if (S >= 16 && _simd_s64x16_sin_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_sin_
		} else if (S >= 8 && _simd_s64x8_sin_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_sin_
		} else if (S >= 4 && _simd_s64x4_sin_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_sin_
		} else if (S >= 2 && _simd_s64x2_sin_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_COS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cos_
		} else if (S >= 64 && _simd_s64x64_cos_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_cos_
		} else if (S >= 32 && _simd_s64x32_cos_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_cos_
		} else if (S >= 16 && _simd_s64x16_cos_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_cos_
		} else if (S >= 8 && _simd_s64x8_cos_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_cos_
		} else if (S >= 4 && _simd_s64x4_cos_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_cos_
		} else if (S >= 2 && _simd_s64x2_cos_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_TAN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_tan_
		} else if (S >= 64 && _simd_s64x64_tan_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_tan_
		} else if (S >= 32 && _simd_s64x32_tan_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_tan_
		} else if (S >= 16 && _simd_s64x16_tan_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_tan_
		} else if (S >= 8 && _simd_s64x8_tan_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_tan_
		} else if (S >= 4 && _simd_s64x4_tan_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_tan_
		} else if (S >= 2 && _simd_s64x2_tan_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ASIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_asin_
		} else if (S >= 64 && _simd_s64x64_asin_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_asin_
		} else if (S >= 32 && _simd_s64x32_asin_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_asin_
		} else if (S >= 16 && _simd_s64x16_asin_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_asin_
		} else if (S >= 8 && _simd_s64x8_asin_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_asin_
		} else if (S >= 4 && _simd_s64x4_asin_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_asin_
		} else if (S >= 2 && _simd_s64x2_asin_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ACOS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_acos_
		} else if (S >= 64 && _simd_s64x64_acos_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_acos_
		} else if (S >= 32 && _simd_s64x32_acos_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_acos_
		} else if (S >= 16 && _simd_s64x16_acos_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_acos_
		} else if (S >= 8 && _simd_s64x8_acos_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_acos_
		} else if (S >= 4 && _simd_s64x4_acos_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_acos_
		} else if (S >= 2 && _simd_s64x2_acos_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ATAN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_atan_
		} else if (S >= 64 && _simd_s64x64_atan_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_atan_
		} else if (S >= 32 && _simd_s64x32_atan_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_atan_
		} else if (S >= 16 && _simd_s64x16_atan_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_atan_
		} else if (S >= 8 && _simd_s64x8_atan_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_atan_
		} else if (S >= 4 && _simd_s64x4_atan_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_atan_
		} else if (S >= 2 && _simd_s64x2_atan_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SINH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sinh_
		} else if (S >= 64 && _simd_s64x64_sinh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_sinh_
		} else if (S >= 32 && _simd_s64x32_sinh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_sinh_
		} else if (S >= 16 && _simd_s64x16_sinh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_sinh_
		} else if (S >= 8 && _simd_s64x8_sinh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_sinh_
		} else if (S >= 4 && _simd_s64x4_sinh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_sinh_
		} else if (S >= 2 && _simd_s64x2_sinh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_COSH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cosh_
		} else if (S >= 64 && _simd_s64x64_cosh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_cosh_
		} else if (S >= 32 && _simd_s64x32_cosh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_cosh_
		} else if (S >= 16 && _simd_s64x16_cosh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_cosh_
		} else if (S >= 8 && _simd_s64x8_cosh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_cosh_
		} else if (S >= 4 && _simd_s64x4_cosh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_cosh_
		} else if (S >= 2 && _simd_s64x2_cosh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_TANH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_tanh_
		} else if (S >= 64 && _simd_s64x64_tanh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_tanh_
		} else if (S >= 32 && _simd_s64x32_tanh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_tanh_
		} else if (S >= 16 && _simd_s64x16_tanh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_tanh_
		} else if (S >= 8 && _simd_s64x8_tanh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_tanh_
		} else if (S >= 4 && _simd_s64x4_tanh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_tanh_
		} else if (S >= 2 && _simd_s64x2_tanh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SQRT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sqrt_
		} else if (S >= 64 && _simd_s64x64_sqrt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_sqrt_
		} else if (S >= 32 && _simd_s64x32_sqrt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_sqrt_
		} else if (S >= 16 && _simd_s64x16_sqrt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_sqrt_
		} else if (S >= 8 && _simd_s64x8_sqrt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_sqrt_
		} else if (S >= 4 && _simd_s64x4_sqrt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_sqrt_
		} else if (S >= 2 && _simd_s64x2_sqrt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CBRT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cbrt_
		} else if (S >= 64 && _simd_s64x64_cbrt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x32_cbrt_
		} else if (S >= 32 && _simd_s64x32_cbrt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x16_cbrt_
		} else if (S >= 16 && _simd_s64x16_cbrt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x8_cbrt_
		} else if (S >= 8 && _simd_s64x8_cbrt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x4_cbrt_
		} else if (S >= 4 && _simd_s64x4_cbrt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s64x2_cbrt_
		} else if (S >= 2 && _simd_s64x2_cbrt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s64x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FMA> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fma_
		} else if (S >= 64 && _simd_u64x64_fma_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x32_fma_
		} else if (S >= 32 && _simd_u64x32_fma_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x16_fma_
		} else if (S >= 16 && _simd_u64x16_fma_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x8_fma_
		} else if (S >= 8 && _simd_u64x8_fma_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x4_fma_
		} else if (S >= 4 && _simd_u64x4_fma_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x2_fma_
		} else if (S >= 2 && _simd_u64x2_fma_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FMS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fms_
		} else if (S >= 64 && _simd_u64x64_fms_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x32_fms_
		} else if (S >= 32 && _simd_u64x32_fms_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x16_fms_
		} else if (S >= 16 && _simd_u64x16_fms_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x8_fms_
		} else if (S >= 8 && _simd_u64x8_fms_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x4_fms_
		} else if (S >= 4 && _simd_u64x4_fms_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u64x2_fms_
		} else if (S >= 2 && _simd_u64x2_fms_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ADD> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_add_
		} else if (S >= 64 && _simd_u64x64_add_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_add_
		} else if (S >= 32 && _simd_u64x32_add_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_add_
		} else if (S >= 16 && _simd_u64x16_add_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_add_
		} else if (S >= 8 && _simd_u64x8_add_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_add_
		} else if (S >= 4 && _simd_u64x4_add_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_add_
		} else if (S >= 2 && _simd_u64x2_add_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SUB> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sub_
		} else if (S >= 64 && _simd_u64x64_sub_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_sub_
		} else if (S >= 32 && _simd_u64x32_sub_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_sub_
		} else if (S >= 16 && _simd_u64x16_sub_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_sub_
		} else if (S >= 8 && _simd_u64x8_sub_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_sub_
		} else if (S >= 4 && _simd_u64x4_sub_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_sub_
		} else if (S >= 2 && _simd_u64x2_sub_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MUL> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_mul_
		} else if (S >= 64 && _simd_u64x64_mul_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_mul_
		} else if (S >= 32 && _simd_u64x32_mul_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_mul_
		} else if (S >= 16 && _simd_u64x16_mul_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_mul_
		} else if (S >= 8 && _simd_u64x8_mul_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_mul_
		} else if (S >= 4 && _simd_u64x4_mul_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_mul_
		} else if (S >= 2 && _simd_u64x2_mul_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_DIV> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_div_
		} else if (S >= 64 && _simd_u64x64_div_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_div_
		} else if (S >= 32 && _simd_u64x32_div_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_div_
		} else if (S >= 16 && _simd_u64x16_div_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_div_
		} else if (S >= 8 && _simd_u64x8_div_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_div_
		} else if (S >= 4 && _simd_u64x4_div_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_div_
		} else if (S >= 2 && _simd_u64x2_div_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_min_
		} else if (S >= 64 && _simd_u64x64_min_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_min_
		} else if (S >= 32 && _simd_u64x32_min_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_min_
		} else if (S >= 16 && _simd_u64x16_min_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_min_
		} else if (S >= 8 && _simd_u64x8_min_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_min_
		} else if (S >= 4 && _simd_u64x4_min_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_min_
		} else if (S >= 2 && _simd_u64x2_min_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MAX> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_max_
		} else if (S >= 64 && _simd_u64x64_max_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_max_
		} else if (S >= 32 && _simd_u64x32_max_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_max_
		} else if (S >= 16 && _simd_u64x16_max_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_max_
		} else if (S >= 8 && _simd_u64x8_max_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_max_
		} else if (S >= 4 && _simd_u64x4_max_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_max_
		} else if (S >= 2 && _simd_u64x2_max_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPEQ> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpeq_
		} else if (S >= 64 && _simd_u64x64_cmpeq_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmpeq_
		} else if (S >= 32 && _simd_u64x32_cmpeq_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmpeq_
		} else if (S >= 16 && _simd_u64x16_cmpeq_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmpeq_
		} else if (S >= 8 && _simd_u64x8_cmpeq_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmpeq_
		} else if (S >= 4 && _simd_u64x4_cmpeq_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmpeq_
		} else if (S >= 2 && _simd_u64x2_cmpeq_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPNE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpne_
		} else if (S >= 64 && _simd_u64x64_cmpne_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmpne_
		} else if (S >= 32 && _simd_u64x32_cmpne_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmpne_
		} else if (S >= 16 && _simd_u64x16_cmpne_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmpne_
		} else if (S >= 8 && _simd_u64x8_cmpne_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmpne_
		} else if (S >= 4 && _simd_u64x4_cmpne_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmpne_
		} else if (S >= 2 && _simd_u64x2_cmpne_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPLT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmplt_
		} else if (S >= 64 && _simd_u64x64_cmplt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmplt_
		} else if (S >= 32 && _simd_u64x32_cmplt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmplt_
		} else if (S >= 16 && _simd_u64x16_cmplt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmplt_
		} else if (S >= 8 && _simd_u64x8_cmplt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmplt_
		} else if (S >= 4 && _simd_u64x4_cmplt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmplt_
		} else if (S >= 2 && _simd_u64x2_cmplt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPGT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpgt_
		} else if (S >= 64 && _simd_u64x64_cmpgt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmpgt_
		} else if (S >= 32 && _simd_u64x32_cmpgt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmpgt_
		} else if (S >= 16 && _simd_u64x16_cmpgt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmpgt_
		} else if (S >= 8 && _simd_u64x8_cmpgt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmpgt_
		} else if (S >= 4 && _simd_u64x4_cmpgt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmpgt_
		} else if (S >= 2 && _simd_u64x2_cmpgt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPLE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmple_
		} else if (S >= 64 && _simd_u64x64_cmple_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmple_
		} else if (S >= 32 && _simd_u64x32_cmple_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmple_
		} else if (S >= 16 && _simd_u64x16_cmple_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmple_
		} else if (S >= 8 && _simd_u64x8_cmple_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmple_
		} else if (S >= 4 && _simd_u64x4_cmple_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmple_
		} else if (S >= 2 && _simd_u64x2_cmple_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPGE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpge_
		} else if (S >= 64 && _simd_u64x64_cmpge_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_cmpge_
		} else if (S >= 32 && _simd_u64x32_cmpge_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_cmpge_
		} else if (S >= 16 && _simd_u64x16_cmpge_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_cmpge_
		} else if (S >= 8 && _simd_u64x8_cmpge_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_cmpge_
		} else if (S >= 4 && _simd_u64x4_cmpge_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_cmpge_
		} else if (S >= 2 && _simd_u64x2_cmpge_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_AND> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_and_
		} else if (S >= 64 && _simd_u64x64_and_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_and_
		} else if (S >= 32 && _simd_u64x32_and_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_and_
		} else if (S >= 16 && _simd_u64x16_and_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_and_
		} else if (S >= 8 && _simd_u64x8_and_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_and_
		} else if (S >= 4 && _simd_u64x4_and_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_and_
		} else if (S >= 2 && _simd_u64x2_and_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_OR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_or_
		} else if (S >= 64 && _simd_u64x64_or_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_or_
		} else if (S >= 32 && _simd_u64x32_or_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_or_
		} else if (S >= 16 && _simd_u64x16_or_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_or_
		} else if (S >= 8 && _simd_u64x8_or_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_or_
		} else if (S >= 4 && _simd_u64x4_or_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_or_
		} else if (S >= 2 && _simd_u64x2_or_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_XOR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_xor_
		} else if (S >= 64 && _simd_u64x64_xor_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_xor_
		} else if (S >= 32 && _simd_u64x32_xor_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_xor_
		} else if (S >= 16 && _simd_u64x16_xor_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_xor_
		} else if (S >= 8 && _simd_u64x8_xor_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_xor_
		} else if (S >= 4 && _simd_u64x4_xor_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_xor_
		} else if (S >= 2 && _simd_u64x2_xor_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_lshift_
		} else if (S >= 64 && _simd_u64x64_lshift_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_lshift_
		} else if (S >= 32 && _simd_u64x32_lshift_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_lshift_
		} else if (S >= 16 && _simd_u64x16_lshift_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_lshift_
		} else if (S >= 8 && _simd_u64x8_lshift_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_lshift_
		} else if (S >= 4 && _simd_u64x4_lshift_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_lshift_
		} else if (S >= 2 && _simd_u64x2_lshift_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_RSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_rshift_
		} else if (S >= 64 && _simd_u64x64_rshift_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_rshift_
		} else if (S >= 32 && _simd_u64x32_rshift_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_rshift_
		} else if (S >= 16 && _simd_u64x16_rshift_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_rshift_
		} else if (S >= 8 && _simd_u64x8_rshift_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_rshift_
		} else if (S >= 4 && _simd_u64x4_rshift_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_rshift_
		} else if (S >= 2 && _simd_u64x2_rshift_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ATAN2> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_atan2_
		} else if (S >= 64 && _simd_u64x64_atan2_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x32_atan2_
		} else if (S >= 32 && _simd_u64x32_atan2_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x16_atan2_
		} else if (S >= 16 && _simd_u64x16_atan2_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x8_atan2_
		} else if (S >= 8 && _simd_u64x8_atan2_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x4_atan2_
		} else if (S >= 4 && _simd_u64x4_atan2_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u64x2_atan2_
		} else if (S >= 2 && _simd_u64x2_atan2_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_REFLECT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_reflect_
		} else if (S >= 64 && _simd_u64x64_reflect_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_reflect_
		} else if (S >= 32 && _simd_u64x32_reflect_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_reflect_
		} else if (S >= 16 && _simd_u64x16_reflect_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_reflect_
		} else if (S >= 8 && _simd_u64x8_reflect_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_reflect_
		} else if (S >= 4 && _simd_u64x4_reflect_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_reflect_
		} else if (S >= 2 && _simd_u64x2_reflect_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_NOT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_not_
		} else if (S >= 64 && _simd_u64x64_not_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_not_
		} else if (S >= 32 && _simd_u64x32_not_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_not_
		} else if (S >= 16 && _simd_u64x16_not_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_not_
		} else if (S >= 8 && _simd_u64x8_not_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_not_
		} else if (S >= 4 && _simd_u64x4_not_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_not_
		} else if (S >= 2 && _simd_u64x2_not_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ABS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_abs_
		} else if (S >= 64 && _simd_u64x64_abs_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_abs_
		} else if (S >= 32 && _simd_u64x32_abs_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_abs_
		} else if (S >= 16 && _simd_u64x16_abs_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_abs_
		} else if (S >= 8 && _simd_u64x8_abs_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_abs_
		} else if (S >= 4 && _simd_u64x4_abs_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_abs_
		} else if (S >= 2 && _simd_u64x2_abs_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_EXP> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_exp_
		} else if (S >= 64 && _simd_u64x64_exp_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_exp_
		} else if (S >= 32 && _simd_u64x32_exp_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_exp_
		} else if (S >= 16 && _simd_u64x16_exp_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_exp_
		} else if (S >= 8 && _simd_u64x8_exp_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_exp_
		} else if (S >= 4 && _simd_u64x4_exp_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_exp_
		} else if (S >= 2 && _simd_u64x2_exp_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log_
		} else if (S >= 64 && _simd_u64x64_log_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_log_
		} else if (S >= 32 && _simd_u64x32_log_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_log_
		} else if (S >= 16 && _simd_u64x16_log_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_log_
		} else if (S >= 8 && _simd_u64x8_log_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_log_
		} else if (S >= 4 && _simd_u64x4_log_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_log_
		} else if (S >= 2 && _simd_u64x2_log_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG2> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log2_
		} else if (S >= 64 && _simd_u64x64_log2_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_log2_
		} else if (S >= 32 && _simd_u64x32_log2_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_log2_
		} else if (S >= 16 && _simd_u64x16_log2_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_log2_
		} else if (S >= 8 && _simd_u64x8_log2_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_log2_
		} else if (S >= 4 && _simd_u64x4_log2_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_log2_
		} else if (S >= 2 && _simd_u64x2_log2_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG10> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log10_
		} else if (S >= 64 && _simd_u64x64_log10_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_log10_
		} else if (S >= 32 && _simd_u64x32_log10_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_log10_
		} else if (S >= 16 && _simd_u64x16_log10_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_log10_
		} else if (S >= 8 && _simd_u64x8_log10_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_log10_
		} else if (S >= 4 && _simd_u64x4_log10_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_log10_
		} else if (S >= 2 && _simd_u64x2_log10_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CEIL> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_ceil_
		} else if (S >= 64 && _simd_u64x64_ceil_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_ceil_
		} else if (S >= 32 && _simd_u64x32_ceil_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_ceil_
		} else if (S >= 16 && _simd_u64x16_ceil_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_ceil_
		} else if (S >= 8 && _simd_u64x8_ceil_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_ceil_
		} else if (S >= 4 && _simd_u64x4_ceil_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_ceil_
		} else if (S >= 2 && _simd_u64x2_ceil_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FLOOR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_floor_
		} else if (S >= 64 && _simd_u64x64_floor_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_floor_
		} else if (S >= 32 && _simd_u64x32_floor_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_floor_
		} else if (S >= 16 && _simd_u64x16_floor_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_floor_
		} else if (S >= 8 && _simd_u64x8_floor_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_floor_
		} else if (S >= 4 && _simd_u64x4_floor_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_floor_
		} else if (S >= 2 && _simd_u64x2_floor_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ROUND> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_round_
		} else if (S >= 64 && _simd_u64x64_round_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_round_
		} else if (S >= 32 && _simd_u64x32_round_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_round_
		} else if (S >= 16 && _simd_u64x16_round_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_round_
		} else if (S >= 8 && _simd_u64x8_round_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_round_
		} else if (S >= 4 && _simd_u64x4_round_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_round_
		} else if (S >= 2 && _simd_u64x2_round_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sin_
		} else if (S >= 64 && _simd_u64x64_sin_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_sin_
		} else if (S >= 32 && _simd_u64x32_sin_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_sin_
		} else if (S >= 16 && _simd_u64x16_sin_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_sin_
		} else if (S >= 8 && _simd_u64x8_sin_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_sin_
		} else if (S >= 4 && _simd_u64x4_sin_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_sin_
		} else if (S >= 2 && _simd_u64x2_sin_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_COS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cos_
		} else if (S >= 64 && _simd_u64x64_cos_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_cos_
		} else if (S >= 32 && _simd_u64x32_cos_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_cos_
		} else if (S >= 16 && _simd_u64x16_cos_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_cos_
		} else if (S >= 8 && _simd_u64x8_cos_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_cos_
		} else if (S >= 4 && _simd_u64x4_cos_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_cos_
		} else if (S >= 2 && _simd_u64x2_cos_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_TAN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_tan_
		} else if (S >= 64 && _simd_u64x64_tan_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_tan_
		} else if (S >= 32 && _simd_u64x32_tan_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_tan_
		} else if (S >= 16 && _simd_u64x16_tan_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_tan_
		} else if (S >= 8 && _simd_u64x8_tan_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_tan_
		} else if (S >= 4 && _simd_u64x4_tan_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_tan_
		} else if (S >= 2 && _simd_u64x2_tan_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ASIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_asin_
		} else if (S >= 64 && _simd_u64x64_asin_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_asin_
		} else if (S >= 32 && _simd_u64x32_asin_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_asin_
		} else if (S >= 16 && _simd_u64x16_asin_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_asin_
		} else if (S >= 8 && _simd_u64x8_asin_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_asin_
		} else if (S >= 4 && _simd_u64x4_asin_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_asin_
		} else if (S >= 2 && _simd_u64x2_asin_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ACOS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_acos_
		} else if (S >= 64 && _simd_u64x64_acos_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_acos_
		} else if (S >= 32 && _simd_u64x32_acos_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_acos_
		} else if (S >= 16 && _simd_u64x16_acos_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_acos_
		} else if (S >= 8 && _simd_u64x8_acos_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_acos_
		} else if (S >= 4 && _simd_u64x4_acos_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_acos_
		} else if (S >= 2 && _simd_u64x2_acos_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ATAN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_atan_
		} else if (S >= 64 && _simd_u64x64_atan_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_atan_
		} else if (S >= 32 && _simd_u64x32_atan_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_atan_
		} else if (S >= 16 && _simd_u64x16_atan_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_atan_
		} else if (S >= 8 && _simd_u64x8_atan_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_atan_
		} else if (S >= 4 && _simd_u64x4_atan_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_atan_
		} else if (S >= 2 && _simd_u64x2_atan_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SINH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sinh_
		} else if (S >= 64 && _simd_u64x64_sinh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_sinh_
		} else if (S >= 32 && _simd_u64x32_sinh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_sinh_
		} else if (S >= 16 && _simd_u64x16_sinh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_sinh_
		} else if (S >= 8 && _simd_u64x8_sinh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_sinh_
		} else if (S >= 4 && _simd_u64x4_sinh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_sinh_
		} else if (S >= 2 && _simd_u64x2_sinh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_COSH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cosh_
		} else if (S >= 64 && _simd_u64x64_cosh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_cosh_
		} else if (S >= 32 && _simd_u64x32_cosh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_cosh_
		} else if (S >= 16 && _simd_u64x16_cosh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_cosh_
		} else if (S >= 8 && _simd_u64x8_cosh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_cosh_
		} else if (S >= 4 && _simd_u64x4_cosh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_cosh_
		} else if (S >= 2 && _simd_u64x2_cosh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_TANH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_tanh_
		} else if (S >= 64 && _simd_u64x64_tanh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_tanh_
		} else if (S >= 32 && _simd_u64x32_tanh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_tanh_
		} else if (S >= 16 && _simd_u64x16_tanh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_tanh_
		} else if (S >= 8 && _simd_u64x8_tanh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_tanh_
		} else if (S >= 4 && _simd_u64x4_tanh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_tanh_
		} else if (S >= 2 && _simd_u64x2_tanh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SQRT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sqrt_
		} else if (S >= 64 && _simd_u64x64_sqrt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_sqrt_
		} else if (S >= 32 && _simd_u64x32_sqrt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_sqrt_
		} else if (S >= 16 && _simd_u64x16_sqrt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_sqrt_
		} else if (S >= 8 && _simd_u64x8_sqrt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_sqrt_
		} else if (S >= 4 && _simd_u64x4_sqrt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_sqrt_
		} else if (S >= 2 && _simd_u64x2_sqrt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CBRT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cbrt_
		} else if (S >= 64 && _simd_u64x64_cbrt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x32_cbrt_
		} else if (S >= 32 && _simd_u64x32_cbrt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x16_cbrt_
		} else if (S >= 16 && _simd_u64x16_cbrt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x8_cbrt_
		} else if (S >= 8 && _simd_u64x8_cbrt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x4_cbrt_
		} else if (S >= 4 && _simd_u64x4_cbrt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u64x2_cbrt_
		} else if (S >= 2 && _simd_u64x2_cbrt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u64x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FMA> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fma_
		} else if (S >= 64 && _simd_s32x64_fma_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x32_fma_
		} else if (S >= 32 && _simd_s32x32_fma_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x16_fma_
		} else if (S >= 16 && _simd_s32x16_fma_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x8_fma_
		} else if (S >= 8 && _simd_s32x8_fma_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x4_fma_
		} else if (S >= 4 && _simd_s32x4_fma_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x2_fma_
		} else if (S >= 2 && _simd_s32x2_fma_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FMS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fms_
		} else if (S >= 64 && _simd_s32x64_fms_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x32_fms_
		} else if (S >= 32 && _simd_s32x32_fms_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x16_fms_
		} else if (S >= 16 && _simd_s32x16_fms_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x8_fms_
		} else if (S >= 8 && _simd_s32x8_fms_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x4_fms_
		} else if (S >= 4 && _simd_s32x4_fms_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s32x2_fms_
		} else if (S >= 2 && _simd_s32x2_fms_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ADD> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_add_
		} else if (S >= 64 && _simd_s32x64_add_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_add_
		} else if (S >= 32 && _simd_s32x32_add_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_add_
		} else if (S >= 16 && _simd_s32x16_add_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_add_
		} else if (S >= 8 && _simd_s32x8_add_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_add_
		} else if (S >= 4 && _simd_s32x4_add_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_add_
		} else if (S >= 2 && _simd_s32x2_add_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SUB> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sub_
		} else if (S >= 64 && _simd_s32x64_sub_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_sub_
		} else if (S >= 32 && _simd_s32x32_sub_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_sub_
		} else if (S >= 16 && _simd_s32x16_sub_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_sub_
		} else if (S >= 8 && _simd_s32x8_sub_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_sub_
		} else if (S >= 4 && _simd_s32x4_sub_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_sub_
		} else if (S >= 2 && _simd_s32x2_sub_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MUL> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_mul_
		} else if (S >= 64 && _simd_s32x64_mul_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_mul_
		} else if (S >= 32 && _simd_s32x32_mul_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_mul_
		} else if (S >= 16 && _simd_s32x16_mul_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_mul_
		} else if (S >= 8 && _simd_s32x8_mul_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_mul_
		} else if (S >= 4 && _simd_s32x4_mul_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_mul_
		} else if (S >= 2 && _simd_s32x2_mul_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_DIV> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_div_
		} else if (S >= 64 && _simd_s32x64_div_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_div_
		} else if (S >= 32 && _simd_s32x32_div_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_div_
		} else if (S >= 16 && _simd_s32x16_div_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_div_
		} else if (S >= 8 && _simd_s32x8_div_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_div_
		} else if (S >= 4 && _simd_s32x4_div_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_div_
		} else if (S >= 2 && _simd_s32x2_div_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_min_
		} else if (S >= 64 && _simd_s32x64_min_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_min_
		} else if (S >= 32 && _simd_s32x32_min_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_min_
		} else if (S >= 16 && _simd_s32x16_min_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_min_
		} else if (S >= 8 && _simd_s32x8_min_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_min_
		} else if (S >= 4 && _simd_s32x4_min_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_min_
		} else if (S >= 2 && _simd_s32x2_min_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MAX> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_max_
		} else if (S >= 64 && _simd_s32x64_max_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_max_
		} else if (S >= 32 && _simd_s32x32_max_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_max_
		} else if (S >= 16 && _simd_s32x16_max_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_max_
		} else if (S >= 8 && _simd_s32x8_max_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_max_
		} else if (S >= 4 && _simd_s32x4_max_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_max_
		} else if (S >= 2 && _simd_s32x2_max_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPEQ> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpeq_
		} else if (S >= 64 && _simd_s32x64_cmpeq_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmpeq_
		} else if (S >= 32 && _simd_s32x32_cmpeq_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmpeq_
		} else if (S >= 16 && _simd_s32x16_cmpeq_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmpeq_
		} else if (S >= 8 && _simd_s32x8_cmpeq_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmpeq_
		} else if (S >= 4 && _simd_s32x4_cmpeq_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmpeq_
		} else if (S >= 2 && _simd_s32x2_cmpeq_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPNE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpne_
		} else if (S >= 64 && _simd_s32x64_cmpne_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmpne_
		} else if (S >= 32 && _simd_s32x32_cmpne_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmpne_
		} else if (S >= 16 && _simd_s32x16_cmpne_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmpne_
		} else if (S >= 8 && _simd_s32x8_cmpne_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmpne_
		} else if (S >= 4 && _simd_s32x4_cmpne_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmpne_
		} else if (S >= 2 && _simd_s32x2_cmpne_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPLT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmplt_
		} else if (S >= 64 && _simd_s32x64_cmplt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmplt_
		} else if (S >= 32 && _simd_s32x32_cmplt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmplt_
		} else if (S >= 16 && _simd_s32x16_cmplt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmplt_
		} else if (S >= 8 && _simd_s32x8_cmplt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmplt_
		} else if (S >= 4 && _simd_s32x4_cmplt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmplt_
		} else if (S >= 2 && _simd_s32x2_cmplt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPGT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpgt_
		} else if (S >= 64 && _simd_s32x64_cmpgt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmpgt_
		} else if (S >= 32 && _simd_s32x32_cmpgt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmpgt_
		} else if (S >= 16 && _simd_s32x16_cmpgt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmpgt_
		} else if (S >= 8 && _simd_s32x8_cmpgt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmpgt_
		} else if (S >= 4 && _simd_s32x4_cmpgt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmpgt_
		} else if (S >= 2 && _simd_s32x2_cmpgt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPLE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmple_
		} else if (S >= 64 && _simd_s32x64_cmple_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmple_
		} else if (S >= 32 && _simd_s32x32_cmple_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmple_
		} else if (S >= 16 && _simd_s32x16_cmple_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmple_
		} else if (S >= 8 && _simd_s32x8_cmple_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmple_
		} else if (S >= 4 && _simd_s32x4_cmple_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmple_
		} else if (S >= 2 && _simd_s32x2_cmple_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPGE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpge_
		} else if (S >= 64 && _simd_s32x64_cmpge_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_cmpge_
		} else if (S >= 32 && _simd_s32x32_cmpge_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_cmpge_
		} else if (S >= 16 && _simd_s32x16_cmpge_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_cmpge_
		} else if (S >= 8 && _simd_s32x8_cmpge_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_cmpge_
		} else if (S >= 4 && _simd_s32x4_cmpge_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_cmpge_
		} else if (S >= 2 && _simd_s32x2_cmpge_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_AND> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_and_
		} else if (S >= 64 && _simd_s32x64_and_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_and_
		} else if (S >= 32 && _simd_s32x32_and_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_and_
		} else if (S >= 16 && _simd_s32x16_and_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_and_
		} else if (S >= 8 && _simd_s32x8_and_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_and_
		} else if (S >= 4 && _simd_s32x4_and_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_and_
		} else if (S >= 2 && _simd_s32x2_and_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_OR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_or_
		} else if (S >= 64 && _simd_s32x64_or_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_or_
		} else if (S >= 32 && _simd_s32x32_or_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_or_
		} else if (S >= 16 && _simd_s32x16_or_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_or_
		} else if (S >= 8 && _simd_s32x8_or_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_or_
		} else if (S >= 4 && _simd_s32x4_or_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_or_
		} else if (S >= 2 && _simd_s32x2_or_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_XOR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_xor_
		} else if (S >= 64 && _simd_s32x64_xor_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_xor_
		} else if (S >= 32 && _simd_s32x32_xor_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_xor_
		} else if (S >= 16 && _simd_s32x16_xor_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_xor_
		} else if (S >= 8 && _simd_s32x8_xor_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_xor_
		} else if (S >= 4 && _simd_s32x4_xor_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_xor_
		} else if (S >= 2 && _simd_s32x2_xor_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_lshift_
		} else if (S >= 64 && _simd_s32x64_lshift_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_lshift_
		} else if (S >= 32 && _simd_s32x32_lshift_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_lshift_
		} else if (S >= 16 && _simd_s32x16_lshift_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_lshift_
		} else if (S >= 8 && _simd_s32x8_lshift_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_lshift_
		} else if (S >= 4 && _simd_s32x4_lshift_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_lshift_
		} else if (S >= 2 && _simd_s32x2_lshift_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_RSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_rshift_
		} else if (S >= 64 && _simd_s32x64_rshift_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_rshift_
		} else if (S >= 32 && _simd_s32x32_rshift_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_rshift_
		} else if (S >= 16 && _simd_s32x16_rshift_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_rshift_
		} else if (S >= 8 && _simd_s32x8_rshift_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_rshift_
		} else if (S >= 4 && _simd_s32x4_rshift_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_rshift_
		} else if (S >= 2 && _simd_s32x2_rshift_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ATAN2> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_atan2_
		} else if (S >= 64 && _simd_s32x64_atan2_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x32_atan2_
		} else if (S >= 32 && _simd_s32x32_atan2_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x16_atan2_
		} else if (S >= 16 && _simd_s32x16_atan2_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x8_atan2_
		} else if (S >= 8 && _simd_s32x8_atan2_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x4_atan2_
		} else if (S >= 4 && _simd_s32x4_atan2_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s32x2_atan2_
		} else if (S >= 2 && _simd_s32x2_atan2_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_REFLECT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_reflect_
		} else if (S >= 64 && _simd_s32x64_reflect_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_reflect_
		} else if (S >= 32 && _simd_s32x32_reflect_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_reflect_
		} else if (S >= 16 && _simd_s32x16_reflect_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_reflect_
		} else if (S >= 8 && _simd_s32x8_reflect_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_reflect_
		} else if (S >= 4 && _simd_s32x4_reflect_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_reflect_
		} else if (S >= 2 && _simd_s32x2_reflect_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_NOT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_not_
		} else if (S >= 64 && _simd_s32x64_not_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_not_
		} else if (S >= 32 && _simd_s32x32_not_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_not_
		} else if (S >= 16 && _simd_s32x16_not_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_not_
		} else if (S >= 8 && _simd_s32x8_not_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_not_
		} else if (S >= 4 && _simd_s32x4_not_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_not_
		} else if (S >= 2 && _simd_s32x2_not_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ABS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_abs_
		} else if (S >= 64 && _simd_s32x64_abs_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_abs_
		} else if (S >= 32 && _simd_s32x32_abs_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_abs_
		} else if (S >= 16 && _simd_s32x16_abs_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_abs_
		} else if (S >= 8 && _simd_s32x8_abs_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_abs_
		} else if (S >= 4 && _simd_s32x4_abs_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_abs_
		} else if (S >= 2 && _simd_s32x2_abs_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_EXP> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_exp_
		} else if (S >= 64 && _simd_s32x64_exp_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_exp_
		} else if (S >= 32 && _simd_s32x32_exp_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_exp_
		} else if (S >= 16 && _simd_s32x16_exp_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_exp_
		} else if (S >= 8 && _simd_s32x8_exp_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_exp_
		} else if (S >= 4 && _simd_s32x4_exp_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_exp_
		} else if (S >= 2 && _simd_s32x2_exp_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log_
		} else if (S >= 64 && _simd_s32x64_log_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_log_
		} else if (S >= 32 && _simd_s32x32_log_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_log_
		} else if (S >= 16 && _simd_s32x16_log_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_log_
		} else if (S >= 8 && _simd_s32x8_log_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_log_
		} else if (S >= 4 && _simd_s32x4_log_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_log_
		} else if (S >= 2 && _simd_s32x2_log_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG2> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log2_
		} else if (S >= 64 && _simd_s32x64_log2_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_log2_
		} else if (S >= 32 && _simd_s32x32_log2_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_log2_
		} else if (S >= 16 && _simd_s32x16_log2_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_log2_
		} else if (S >= 8 && _simd_s32x8_log2_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_log2_
		} else if (S >= 4 && _simd_s32x4_log2_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_log2_
		} else if (S >= 2 && _simd_s32x2_log2_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG10> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log10_
		} else if (S >= 64 && _simd_s32x64_log10_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_log10_
		} else if (S >= 32 && _simd_s32x32_log10_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_log10_
		} else if (S >= 16 && _simd_s32x16_log10_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_log10_
		} else if (S >= 8 && _simd_s32x8_log10_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_log10_
		} else if (S >= 4 && _simd_s32x4_log10_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_log10_
		} else if (S >= 2 && _simd_s32x2_log10_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CEIL> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_ceil_
		} else if (S >= 64 && _simd_s32x64_ceil_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_ceil_
		} else if (S >= 32 && _simd_s32x32_ceil_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_ceil_
		} else if (S >= 16 && _simd_s32x16_ceil_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_ceil_
		} else if (S >= 8 && _simd_s32x8_ceil_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_ceil_
		} else if (S >= 4 && _simd_s32x4_ceil_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_ceil_
		} else if (S >= 2 && _simd_s32x2_ceil_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FLOOR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_floor_
		} else if (S >= 64 && _simd_s32x64_floor_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_floor_
		} else if (S >= 32 && _simd_s32x32_floor_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_floor_
		} else if (S >= 16 && _simd_s32x16_floor_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_floor_
		} else if (S >= 8 && _simd_s32x8_floor_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_floor_
		} else if (S >= 4 && _simd_s32x4_floor_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_floor_
		} else if (S >= 2 && _simd_s32x2_floor_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ROUND> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_round_
		} else if (S >= 64 && _simd_s32x64_round_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_round_
		} else if (S >= 32 && _simd_s32x32_round_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_round_
		} else if (S >= 16 && _simd_s32x16_round_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_round_
		} else if (S >= 8 && _simd_s32x8_round_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_round_
		} else if (S >= 4 && _simd_s32x4_round_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_round_
		} else if (S >= 2 && _simd_s32x2_round_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sin_
		} else if (S >= 64 && _simd_s32x64_sin_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_sin_
		} else if (S >= 32 && _simd_s32x32_sin_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_sin_
		} else if (S >= 16 && _simd_s32x16_sin_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_sin_
		} else if (S >= 8 && _simd_s32x8_sin_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_sin_
		} else if (S >= 4 && _simd_s32x4_sin_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_sin_
		} else if (S >= 2 && _simd_s32x2_sin_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_COS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cos_
		} else if (S >= 64 && _simd_s32x64_cos_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_cos_
		} else if (S >= 32 && _simd_s32x32_cos_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_cos_
		} else if (S >= 16 && _simd_s32x16_cos_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_cos_
		} else if (S >= 8 && _simd_s32x8_cos_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_cos_
		} else if (S >= 4 && _simd_s32x4_cos_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_cos_
		} else if (S >= 2 && _simd_s32x2_cos_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_TAN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_tan_
		} else if (S >= 64 && _simd_s32x64_tan_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_tan_
		} else if (S >= 32 && _simd_s32x32_tan_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_tan_
		} else if (S >= 16 && _simd_s32x16_tan_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_tan_
		} else if (S >= 8 && _simd_s32x8_tan_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_tan_
		} else if (S >= 4 && _simd_s32x4_tan_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_tan_
		} else if (S >= 2 && _simd_s32x2_tan_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ASIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_asin_
		} else if (S >= 64 && _simd_s32x64_asin_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_asin_
		} else if (S >= 32 && _simd_s32x32_asin_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_asin_
		} else if (S >= 16 && _simd_s32x16_asin_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_asin_
		} else if (S >= 8 && _simd_s32x8_asin_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_asin_
		} else if (S >= 4 && _simd_s32x4_asin_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_asin_
		} else if (S >= 2 && _simd_s32x2_asin_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ACOS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_acos_
		} else if (S >= 64 && _simd_s32x64_acos_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_acos_
		} else if (S >= 32 && _simd_s32x32_acos_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_acos_
		} else if (S >= 16 && _simd_s32x16_acos_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_acos_
		} else if (S >= 8 && _simd_s32x8_acos_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_acos_
		} else if (S >= 4 && _simd_s32x4_acos_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_acos_
		} else if (S >= 2 && _simd_s32x2_acos_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ATAN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_atan_
		} else if (S >= 64 && _simd_s32x64_atan_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_atan_
		} else if (S >= 32 && _simd_s32x32_atan_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_atan_
		} else if (S >= 16 && _simd_s32x16_atan_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_atan_
		} else if (S >= 8 && _simd_s32x8_atan_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_atan_
		} else if (S >= 4 && _simd_s32x4_atan_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_atan_
		} else if (S >= 2 && _simd_s32x2_atan_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SINH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sinh_
		} else if (S >= 64 && _simd_s32x64_sinh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_sinh_
		} else if (S >= 32 && _simd_s32x32_sinh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_sinh_
		} else if (S >= 16 && _simd_s32x16_sinh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_sinh_
		} else if (S >= 8 && _simd_s32x8_sinh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_sinh_
		} else if (S >= 4 && _simd_s32x4_sinh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_sinh_
		} else if (S >= 2 && _simd_s32x2_sinh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_COSH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cosh_
		} else if (S >= 64 && _simd_s32x64_cosh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_cosh_
		} else if (S >= 32 && _simd_s32x32_cosh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_cosh_
		} else if (S >= 16 && _simd_s32x16_cosh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_cosh_
		} else if (S >= 8 && _simd_s32x8_cosh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_cosh_
		} else if (S >= 4 && _simd_s32x4_cosh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_cosh_
		} else if (S >= 2 && _simd_s32x2_cosh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_TANH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_tanh_
		} else if (S >= 64 && _simd_s32x64_tanh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_tanh_
		} else if (S >= 32 && _simd_s32x32_tanh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_tanh_
		} else if (S >= 16 && _simd_s32x16_tanh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_tanh_
		} else if (S >= 8 && _simd_s32x8_tanh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_tanh_
		} else if (S >= 4 && _simd_s32x4_tanh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_tanh_
		} else if (S >= 2 && _simd_s32x2_tanh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SQRT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sqrt_
		} else if (S >= 64 && _simd_s32x64_sqrt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_sqrt_
		} else if (S >= 32 && _simd_s32x32_sqrt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_sqrt_
		} else if (S >= 16 && _simd_s32x16_sqrt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_sqrt_
		} else if (S >= 8 && _simd_s32x8_sqrt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_sqrt_
		} else if (S >= 4 && _simd_s32x4_sqrt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_sqrt_
		} else if (S >= 2 && _simd_s32x2_sqrt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CBRT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cbrt_
		} else if (S >= 64 && _simd_s32x64_cbrt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x32_cbrt_
		} else if (S >= 32 && _simd_s32x32_cbrt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x16_cbrt_
		} else if (S >= 16 && _simd_s32x16_cbrt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x8_cbrt_
		} else if (S >= 8 && _simd_s32x8_cbrt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x4_cbrt_
		} else if (S >= 4 && _simd_s32x4_cbrt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s32x2_cbrt_
		} else if (S >= 2 && _simd_s32x2_cbrt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s32x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FMA> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fma_
		} else if (S >= 64 && _simd_u32x64_fma_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x32_fma_
		} else if (S >= 32 && _simd_u32x32_fma_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x16_fma_
		} else if (S >= 16 && _simd_u32x16_fma_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x8_fma_
		} else if (S >= 8 && _simd_u32x8_fma_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x4_fma_
		} else if (S >= 4 && _simd_u32x4_fma_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x2_fma_
		} else if (S >= 2 && _simd_u32x2_fma_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FMS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fms_
		} else if (S >= 64 && _simd_u32x64_fms_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x32_fms_
		} else if (S >= 32 && _simd_u32x32_fms_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x16_fms_
		} else if (S >= 16 && _simd_u32x16_fms_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x8_fms_
		} else if (S >= 8 && _simd_u32x8_fms_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x4_fms_
		} else if (S >= 4 && _simd_u32x4_fms_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u32x2_fms_
		} else if (S >= 2 && _simd_u32x2_fms_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ADD> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_add_
		} else if (S >= 64 && _simd_u32x64_add_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_add_
		} else if (S >= 32 && _simd_u32x32_add_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_add_
		} else if (S >= 16 && _simd_u32x16_add_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_add_
		} else if (S >= 8 && _simd_u32x8_add_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_add_
		} else if (S >= 4 && _simd_u32x4_add_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_add_
		} else if (S >= 2 && _simd_u32x2_add_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SUB> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sub_
		} else if (S >= 64 && _simd_u32x64_sub_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_sub_
		} else if (S >= 32 && _simd_u32x32_sub_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_sub_
		} else if (S >= 16 && _simd_u32x16_sub_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_sub_
		} else if (S >= 8 && _simd_u32x8_sub_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_sub_
		} else if (S >= 4 && _simd_u32x4_sub_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_sub_
		} else if (S >= 2 && _simd_u32x2_sub_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MUL> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_mul_
		} else if (S >= 64 && _simd_u32x64_mul_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_mul_
		} else if (S >= 32 && _simd_u32x32_mul_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_mul_
		} else if (S >= 16 && _simd_u32x16_mul_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_mul_
		} else if (S >= 8 && _simd_u32x8_mul_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_mul_
		} else if (S >= 4 && _simd_u32x4_mul_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_mul_
		} else if (S >= 2 && _simd_u32x2_mul_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_DIV> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_div_
		} else if (S >= 64 && _simd_u32x64_div_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_div_
		} else if (S >= 32 && _simd_u32x32_div_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_div_
		} else if (S >= 16 && _simd_u32x16_div_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_div_
		} else if (S >= 8 && _simd_u32x8_div_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_div_
		} else if (S >= 4 && _simd_u32x4_div_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_div_
		} else if (S >= 2 && _simd_u32x2_div_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_min_
		} else if (S >= 64 && _simd_u32x64_min_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_min_
		} else if (S >= 32 && _simd_u32x32_min_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_min_
		} else if (S >= 16 && _simd_u32x16_min_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_min_
		} else if (S >= 8 && _simd_u32x8_min_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_min_
		} else if (S >= 4 && _simd_u32x4_min_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_min_
		} else if (S >= 2 && _simd_u32x2_min_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MAX> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_max_
		} else if (S >= 64 && _simd_u32x64_max_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_max_
		} else if (S >= 32 && _simd_u32x32_max_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_max_
		} else if (S >= 16 && _simd_u32x16_max_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_max_
		} else if (S >= 8 && _simd_u32x8_max_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_max_
		} else if (S >= 4 && _simd_u32x4_max_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_max_
		} else if (S >= 2 && _simd_u32x2_max_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPEQ> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpeq_
		} else if (S >= 64 && _simd_u32x64_cmpeq_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmpeq_
		} else if (S >= 32 && _simd_u32x32_cmpeq_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmpeq_
		} else if (S >= 16 && _simd_u32x16_cmpeq_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmpeq_
		} else if (S >= 8 && _simd_u32x8_cmpeq_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmpeq_
		} else if (S >= 4 && _simd_u32x4_cmpeq_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmpeq_
		} else if (S >= 2 && _simd_u32x2_cmpeq_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPNE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpne_
		} else if (S >= 64 && _simd_u32x64_cmpne_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmpne_
		} else if (S >= 32 && _simd_u32x32_cmpne_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmpne_
		} else if (S >= 16 && _simd_u32x16_cmpne_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmpne_
		} else if (S >= 8 && _simd_u32x8_cmpne_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmpne_
		} else if (S >= 4 && _simd_u32x4_cmpne_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmpne_
		} else if (S >= 2 && _simd_u32x2_cmpne_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPLT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmplt_
		} else if (S >= 64 && _simd_u32x64_cmplt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmplt_
		} else if (S >= 32 && _simd_u32x32_cmplt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmplt_
		} else if (S >= 16 && _simd_u32x16_cmplt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmplt_
		} else if (S >= 8 && _simd_u32x8_cmplt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmplt_
		} else if (S >= 4 && _simd_u32x4_cmplt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmplt_
		} else if (S >= 2 && _simd_u32x2_cmplt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPGT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpgt_
		} else if (S >= 64 && _simd_u32x64_cmpgt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmpgt_
		} else if (S >= 32 && _simd_u32x32_cmpgt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmpgt_
		} else if (S >= 16 && _simd_u32x16_cmpgt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmpgt_
		} else if (S >= 8 && _simd_u32x8_cmpgt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmpgt_
		} else if (S >= 4 && _simd_u32x4_cmpgt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmpgt_
		} else if (S >= 2 && _simd_u32x2_cmpgt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPLE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmple_
		} else if (S >= 64 && _simd_u32x64_cmple_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmple_
		} else if (S >= 32 && _simd_u32x32_cmple_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmple_
		} else if (S >= 16 && _simd_u32x16_cmple_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmple_
		} else if (S >= 8 && _simd_u32x8_cmple_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmple_
		} else if (S >= 4 && _simd_u32x4_cmple_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmple_
		} else if (S >= 2 && _simd_u32x2_cmple_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPGE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpge_
		} else if (S >= 64 && _simd_u32x64_cmpge_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_cmpge_
		} else if (S >= 32 && _simd_u32x32_cmpge_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_cmpge_
		} else if (S >= 16 && _simd_u32x16_cmpge_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_cmpge_
		} else if (S >= 8 && _simd_u32x8_cmpge_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_cmpge_
		} else if (S >= 4 && _simd_u32x4_cmpge_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_cmpge_
		} else if (S >= 2 && _simd_u32x2_cmpge_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_AND> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_and_
		} else if (S >= 64 && _simd_u32x64_and_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_and_
		} else if (S >= 32 && _simd_u32x32_and_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_and_
		} else if (S >= 16 && _simd_u32x16_and_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_and_
		} else if (S >= 8 && _simd_u32x8_and_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_and_
		} else if (S >= 4 && _simd_u32x4_and_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_and_
		} else if (S >= 2 && _simd_u32x2_and_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_OR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_or_
		} else if (S >= 64 && _simd_u32x64_or_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_or_
		} else if (S >= 32 && _simd_u32x32_or_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_or_
		} else if (S >= 16 && _simd_u32x16_or_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_or_
		} else if (S >= 8 && _simd_u32x8_or_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_or_
		} else if (S >= 4 && _simd_u32x4_or_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_or_
		} else if (S >= 2 && _simd_u32x2_or_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_XOR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_xor_
		} else if (S >= 64 && _simd_u32x64_xor_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_xor_
		} else if (S >= 32 && _simd_u32x32_xor_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_xor_
		} else if (S >= 16 && _simd_u32x16_xor_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_xor_
		} else if (S >= 8 && _simd_u32x8_xor_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_xor_
		} else if (S >= 4 && _simd_u32x4_xor_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_xor_
		} else if (S >= 2 && _simd_u32x2_xor_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_lshift_
		} else if (S >= 64 && _simd_u32x64_lshift_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_lshift_
		} else if (S >= 32 && _simd_u32x32_lshift_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_lshift_
		} else if (S >= 16 && _simd_u32x16_lshift_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_lshift_
		} else if (S >= 8 && _simd_u32x8_lshift_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_lshift_
		} else if (S >= 4 && _simd_u32x4_lshift_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_lshift_
		} else if (S >= 2 && _simd_u32x2_lshift_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_RSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_rshift_
		} else if (S >= 64 && _simd_u32x64_rshift_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_rshift_
		} else if (S >= 32 && _simd_u32x32_rshift_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_rshift_
		} else if (S >= 16 && _simd_u32x16_rshift_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_rshift_
		} else if (S >= 8 && _simd_u32x8_rshift_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_rshift_
		} else if (S >= 4 && _simd_u32x4_rshift_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_rshift_
		} else if (S >= 2 && _simd_u32x2_rshift_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ATAN2> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_atan2_
		} else if (S >= 64 && _simd_u32x64_atan2_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x32_atan2_
		} else if (S >= 32 && _simd_u32x32_atan2_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x16_atan2_
		} else if (S >= 16 && _simd_u32x16_atan2_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x8_atan2_
		} else if (S >= 8 && _simd_u32x8_atan2_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x4_atan2_
		} else if (S >= 4 && _simd_u32x4_atan2_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u32x2_atan2_
		} else if (S >= 2 && _simd_u32x2_atan2_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_REFLECT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_reflect_
		} else if (S >= 64 && _simd_u32x64_reflect_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_reflect_
		} else if (S >= 32 && _simd_u32x32_reflect_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_reflect_
		} else if (S >= 16 && _simd_u32x16_reflect_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_reflect_
		} else if (S >= 8 && _simd_u32x8_reflect_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_reflect_
		} else if (S >= 4 && _simd_u32x4_reflect_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_reflect_
		} else if (S >= 2 && _simd_u32x2_reflect_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_NOT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_not_
		} else if (S >= 64 && _simd_u32x64_not_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_not_
		} else if (S >= 32 && _simd_u32x32_not_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_not_
		} else if (S >= 16 && _simd_u32x16_not_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_not_
		} else if (S >= 8 && _simd_u32x8_not_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_not_
		} else if (S >= 4 && _simd_u32x4_not_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_not_
		} else if (S >= 2 && _simd_u32x2_not_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ABS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_abs_
		} else if (S >= 64 && _simd_u32x64_abs_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_abs_
		} else if (S >= 32 && _simd_u32x32_abs_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_abs_
		} else if (S >= 16 && _simd_u32x16_abs_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_abs_
		} else if (S >= 8 && _simd_u32x8_abs_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_abs_
		} else if (S >= 4 && _simd_u32x4_abs_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_abs_
		} else if (S >= 2 && _simd_u32x2_abs_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_EXP> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_exp_
		} else if (S >= 64 && _simd_u32x64_exp_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_exp_
		} else if (S >= 32 && _simd_u32x32_exp_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_exp_
		} else if (S >= 16 && _simd_u32x16_exp_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_exp_
		} else if (S >= 8 && _simd_u32x8_exp_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_exp_
		} else if (S >= 4 && _simd_u32x4_exp_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_exp_
		} else if (S >= 2 && _simd_u32x2_exp_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log_
		} else if (S >= 64 && _simd_u32x64_log_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_log_
		} else if (S >= 32 && _simd_u32x32_log_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_log_
		} else if (S >= 16 && _simd_u32x16_log_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_log_
		} else if (S >= 8 && _simd_u32x8_log_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_log_
		} else if (S >= 4 && _simd_u32x4_log_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_log_
		} else if (S >= 2 && _simd_u32x2_log_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG2> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log2_
		} else if (S >= 64 && _simd_u32x64_log2_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_log2_
		} else if (S >= 32 && _simd_u32x32_log2_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_log2_
		} else if (S >= 16 && _simd_u32x16_log2_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_log2_
		} else if (S >= 8 && _simd_u32x8_log2_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_log2_
		} else if (S >= 4 && _simd_u32x4_log2_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_log2_
		} else if (S >= 2 && _simd_u32x2_log2_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG10> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log10_
		} else if (S >= 64 && _simd_u32x64_log10_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_log10_
		} else if (S >= 32 && _simd_u32x32_log10_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_log10_
		} else if (S >= 16 && _simd_u32x16_log10_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_log10_
		} else if (S >= 8 && _simd_u32x8_log10_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_log10_
		} else if (S >= 4 && _simd_u32x4_log10_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_log10_
		} else if (S >= 2 && _simd_u32x2_log10_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CEIL> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_ceil_
		} else if (S >= 64 && _simd_u32x64_ceil_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_ceil_
		} else if (S >= 32 && _simd_u32x32_ceil_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_ceil_
		} else if (S >= 16 && _simd_u32x16_ceil_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_ceil_
		} else if (S >= 8 && _simd_u32x8_ceil_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_ceil_
		} else if (S >= 4 && _simd_u32x4_ceil_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_ceil_
		} else if (S >= 2 && _simd_u32x2_ceil_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FLOOR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_floor_
		} else if (S >= 64 && _simd_u32x64_floor_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_floor_
		} else if (S >= 32 && _simd_u32x32_floor_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_floor_
		} else if (S >= 16 && _simd_u32x16_floor_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_floor_
		} else if (S >= 8 && _simd_u32x8_floor_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_floor_
		} else if (S >= 4 && _simd_u32x4_floor_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_floor_
		} else if (S >= 2 && _simd_u32x2_floor_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ROUND> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_round_
		} else if (S >= 64 && _simd_u32x64_round_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_round_
		} else if (S >= 32 && _simd_u32x32_round_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_round_
		} else if (S >= 16 && _simd_u32x16_round_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_round_
		} else if (S >= 8 && _simd_u32x8_round_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_round_
		} else if (S >= 4 && _simd_u32x4_round_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_round_
		} else if (S >= 2 && _simd_u32x2_round_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sin_
		} else if (S >= 64 && _simd_u32x64_sin_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_sin_
		} else if (S >= 32 && _simd_u32x32_sin_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_sin_
		} else if (S >= 16 && _simd_u32x16_sin_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_sin_
		} else if (S >= 8 && _simd_u32x8_sin_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_sin_
		} else if (S >= 4 && _simd_u32x4_sin_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_sin_
		} else if (S >= 2 && _simd_u32x2_sin_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_COS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cos_
		} else if (S >= 64 && _simd_u32x64_cos_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_cos_
		} else if (S >= 32 && _simd_u32x32_cos_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_cos_
		} else if (S >= 16 && _simd_u32x16_cos_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_cos_
		} else if (S >= 8 && _simd_u32x8_cos_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_cos_
		} else if (S >= 4 && _simd_u32x4_cos_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_cos_
		} else if (S >= 2 && _simd_u32x2_cos_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_TAN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_tan_
		} else if (S >= 64 && _simd_u32x64_tan_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_tan_
		} else if (S >= 32 && _simd_u32x32_tan_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_tan_
		} else if (S >= 16 && _simd_u32x16_tan_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_tan_
		} else if (S >= 8 && _simd_u32x8_tan_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_tan_
		} else if (S >= 4 && _simd_u32x4_tan_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_tan_
		} else if (S >= 2 && _simd_u32x2_tan_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ASIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_asin_
		} else if (S >= 64 && _simd_u32x64_asin_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_asin_
		} else if (S >= 32 && _simd_u32x32_asin_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_asin_
		} else if (S >= 16 && _simd_u32x16_asin_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_asin_
		} else if (S >= 8 && _simd_u32x8_asin_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_asin_
		} else if (S >= 4 && _simd_u32x4_asin_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_asin_
		} else if (S >= 2 && _simd_u32x2_asin_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ACOS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_acos_
		} else if (S >= 64 && _simd_u32x64_acos_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_acos_
		} else if (S >= 32 && _simd_u32x32_acos_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_acos_
		} else if (S >= 16 && _simd_u32x16_acos_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_acos_
		} else if (S >= 8 && _simd_u32x8_acos_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_acos_
		} else if (S >= 4 && _simd_u32x4_acos_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_acos_
		} else if (S >= 2 && _simd_u32x2_acos_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ATAN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_atan_
		} else if (S >= 64 && _simd_u32x64_atan_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_atan_
		} else if (S >= 32 && _simd_u32x32_atan_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_atan_
		} else if (S >= 16 && _simd_u32x16_atan_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_atan_
		} else if (S >= 8 && _simd_u32x8_atan_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_atan_
		} else if (S >= 4 && _simd_u32x4_atan_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_atan_
		} else if (S >= 2 && _simd_u32x2_atan_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SINH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sinh_
		} else if (S >= 64 && _simd_u32x64_sinh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_sinh_
		} else if (S >= 32 && _simd_u32x32_sinh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_sinh_
		} else if (S >= 16 && _simd_u32x16_sinh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_sinh_
		} else if (S >= 8 && _simd_u32x8_sinh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_sinh_
		} else if (S >= 4 && _simd_u32x4_sinh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_sinh_
		} else if (S >= 2 && _simd_u32x2_sinh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_COSH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cosh_
		} else if (S >= 64 && _simd_u32x64_cosh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_cosh_
		} else if (S >= 32 && _simd_u32x32_cosh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_cosh_
		} else if (S >= 16 && _simd_u32x16_cosh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_cosh_
		} else if (S >= 8 && _simd_u32x8_cosh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_cosh_
		} else if (S >= 4 && _simd_u32x4_cosh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_cosh_
		} else if (S >= 2 && _simd_u32x2_cosh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_TANH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_tanh_
		} else if (S >= 64 && _simd_u32x64_tanh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_tanh_
		} else if (S >= 32 && _simd_u32x32_tanh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_tanh_
		} else if (S >= 16 && _simd_u32x16_tanh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_tanh_
		} else if (S >= 8 && _simd_u32x8_tanh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_tanh_
		} else if (S >= 4 && _simd_u32x4_tanh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_tanh_
		} else if (S >= 2 && _simd_u32x2_tanh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SQRT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sqrt_
		} else if (S >= 64 && _simd_u32x64_sqrt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_sqrt_
		} else if (S >= 32 && _simd_u32x32_sqrt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_sqrt_
		} else if (S >= 16 && _simd_u32x16_sqrt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_sqrt_
		} else if (S >= 8 && _simd_u32x8_sqrt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_sqrt_
		} else if (S >= 4 && _simd_u32x4_sqrt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_sqrt_
		} else if (S >= 2 && _simd_u32x2_sqrt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CBRT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cbrt_
		} else if (S >= 64 && _simd_u32x64_cbrt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x32_cbrt_
		} else if (S >= 32 && _simd_u32x32_cbrt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x16_cbrt_
		} else if (S >= 16 && _simd_u32x16_cbrt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x8_cbrt_
		} else if (S >= 8 && _simd_u32x8_cbrt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x4_cbrt_
		} else if (S >= 4 && _simd_u32x4_cbrt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u32x2_cbrt_
		} else if (S >= 2 && _simd_u32x2_cbrt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u32x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FMA> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fma_
		} else if (S >= 64 && _simd_s16x64_fma_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x32_fma_
		} else if (S >= 32 && _simd_s16x32_fma_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x16_fma_
		} else if (S >= 16 && _simd_s16x16_fma_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x8_fma_
		} else if (S >= 8 && _simd_s16x8_fma_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x4_fma_
		} else if (S >= 4 && _simd_s16x4_fma_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x2_fma_
		} else if (S >= 2 && _simd_s16x2_fma_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FMS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fms_
		} else if (S >= 64 && _simd_s16x64_fms_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x32_fms_
		} else if (S >= 32 && _simd_s16x32_fms_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x16_fms_
		} else if (S >= 16 && _simd_s16x16_fms_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x8_fms_
		} else if (S >= 8 && _simd_s16x8_fms_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x4_fms_
		} else if (S >= 4 && _simd_s16x4_fms_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s16x2_fms_
		} else if (S >= 2 && _simd_s16x2_fms_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ADD> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_add_
		} else if (S >= 64 && _simd_s16x64_add_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_add_
		} else if (S >= 32 && _simd_s16x32_add_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_add_
		} else if (S >= 16 && _simd_s16x16_add_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_add_
		} else if (S >= 8 && _simd_s16x8_add_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_add_
		} else if (S >= 4 && _simd_s16x4_add_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_add_
		} else if (S >= 2 && _simd_s16x2_add_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SUB> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sub_
		} else if (S >= 64 && _simd_s16x64_sub_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_sub_
		} else if (S >= 32 && _simd_s16x32_sub_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_sub_
		} else if (S >= 16 && _simd_s16x16_sub_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_sub_
		} else if (S >= 8 && _simd_s16x8_sub_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_sub_
		} else if (S >= 4 && _simd_s16x4_sub_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_sub_
		} else if (S >= 2 && _simd_s16x2_sub_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MUL> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_mul_
		} else if (S >= 64 && _simd_s16x64_mul_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_mul_
		} else if (S >= 32 && _simd_s16x32_mul_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_mul_
		} else if (S >= 16 && _simd_s16x16_mul_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_mul_
		} else if (S >= 8 && _simd_s16x8_mul_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_mul_
		} else if (S >= 4 && _simd_s16x4_mul_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_mul_
		} else if (S >= 2 && _simd_s16x2_mul_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_DIV> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_div_
		} else if (S >= 64 && _simd_s16x64_div_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_div_
		} else if (S >= 32 && _simd_s16x32_div_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_div_
		} else if (S >= 16 && _simd_s16x16_div_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_div_
		} else if (S >= 8 && _simd_s16x8_div_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_div_
		} else if (S >= 4 && _simd_s16x4_div_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_div_
		} else if (S >= 2 && _simd_s16x2_div_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_min_
		} else if (S >= 64 && _simd_s16x64_min_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_min_
		} else if (S >= 32 && _simd_s16x32_min_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_min_
		} else if (S >= 16 && _simd_s16x16_min_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_min_
		} else if (S >= 8 && _simd_s16x8_min_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_min_
		} else if (S >= 4 && _simd_s16x4_min_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_min_
		} else if (S >= 2 && _simd_s16x2_min_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MAX> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_max_
		} else if (S >= 64 && _simd_s16x64_max_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_max_
		} else if (S >= 32 && _simd_s16x32_max_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_max_
		} else if (S >= 16 && _simd_s16x16_max_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_max_
		} else if (S >= 8 && _simd_s16x8_max_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_max_
		} else if (S >= 4 && _simd_s16x4_max_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_max_
		} else if (S >= 2 && _simd_s16x2_max_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPEQ> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpeq_
		} else if (S >= 64 && _simd_s16x64_cmpeq_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmpeq_
		} else if (S >= 32 && _simd_s16x32_cmpeq_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmpeq_
		} else if (S >= 16 && _simd_s16x16_cmpeq_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmpeq_
		} else if (S >= 8 && _simd_s16x8_cmpeq_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmpeq_
		} else if (S >= 4 && _simd_s16x4_cmpeq_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmpeq_
		} else if (S >= 2 && _simd_s16x2_cmpeq_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPNE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpne_
		} else if (S >= 64 && _simd_s16x64_cmpne_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmpne_
		} else if (S >= 32 && _simd_s16x32_cmpne_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmpne_
		} else if (S >= 16 && _simd_s16x16_cmpne_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmpne_
		} else if (S >= 8 && _simd_s16x8_cmpne_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmpne_
		} else if (S >= 4 && _simd_s16x4_cmpne_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmpne_
		} else if (S >= 2 && _simd_s16x2_cmpne_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPLT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmplt_
		} else if (S >= 64 && _simd_s16x64_cmplt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmplt_
		} else if (S >= 32 && _simd_s16x32_cmplt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmplt_
		} else if (S >= 16 && _simd_s16x16_cmplt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmplt_
		} else if (S >= 8 && _simd_s16x8_cmplt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmplt_
		} else if (S >= 4 && _simd_s16x4_cmplt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmplt_
		} else if (S >= 2 && _simd_s16x2_cmplt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPGT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpgt_
		} else if (S >= 64 && _simd_s16x64_cmpgt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmpgt_
		} else if (S >= 32 && _simd_s16x32_cmpgt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmpgt_
		} else if (S >= 16 && _simd_s16x16_cmpgt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmpgt_
		} else if (S >= 8 && _simd_s16x8_cmpgt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmpgt_
		} else if (S >= 4 && _simd_s16x4_cmpgt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmpgt_
		} else if (S >= 2 && _simd_s16x2_cmpgt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPLE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmple_
		} else if (S >= 64 && _simd_s16x64_cmple_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmple_
		} else if (S >= 32 && _simd_s16x32_cmple_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmple_
		} else if (S >= 16 && _simd_s16x16_cmple_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmple_
		} else if (S >= 8 && _simd_s16x8_cmple_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmple_
		} else if (S >= 4 && _simd_s16x4_cmple_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmple_
		} else if (S >= 2 && _simd_s16x2_cmple_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPGE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpge_
		} else if (S >= 64 && _simd_s16x64_cmpge_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_cmpge_
		} else if (S >= 32 && _simd_s16x32_cmpge_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_cmpge_
		} else if (S >= 16 && _simd_s16x16_cmpge_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_cmpge_
		} else if (S >= 8 && _simd_s16x8_cmpge_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_cmpge_
		} else if (S >= 4 && _simd_s16x4_cmpge_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_cmpge_
		} else if (S >= 2 && _simd_s16x2_cmpge_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_AND> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_and_
		} else if (S >= 64 && _simd_s16x64_and_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_and_
		} else if (S >= 32 && _simd_s16x32_and_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_and_
		} else if (S >= 16 && _simd_s16x16_and_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_and_
		} else if (S >= 8 && _simd_s16x8_and_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_and_
		} else if (S >= 4 && _simd_s16x4_and_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_and_
		} else if (S >= 2 && _simd_s16x2_and_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_OR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_or_
		} else if (S >= 64 && _simd_s16x64_or_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_or_
		} else if (S >= 32 && _simd_s16x32_or_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_or_
		} else if (S >= 16 && _simd_s16x16_or_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_or_
		} else if (S >= 8 && _simd_s16x8_or_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_or_
		} else if (S >= 4 && _simd_s16x4_or_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_or_
		} else if (S >= 2 && _simd_s16x2_or_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_XOR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_xor_
		} else if (S >= 64 && _simd_s16x64_xor_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_xor_
		} else if (S >= 32 && _simd_s16x32_xor_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_xor_
		} else if (S >= 16 && _simd_s16x16_xor_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_xor_
		} else if (S >= 8 && _simd_s16x8_xor_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_xor_
		} else if (S >= 4 && _simd_s16x4_xor_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_xor_
		} else if (S >= 2 && _simd_s16x2_xor_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_lshift_
		} else if (S >= 64 && _simd_s16x64_lshift_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_lshift_
		} else if (S >= 32 && _simd_s16x32_lshift_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_lshift_
		} else if (S >= 16 && _simd_s16x16_lshift_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_lshift_
		} else if (S >= 8 && _simd_s16x8_lshift_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_lshift_
		} else if (S >= 4 && _simd_s16x4_lshift_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_lshift_
		} else if (S >= 2 && _simd_s16x2_lshift_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_RSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_rshift_
		} else if (S >= 64 && _simd_s16x64_rshift_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_rshift_
		} else if (S >= 32 && _simd_s16x32_rshift_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_rshift_
		} else if (S >= 16 && _simd_s16x16_rshift_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_rshift_
		} else if (S >= 8 && _simd_s16x8_rshift_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_rshift_
		} else if (S >= 4 && _simd_s16x4_rshift_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_rshift_
		} else if (S >= 2 && _simd_s16x2_rshift_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ATAN2> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_atan2_
		} else if (S >= 64 && _simd_s16x64_atan2_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x32_atan2_
		} else if (S >= 32 && _simd_s16x32_atan2_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x16_atan2_
		} else if (S >= 16 && _simd_s16x16_atan2_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x8_atan2_
		} else if (S >= 8 && _simd_s16x8_atan2_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x4_atan2_
		} else if (S >= 4 && _simd_s16x4_atan2_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s16x2_atan2_
		} else if (S >= 2 && _simd_s16x2_atan2_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_REFLECT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_reflect_
		} else if (S >= 64 && _simd_s16x64_reflect_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_reflect_
		} else if (S >= 32 && _simd_s16x32_reflect_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_reflect_
		} else if (S >= 16 && _simd_s16x16_reflect_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_reflect_
		} else if (S >= 8 && _simd_s16x8_reflect_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_reflect_
		} else if (S >= 4 && _simd_s16x4_reflect_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_reflect_
		} else if (S >= 2 && _simd_s16x2_reflect_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_NOT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_not_
		} else if (S >= 64 && _simd_s16x64_not_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_not_
		} else if (S >= 32 && _simd_s16x32_not_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_not_
		} else if (S >= 16 && _simd_s16x16_not_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_not_
		} else if (S >= 8 && _simd_s16x8_not_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_not_
		} else if (S >= 4 && _simd_s16x4_not_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_not_
		} else if (S >= 2 && _simd_s16x2_not_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ABS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_abs_
		} else if (S >= 64 && _simd_s16x64_abs_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_abs_
		} else if (S >= 32 && _simd_s16x32_abs_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_abs_
		} else if (S >= 16 && _simd_s16x16_abs_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_abs_
		} else if (S >= 8 && _simd_s16x8_abs_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_abs_
		} else if (S >= 4 && _simd_s16x4_abs_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_abs_
		} else if (S >= 2 && _simd_s16x2_abs_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_EXP> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_exp_
		} else if (S >= 64 && _simd_s16x64_exp_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_exp_
		} else if (S >= 32 && _simd_s16x32_exp_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_exp_
		} else if (S >= 16 && _simd_s16x16_exp_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_exp_
		} else if (S >= 8 && _simd_s16x8_exp_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_exp_
		} else if (S >= 4 && _simd_s16x4_exp_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_exp_
		} else if (S >= 2 && _simd_s16x2_exp_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log_
		} else if (S >= 64 && _simd_s16x64_log_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_log_
		} else if (S >= 32 && _simd_s16x32_log_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_log_
		} else if (S >= 16 && _simd_s16x16_log_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_log_
		} else if (S >= 8 && _simd_s16x8_log_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_log_
		} else if (S >= 4 && _simd_s16x4_log_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_log_
		} else if (S >= 2 && _simd_s16x2_log_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG2> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log2_
		} else if (S >= 64 && _simd_s16x64_log2_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_log2_
		} else if (S >= 32 && _simd_s16x32_log2_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_log2_
		} else if (S >= 16 && _simd_s16x16_log2_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_log2_
		} else if (S >= 8 && _simd_s16x8_log2_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_log2_
		} else if (S >= 4 && _simd_s16x4_log2_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_log2_
		} else if (S >= 2 && _simd_s16x2_log2_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG10> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log10_
		} else if (S >= 64 && _simd_s16x64_log10_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_log10_
		} else if (S >= 32 && _simd_s16x32_log10_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_log10_
		} else if (S >= 16 && _simd_s16x16_log10_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_log10_
		} else if (S >= 8 && _simd_s16x8_log10_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_log10_
		} else if (S >= 4 && _simd_s16x4_log10_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_log10_
		} else if (S >= 2 && _simd_s16x2_log10_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CEIL> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_ceil_
		} else if (S >= 64 && _simd_s16x64_ceil_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_ceil_
		} else if (S >= 32 && _simd_s16x32_ceil_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_ceil_
		} else if (S >= 16 && _simd_s16x16_ceil_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_ceil_
		} else if (S >= 8 && _simd_s16x8_ceil_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_ceil_
		} else if (S >= 4 && _simd_s16x4_ceil_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_ceil_
		} else if (S >= 2 && _simd_s16x2_ceil_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FLOOR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_floor_
		} else if (S >= 64 && _simd_s16x64_floor_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_floor_
		} else if (S >= 32 && _simd_s16x32_floor_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_floor_
		} else if (S >= 16 && _simd_s16x16_floor_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_floor_
		} else if (S >= 8 && _simd_s16x8_floor_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_floor_
		} else if (S >= 4 && _simd_s16x4_floor_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_floor_
		} else if (S >= 2 && _simd_s16x2_floor_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ROUND> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_round_
		} else if (S >= 64 && _simd_s16x64_round_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_round_
		} else if (S >= 32 && _simd_s16x32_round_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_round_
		} else if (S >= 16 && _simd_s16x16_round_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_round_
		} else if (S >= 8 && _simd_s16x8_round_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_round_
		} else if (S >= 4 && _simd_s16x4_round_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_round_
		} else if (S >= 2 && _simd_s16x2_round_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sin_
		} else if (S >= 64 && _simd_s16x64_sin_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_sin_
		} else if (S >= 32 && _simd_s16x32_sin_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_sin_
		} else if (S >= 16 && _simd_s16x16_sin_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_sin_
		} else if (S >= 8 && _simd_s16x8_sin_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_sin_
		} else if (S >= 4 && _simd_s16x4_sin_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_sin_
		} else if (S >= 2 && _simd_s16x2_sin_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_COS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cos_
		} else if (S >= 64 && _simd_s16x64_cos_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_cos_
		} else if (S >= 32 && _simd_s16x32_cos_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_cos_
		} else if (S >= 16 && _simd_s16x16_cos_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_cos_
		} else if (S >= 8 && _simd_s16x8_cos_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_cos_
		} else if (S >= 4 && _simd_s16x4_cos_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_cos_
		} else if (S >= 2 && _simd_s16x2_cos_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_TAN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_tan_
		} else if (S >= 64 && _simd_s16x64_tan_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_tan_
		} else if (S >= 32 && _simd_s16x32_tan_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_tan_
		} else if (S >= 16 && _simd_s16x16_tan_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_tan_
		} else if (S >= 8 && _simd_s16x8_tan_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_tan_
		} else if (S >= 4 && _simd_s16x4_tan_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_tan_
		} else if (S >= 2 && _simd_s16x2_tan_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ASIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_asin_
		} else if (S >= 64 && _simd_s16x64_asin_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_asin_
		} else if (S >= 32 && _simd_s16x32_asin_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_asin_
		} else if (S >= 16 && _simd_s16x16_asin_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_asin_
		} else if (S >= 8 && _simd_s16x8_asin_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_asin_
		} else if (S >= 4 && _simd_s16x4_asin_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_asin_
		} else if (S >= 2 && _simd_s16x2_asin_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ACOS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_acos_
		} else if (S >= 64 && _simd_s16x64_acos_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_acos_
		} else if (S >= 32 && _simd_s16x32_acos_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_acos_
		} else if (S >= 16 && _simd_s16x16_acos_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_acos_
		} else if (S >= 8 && _simd_s16x8_acos_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_acos_
		} else if (S >= 4 && _simd_s16x4_acos_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_acos_
		} else if (S >= 2 && _simd_s16x2_acos_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ATAN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_atan_
		} else if (S >= 64 && _simd_s16x64_atan_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_atan_
		} else if (S >= 32 && _simd_s16x32_atan_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_atan_
		} else if (S >= 16 && _simd_s16x16_atan_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_atan_
		} else if (S >= 8 && _simd_s16x8_atan_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_atan_
		} else if (S >= 4 && _simd_s16x4_atan_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_atan_
		} else if (S >= 2 && _simd_s16x2_atan_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SINH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sinh_
		} else if (S >= 64 && _simd_s16x64_sinh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_sinh_
		} else if (S >= 32 && _simd_s16x32_sinh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_sinh_
		} else if (S >= 16 && _simd_s16x16_sinh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_sinh_
		} else if (S >= 8 && _simd_s16x8_sinh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_sinh_
		} else if (S >= 4 && _simd_s16x4_sinh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_sinh_
		} else if (S >= 2 && _simd_s16x2_sinh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_COSH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cosh_
		} else if (S >= 64 && _simd_s16x64_cosh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_cosh_
		} else if (S >= 32 && _simd_s16x32_cosh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_cosh_
		} else if (S >= 16 && _simd_s16x16_cosh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_cosh_
		} else if (S >= 8 && _simd_s16x8_cosh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_cosh_
		} else if (S >= 4 && _simd_s16x4_cosh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_cosh_
		} else if (S >= 2 && _simd_s16x2_cosh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_TANH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_tanh_
		} else if (S >= 64 && _simd_s16x64_tanh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_tanh_
		} else if (S >= 32 && _simd_s16x32_tanh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_tanh_
		} else if (S >= 16 && _simd_s16x16_tanh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_tanh_
		} else if (S >= 8 && _simd_s16x8_tanh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_tanh_
		} else if (S >= 4 && _simd_s16x4_tanh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_tanh_
		} else if (S >= 2 && _simd_s16x2_tanh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SQRT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sqrt_
		} else if (S >= 64 && _simd_s16x64_sqrt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_sqrt_
		} else if (S >= 32 && _simd_s16x32_sqrt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_sqrt_
		} else if (S >= 16 && _simd_s16x16_sqrt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_sqrt_
		} else if (S >= 8 && _simd_s16x8_sqrt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_sqrt_
		} else if (S >= 4 && _simd_s16x4_sqrt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_sqrt_
		} else if (S >= 2 && _simd_s16x2_sqrt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CBRT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cbrt_
		} else if (S >= 64 && _simd_s16x64_cbrt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x32_cbrt_
		} else if (S >= 32 && _simd_s16x32_cbrt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x16_cbrt_
		} else if (S >= 16 && _simd_s16x16_cbrt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x8_cbrt_
		} else if (S >= 8 && _simd_s16x8_cbrt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x4_cbrt_
		} else if (S >= 4 && _simd_s16x4_cbrt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s16x2_cbrt_
		} else if (S >= 2 && _simd_s16x2_cbrt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s16x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FMA> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fma_
		} else if (S >= 64 && _simd_u16x64_fma_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x32_fma_
		} else if (S >= 32 && _simd_u16x32_fma_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x16_fma_
		} else if (S >= 16 && _simd_u16x16_fma_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x8_fma_
		} else if (S >= 8 && _simd_u16x8_fma_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x4_fma_
		} else if (S >= 4 && _simd_u16x4_fma_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x2_fma_
		} else if (S >= 2 && _simd_u16x2_fma_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FMS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fms_
		} else if (S >= 64 && _simd_u16x64_fms_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x32_fms_
		} else if (S >= 32 && _simd_u16x32_fms_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x16_fms_
		} else if (S >= 16 && _simd_u16x16_fms_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x8_fms_
		} else if (S >= 8 && _simd_u16x8_fms_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x4_fms_
		} else if (S >= 4 && _simd_u16x4_fms_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u16x2_fms_
		} else if (S >= 2 && _simd_u16x2_fms_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ADD> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_add_
		} else if (S >= 64 && _simd_u16x64_add_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_add_
		} else if (S >= 32 && _simd_u16x32_add_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_add_
		} else if (S >= 16 && _simd_u16x16_add_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_add_
		} else if (S >= 8 && _simd_u16x8_add_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_add_
		} else if (S >= 4 && _simd_u16x4_add_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_add_
		} else if (S >= 2 && _simd_u16x2_add_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SUB> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sub_
		} else if (S >= 64 && _simd_u16x64_sub_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_sub_
		} else if (S >= 32 && _simd_u16x32_sub_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_sub_
		} else if (S >= 16 && _simd_u16x16_sub_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_sub_
		} else if (S >= 8 && _simd_u16x8_sub_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_sub_
		} else if (S >= 4 && _simd_u16x4_sub_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_sub_
		} else if (S >= 2 && _simd_u16x2_sub_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MUL> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_mul_
		} else if (S >= 64 && _simd_u16x64_mul_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_mul_
		} else if (S >= 32 && _simd_u16x32_mul_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_mul_
		} else if (S >= 16 && _simd_u16x16_mul_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_mul_
		} else if (S >= 8 && _simd_u16x8_mul_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_mul_
		} else if (S >= 4 && _simd_u16x4_mul_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_mul_
		} else if (S >= 2 && _simd_u16x2_mul_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_DIV> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_div_
		} else if (S >= 64 && _simd_u16x64_div_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_div_
		} else if (S >= 32 && _simd_u16x32_div_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_div_
		} else if (S >= 16 && _simd_u16x16_div_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_div_
		} else if (S >= 8 && _simd_u16x8_div_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_div_
		} else if (S >= 4 && _simd_u16x4_div_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_div_
		} else if (S >= 2 && _simd_u16x2_div_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_min_
		} else if (S >= 64 && _simd_u16x64_min_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_min_
		} else if (S >= 32 && _simd_u16x32_min_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_min_
		} else if (S >= 16 && _simd_u16x16_min_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_min_
		} else if (S >= 8 && _simd_u16x8_min_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_min_
		} else if (S >= 4 && _simd_u16x4_min_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_min_
		} else if (S >= 2 && _simd_u16x2_min_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MAX> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_max_
		} else if (S >= 64 && _simd_u16x64_max_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_max_
		} else if (S >= 32 && _simd_u16x32_max_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_max_
		} else if (S >= 16 && _simd_u16x16_max_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_max_
		} else if (S >= 8 && _simd_u16x8_max_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_max_
		} else if (S >= 4 && _simd_u16x4_max_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_max_
		} else if (S >= 2 && _simd_u16x2_max_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPEQ> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpeq_
		} else if (S >= 64 && _simd_u16x64_cmpeq_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmpeq_
		} else if (S >= 32 && _simd_u16x32_cmpeq_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmpeq_
		} else if (S >= 16 && _simd_u16x16_cmpeq_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmpeq_
		} else if (S >= 8 && _simd_u16x8_cmpeq_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmpeq_
		} else if (S >= 4 && _simd_u16x4_cmpeq_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmpeq_
		} else if (S >= 2 && _simd_u16x2_cmpeq_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPNE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpne_
		} else if (S >= 64 && _simd_u16x64_cmpne_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmpne_
		} else if (S >= 32 && _simd_u16x32_cmpne_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmpne_
		} else if (S >= 16 && _simd_u16x16_cmpne_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmpne_
		} else if (S >= 8 && _simd_u16x8_cmpne_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmpne_
		} else if (S >= 4 && _simd_u16x4_cmpne_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmpne_
		} else if (S >= 2 && _simd_u16x2_cmpne_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPLT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmplt_
		} else if (S >= 64 && _simd_u16x64_cmplt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmplt_
		} else if (S >= 32 && _simd_u16x32_cmplt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmplt_
		} else if (S >= 16 && _simd_u16x16_cmplt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmplt_
		} else if (S >= 8 && _simd_u16x8_cmplt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmplt_
		} else if (S >= 4 && _simd_u16x4_cmplt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmplt_
		} else if (S >= 2 && _simd_u16x2_cmplt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPGT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpgt_
		} else if (S >= 64 && _simd_u16x64_cmpgt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmpgt_
		} else if (S >= 32 && _simd_u16x32_cmpgt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmpgt_
		} else if (S >= 16 && _simd_u16x16_cmpgt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmpgt_
		} else if (S >= 8 && _simd_u16x8_cmpgt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmpgt_
		} else if (S >= 4 && _simd_u16x4_cmpgt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmpgt_
		} else if (S >= 2 && _simd_u16x2_cmpgt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPLE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmple_
		} else if (S >= 64 && _simd_u16x64_cmple_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmple_
		} else if (S >= 32 && _simd_u16x32_cmple_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmple_
		} else if (S >= 16 && _simd_u16x16_cmple_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmple_
		} else if (S >= 8 && _simd_u16x8_cmple_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmple_
		} else if (S >= 4 && _simd_u16x4_cmple_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmple_
		} else if (S >= 2 && _simd_u16x2_cmple_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPGE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpge_
		} else if (S >= 64 && _simd_u16x64_cmpge_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_cmpge_
		} else if (S >= 32 && _simd_u16x32_cmpge_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_cmpge_
		} else if (S >= 16 && _simd_u16x16_cmpge_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_cmpge_
		} else if (S >= 8 && _simd_u16x8_cmpge_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_cmpge_
		} else if (S >= 4 && _simd_u16x4_cmpge_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_cmpge_
		} else if (S >= 2 && _simd_u16x2_cmpge_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_AND> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_and_
		} else if (S >= 64 && _simd_u16x64_and_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_and_
		} else if (S >= 32 && _simd_u16x32_and_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_and_
		} else if (S >= 16 && _simd_u16x16_and_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_and_
		} else if (S >= 8 && _simd_u16x8_and_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_and_
		} else if (S >= 4 && _simd_u16x4_and_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_and_
		} else if (S >= 2 && _simd_u16x2_and_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_OR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_or_
		} else if (S >= 64 && _simd_u16x64_or_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_or_
		} else if (S >= 32 && _simd_u16x32_or_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_or_
		} else if (S >= 16 && _simd_u16x16_or_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_or_
		} else if (S >= 8 && _simd_u16x8_or_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_or_
		} else if (S >= 4 && _simd_u16x4_or_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_or_
		} else if (S >= 2 && _simd_u16x2_or_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_XOR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_xor_
		} else if (S >= 64 && _simd_u16x64_xor_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_xor_
		} else if (S >= 32 && _simd_u16x32_xor_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_xor_
		} else if (S >= 16 && _simd_u16x16_xor_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_xor_
		} else if (S >= 8 && _simd_u16x8_xor_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_xor_
		} else if (S >= 4 && _simd_u16x4_xor_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_xor_
		} else if (S >= 2 && _simd_u16x2_xor_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_lshift_
		} else if (S >= 64 && _simd_u16x64_lshift_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_lshift_
		} else if (S >= 32 && _simd_u16x32_lshift_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_lshift_
		} else if (S >= 16 && _simd_u16x16_lshift_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_lshift_
		} else if (S >= 8 && _simd_u16x8_lshift_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_lshift_
		} else if (S >= 4 && _simd_u16x4_lshift_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_lshift_
		} else if (S >= 2 && _simd_u16x2_lshift_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_RSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_rshift_
		} else if (S >= 64 && _simd_u16x64_rshift_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_rshift_
		} else if (S >= 32 && _simd_u16x32_rshift_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_rshift_
		} else if (S >= 16 && _simd_u16x16_rshift_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_rshift_
		} else if (S >= 8 && _simd_u16x8_rshift_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_rshift_
		} else if (S >= 4 && _simd_u16x4_rshift_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_rshift_
		} else if (S >= 2 && _simd_u16x2_rshift_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ATAN2> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_atan2_
		} else if (S >= 64 && _simd_u16x64_atan2_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x32_atan2_
		} else if (S >= 32 && _simd_u16x32_atan2_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x16_atan2_
		} else if (S >= 16 && _simd_u16x16_atan2_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x8_atan2_
		} else if (S >= 8 && _simd_u16x8_atan2_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x4_atan2_
		} else if (S >= 4 && _simd_u16x4_atan2_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u16x2_atan2_
		} else if (S >= 2 && _simd_u16x2_atan2_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_REFLECT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_reflect_
		} else if (S >= 64 && _simd_u16x64_reflect_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_reflect_
		} else if (S >= 32 && _simd_u16x32_reflect_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_reflect_
		} else if (S >= 16 && _simd_u16x16_reflect_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_reflect_
		} else if (S >= 8 && _simd_u16x8_reflect_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_reflect_
		} else if (S >= 4 && _simd_u16x4_reflect_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_reflect_
		} else if (S >= 2 && _simd_u16x2_reflect_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_NOT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_not_
		} else if (S >= 64 && _simd_u16x64_not_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_not_
		} else if (S >= 32 && _simd_u16x32_not_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_not_
		} else if (S >= 16 && _simd_u16x16_not_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_not_
		} else if (S >= 8 && _simd_u16x8_not_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_not_
		} else if (S >= 4 && _simd_u16x4_not_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_not_
		} else if (S >= 2 && _simd_u16x2_not_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ABS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_abs_
		} else if (S >= 64 && _simd_u16x64_abs_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_abs_
		} else if (S >= 32 && _simd_u16x32_abs_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_abs_
		} else if (S >= 16 && _simd_u16x16_abs_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_abs_
		} else if (S >= 8 && _simd_u16x8_abs_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_abs_
		} else if (S >= 4 && _simd_u16x4_abs_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_abs_
		} else if (S >= 2 && _simd_u16x2_abs_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_EXP> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_exp_
		} else if (S >= 64 && _simd_u16x64_exp_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_exp_
		} else if (S >= 32 && _simd_u16x32_exp_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_exp_
		} else if (S >= 16 && _simd_u16x16_exp_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_exp_
		} else if (S >= 8 && _simd_u16x8_exp_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_exp_
		} else if (S >= 4 && _simd_u16x4_exp_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_exp_
		} else if (S >= 2 && _simd_u16x2_exp_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log_
		} else if (S >= 64 && _simd_u16x64_log_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_log_
		} else if (S >= 32 && _simd_u16x32_log_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_log_
		} else if (S >= 16 && _simd_u16x16_log_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_log_
		} else if (S >= 8 && _simd_u16x8_log_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_log_
		} else if (S >= 4 && _simd_u16x4_log_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_log_
		} else if (S >= 2 && _simd_u16x2_log_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG2> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log2_
		} else if (S >= 64 && _simd_u16x64_log2_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_log2_
		} else if (S >= 32 && _simd_u16x32_log2_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_log2_
		} else if (S >= 16 && _simd_u16x16_log2_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_log2_
		} else if (S >= 8 && _simd_u16x8_log2_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_log2_
		} else if (S >= 4 && _simd_u16x4_log2_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_log2_
		} else if (S >= 2 && _simd_u16x2_log2_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG10> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log10_
		} else if (S >= 64 && _simd_u16x64_log10_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_log10_
		} else if (S >= 32 && _simd_u16x32_log10_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_log10_
		} else if (S >= 16 && _simd_u16x16_log10_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_log10_
		} else if (S >= 8 && _simd_u16x8_log10_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_log10_
		} else if (S >= 4 && _simd_u16x4_log10_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_log10_
		} else if (S >= 2 && _simd_u16x2_log10_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CEIL> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_ceil_
		} else if (S >= 64 && _simd_u16x64_ceil_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_ceil_
		} else if (S >= 32 && _simd_u16x32_ceil_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_ceil_
		} else if (S >= 16 && _simd_u16x16_ceil_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_ceil_
		} else if (S >= 8 && _simd_u16x8_ceil_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_ceil_
		} else if (S >= 4 && _simd_u16x4_ceil_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_ceil_
		} else if (S >= 2 && _simd_u16x2_ceil_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FLOOR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_floor_
		} else if (S >= 64 && _simd_u16x64_floor_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_floor_
		} else if (S >= 32 && _simd_u16x32_floor_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_floor_
		} else if (S >= 16 && _simd_u16x16_floor_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_floor_
		} else if (S >= 8 && _simd_u16x8_floor_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_floor_
		} else if (S >= 4 && _simd_u16x4_floor_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_floor_
		} else if (S >= 2 && _simd_u16x2_floor_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ROUND> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_round_
		} else if (S >= 64 && _simd_u16x64_round_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_round_
		} else if (S >= 32 && _simd_u16x32_round_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_round_
		} else if (S >= 16 && _simd_u16x16_round_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_round_
		} else if (S >= 8 && _simd_u16x8_round_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_round_
		} else if (S >= 4 && _simd_u16x4_round_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_round_
		} else if (S >= 2 && _simd_u16x2_round_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sin_
		} else if (S >= 64 && _simd_u16x64_sin_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_sin_
		} else if (S >= 32 && _simd_u16x32_sin_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_sin_
		} else if (S >= 16 && _simd_u16x16_sin_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_sin_
		} else if (S >= 8 && _simd_u16x8_sin_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_sin_
		} else if (S >= 4 && _simd_u16x4_sin_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_sin_
		} else if (S >= 2 && _simd_u16x2_sin_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_COS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cos_
		} else if (S >= 64 && _simd_u16x64_cos_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_cos_
		} else if (S >= 32 && _simd_u16x32_cos_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_cos_
		} else if (S >= 16 && _simd_u16x16_cos_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_cos_
		} else if (S >= 8 && _simd_u16x8_cos_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_cos_
		} else if (S >= 4 && _simd_u16x4_cos_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_cos_
		} else if (S >= 2 && _simd_u16x2_cos_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_TAN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_tan_
		} else if (S >= 64 && _simd_u16x64_tan_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_tan_
		} else if (S >= 32 && _simd_u16x32_tan_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_tan_
		} else if (S >= 16 && _simd_u16x16_tan_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_tan_
		} else if (S >= 8 && _simd_u16x8_tan_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_tan_
		} else if (S >= 4 && _simd_u16x4_tan_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_tan_
		} else if (S >= 2 && _simd_u16x2_tan_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ASIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_asin_
		} else if (S >= 64 && _simd_u16x64_asin_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_asin_
		} else if (S >= 32 && _simd_u16x32_asin_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_asin_
		} else if (S >= 16 && _simd_u16x16_asin_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_asin_
		} else if (S >= 8 && _simd_u16x8_asin_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_asin_
		} else if (S >= 4 && _simd_u16x4_asin_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_asin_
		} else if (S >= 2 && _simd_u16x2_asin_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ACOS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_acos_
		} else if (S >= 64 && _simd_u16x64_acos_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_acos_
		} else if (S >= 32 && _simd_u16x32_acos_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_acos_
		} else if (S >= 16 && _simd_u16x16_acos_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_acos_
		} else if (S >= 8 && _simd_u16x8_acos_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_acos_
		} else if (S >= 4 && _simd_u16x4_acos_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_acos_
		} else if (S >= 2 && _simd_u16x2_acos_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ATAN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_atan_
		} else if (S >= 64 && _simd_u16x64_atan_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_atan_
		} else if (S >= 32 && _simd_u16x32_atan_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_atan_
		} else if (S >= 16 && _simd_u16x16_atan_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_atan_
		} else if (S >= 8 && _simd_u16x8_atan_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_atan_
		} else if (S >= 4 && _simd_u16x4_atan_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_atan_
		} else if (S >= 2 && _simd_u16x2_atan_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SINH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sinh_
		} else if (S >= 64 && _simd_u16x64_sinh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_sinh_
		} else if (S >= 32 && _simd_u16x32_sinh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_sinh_
		} else if (S >= 16 && _simd_u16x16_sinh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_sinh_
		} else if (S >= 8 && _simd_u16x8_sinh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_sinh_
		} else if (S >= 4 && _simd_u16x4_sinh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_sinh_
		} else if (S >= 2 && _simd_u16x2_sinh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_COSH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cosh_
		} else if (S >= 64 && _simd_u16x64_cosh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_cosh_
		} else if (S >= 32 && _simd_u16x32_cosh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_cosh_
		} else if (S >= 16 && _simd_u16x16_cosh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_cosh_
		} else if (S >= 8 && _simd_u16x8_cosh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_cosh_
		} else if (S >= 4 && _simd_u16x4_cosh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_cosh_
		} else if (S >= 2 && _simd_u16x2_cosh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_TANH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_tanh_
		} else if (S >= 64 && _simd_u16x64_tanh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_tanh_
		} else if (S >= 32 && _simd_u16x32_tanh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_tanh_
		} else if (S >= 16 && _simd_u16x16_tanh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_tanh_
		} else if (S >= 8 && _simd_u16x8_tanh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_tanh_
		} else if (S >= 4 && _simd_u16x4_tanh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_tanh_
		} else if (S >= 2 && _simd_u16x2_tanh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SQRT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sqrt_
		} else if (S >= 64 && _simd_u16x64_sqrt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_sqrt_
		} else if (S >= 32 && _simd_u16x32_sqrt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_sqrt_
		} else if (S >= 16 && _simd_u16x16_sqrt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_sqrt_
		} else if (S >= 8 && _simd_u16x8_sqrt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_sqrt_
		} else if (S >= 4 && _simd_u16x4_sqrt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_sqrt_
		} else if (S >= 2 && _simd_u16x2_sqrt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CBRT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cbrt_
		} else if (S >= 64 && _simd_u16x64_cbrt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x32_cbrt_
		} else if (S >= 32 && _simd_u16x32_cbrt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x16_cbrt_
		} else if (S >= 16 && _simd_u16x16_cbrt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x8_cbrt_
		} else if (S >= 8 && _simd_u16x8_cbrt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x4_cbrt_
		} else if (S >= 4 && _simd_u16x4_cbrt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u16x2_cbrt_
		} else if (S >= 2 && _simd_u16x2_cbrt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u16x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FMA> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fma_
		} else if (S >= 64 && _simd_s8x64_fma_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x32_fma_
		} else if (S >= 32 && _simd_s8x32_fma_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x16_fma_
		} else if (S >= 16 && _simd_s8x16_fma_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x8_fma_
		} else if (S >= 8 && _simd_s8x8_fma_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x4_fma_
		} else if (S >= 4 && _simd_s8x4_fma_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x2_fma_
		} else if (S >= 2 && _simd_s8x2_fma_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FMS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fms_
		} else if (S >= 64 && _simd_s8x64_fms_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x32_fms_
		} else if (S >= 32 && _simd_s8x32_fms_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x16_fms_
		} else if (S >= 16 && _simd_s8x16_fms_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x8_fms_
		} else if (S >= 8 && _simd_s8x8_fms_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x4_fms_
		} else if (S >= 4 && _simd_s8x4_fms_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_s8x2_fms_
		} else if (S >= 2 && _simd_s8x2_fms_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ADD> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_add_
		} else if (S >= 64 && _simd_s8x64_add_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_add_
		} else if (S >= 32 && _simd_s8x32_add_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_add_
		} else if (S >= 16 && _simd_s8x16_add_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_add_
		} else if (S >= 8 && _simd_s8x8_add_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_add_
		} else if (S >= 4 && _simd_s8x4_add_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_add_
		} else if (S >= 2 && _simd_s8x2_add_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SUB> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sub_
		} else if (S >= 64 && _simd_s8x64_sub_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_sub_
		} else if (S >= 32 && _simd_s8x32_sub_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_sub_
		} else if (S >= 16 && _simd_s8x16_sub_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_sub_
		} else if (S >= 8 && _simd_s8x8_sub_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_sub_
		} else if (S >= 4 && _simd_s8x4_sub_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_sub_
		} else if (S >= 2 && _simd_s8x2_sub_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MUL> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_mul_
		} else if (S >= 64 && _simd_s8x64_mul_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_mul_
		} else if (S >= 32 && _simd_s8x32_mul_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_mul_
		} else if (S >= 16 && _simd_s8x16_mul_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_mul_
		} else if (S >= 8 && _simd_s8x8_mul_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_mul_
		} else if (S >= 4 && _simd_s8x4_mul_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_mul_
		} else if (S >= 2 && _simd_s8x2_mul_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_DIV> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_div_
		} else if (S >= 64 && _simd_s8x64_div_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_div_
		} else if (S >= 32 && _simd_s8x32_div_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_div_
		} else if (S >= 16 && _simd_s8x16_div_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_div_
		} else if (S >= 8 && _simd_s8x8_div_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_div_
		} else if (S >= 4 && _simd_s8x4_div_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_div_
		} else if (S >= 2 && _simd_s8x2_div_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_min_
		} else if (S >= 64 && _simd_s8x64_min_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_min_
		} else if (S >= 32 && _simd_s8x32_min_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_min_
		} else if (S >= 16 && _simd_s8x16_min_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_min_
		} else if (S >= 8 && _simd_s8x8_min_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_min_
		} else if (S >= 4 && _simd_s8x4_min_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_min_
		} else if (S >= 2 && _simd_s8x2_min_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MAX> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_max_
		} else if (S >= 64 && _simd_s8x64_max_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_max_
		} else if (S >= 32 && _simd_s8x32_max_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_max_
		} else if (S >= 16 && _simd_s8x16_max_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_max_
		} else if (S >= 8 && _simd_s8x8_max_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_max_
		} else if (S >= 4 && _simd_s8x4_max_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_max_
		} else if (S >= 2 && _simd_s8x2_max_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPEQ> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpeq_
		} else if (S >= 64 && _simd_s8x64_cmpeq_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmpeq_
		} else if (S >= 32 && _simd_s8x32_cmpeq_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmpeq_
		} else if (S >= 16 && _simd_s8x16_cmpeq_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmpeq_
		} else if (S >= 8 && _simd_s8x8_cmpeq_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmpeq_
		} else if (S >= 4 && _simd_s8x4_cmpeq_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmpeq_
		} else if (S >= 2 && _simd_s8x2_cmpeq_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPNE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpne_
		} else if (S >= 64 && _simd_s8x64_cmpne_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmpne_
		} else if (S >= 32 && _simd_s8x32_cmpne_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmpne_
		} else if (S >= 16 && _simd_s8x16_cmpne_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmpne_
		} else if (S >= 8 && _simd_s8x8_cmpne_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmpne_
		} else if (S >= 4 && _simd_s8x4_cmpne_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmpne_
		} else if (S >= 2 && _simd_s8x2_cmpne_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPLT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmplt_
		} else if (S >= 64 && _simd_s8x64_cmplt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmplt_
		} else if (S >= 32 && _simd_s8x32_cmplt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmplt_
		} else if (S >= 16 && _simd_s8x16_cmplt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmplt_
		} else if (S >= 8 && _simd_s8x8_cmplt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmplt_
		} else if (S >= 4 && _simd_s8x4_cmplt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmplt_
		} else if (S >= 2 && _simd_s8x2_cmplt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPGT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpgt_
		} else if (S >= 64 && _simd_s8x64_cmpgt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmpgt_
		} else if (S >= 32 && _simd_s8x32_cmpgt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmpgt_
		} else if (S >= 16 && _simd_s8x16_cmpgt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmpgt_
		} else if (S >= 8 && _simd_s8x8_cmpgt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmpgt_
		} else if (S >= 4 && _simd_s8x4_cmpgt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmpgt_
		} else if (S >= 2 && _simd_s8x2_cmpgt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPLE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmple_
		} else if (S >= 64 && _simd_s8x64_cmple_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmple_
		} else if (S >= 32 && _simd_s8x32_cmple_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmple_
		} else if (S >= 16 && _simd_s8x16_cmple_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmple_
		} else if (S >= 8 && _simd_s8x8_cmple_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmple_
		} else if (S >= 4 && _simd_s8x4_cmple_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmple_
		} else if (S >= 2 && _simd_s8x2_cmple_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPGE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpge_
		} else if (S >= 64 && _simd_s8x64_cmpge_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_cmpge_
		} else if (S >= 32 && _simd_s8x32_cmpge_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_cmpge_
		} else if (S >= 16 && _simd_s8x16_cmpge_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_cmpge_
		} else if (S >= 8 && _simd_s8x8_cmpge_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_cmpge_
		} else if (S >= 4 && _simd_s8x4_cmpge_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_cmpge_
		} else if (S >= 2 && _simd_s8x2_cmpge_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_AND> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_and_
		} else if (S >= 64 && _simd_s8x64_and_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_and_
		} else if (S >= 32 && _simd_s8x32_and_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_and_
		} else if (S >= 16 && _simd_s8x16_and_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_and_
		} else if (S >= 8 && _simd_s8x8_and_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_and_
		} else if (S >= 4 && _simd_s8x4_and_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_and_
		} else if (S >= 2 && _simd_s8x2_and_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_OR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_or_
		} else if (S >= 64 && _simd_s8x64_or_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_or_
		} else if (S >= 32 && _simd_s8x32_or_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_or_
		} else if (S >= 16 && _simd_s8x16_or_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_or_
		} else if (S >= 8 && _simd_s8x8_or_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_or_
		} else if (S >= 4 && _simd_s8x4_or_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_or_
		} else if (S >= 2 && _simd_s8x2_or_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_XOR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_xor_
		} else if (S >= 64 && _simd_s8x64_xor_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_xor_
		} else if (S >= 32 && _simd_s8x32_xor_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_xor_
		} else if (S >= 16 && _simd_s8x16_xor_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_xor_
		} else if (S >= 8 && _simd_s8x8_xor_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_xor_
		} else if (S >= 4 && _simd_s8x4_xor_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_xor_
		} else if (S >= 2 && _simd_s8x2_xor_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_lshift_
		} else if (S >= 64 && _simd_s8x64_lshift_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_lshift_
		} else if (S >= 32 && _simd_s8x32_lshift_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_lshift_
		} else if (S >= 16 && _simd_s8x16_lshift_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_lshift_
		} else if (S >= 8 && _simd_s8x8_lshift_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_lshift_
		} else if (S >= 4 && _simd_s8x4_lshift_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_lshift_
		} else if (S >= 2 && _simd_s8x2_lshift_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_RSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_rshift_
		} else if (S >= 64 && _simd_s8x64_rshift_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_rshift_
		} else if (S >= 32 && _simd_s8x32_rshift_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_rshift_
		} else if (S >= 16 && _simd_s8x16_rshift_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_rshift_
		} else if (S >= 8 && _simd_s8x8_rshift_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_rshift_
		} else if (S >= 4 && _simd_s8x4_rshift_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_rshift_
		} else if (S >= 2 && _simd_s8x2_rshift_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ATAN2> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_atan2_
		} else if (S >= 64 && _simd_s8x64_atan2_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x32_atan2_
		} else if (S >= 32 && _simd_s8x32_atan2_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x16_atan2_
		} else if (S >= 16 && _simd_s8x16_atan2_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x8_atan2_
		} else if (S >= 8 && _simd_s8x8_atan2_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x4_atan2_
		} else if (S >= 4 && _simd_s8x4_atan2_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_s8x2_atan2_
		} else if (S >= 2 && _simd_s8x2_atan2_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_REFLECT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_reflect_
		} else if (S >= 64 && _simd_s8x64_reflect_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_reflect_
		} else if (S >= 32 && _simd_s8x32_reflect_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_reflect_
		} else if (S >= 16 && _simd_s8x16_reflect_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_reflect_
		} else if (S >= 8 && _simd_s8x8_reflect_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_reflect_
		} else if (S >= 4 && _simd_s8x4_reflect_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_reflect_
		} else if (S >= 2 && _simd_s8x2_reflect_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_NOT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_not_
		} else if (S >= 64 && _simd_s8x64_not_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_not_
		} else if (S >= 32 && _simd_s8x32_not_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_not_
		} else if (S >= 16 && _simd_s8x16_not_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_not_
		} else if (S >= 8 && _simd_s8x8_not_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_not_
		} else if (S >= 4 && _simd_s8x4_not_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_not_
		} else if (S >= 2 && _simd_s8x2_not_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ABS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_abs_
		} else if (S >= 64 && _simd_s8x64_abs_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_abs_
		} else if (S >= 32 && _simd_s8x32_abs_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_abs_
		} else if (S >= 16 && _simd_s8x16_abs_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_abs_
		} else if (S >= 8 && _simd_s8x8_abs_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_abs_
		} else if (S >= 4 && _simd_s8x4_abs_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_abs_
		} else if (S >= 2 && _simd_s8x2_abs_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_EXP> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_exp_
		} else if (S >= 64 && _simd_s8x64_exp_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_exp_
		} else if (S >= 32 && _simd_s8x32_exp_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_exp_
		} else if (S >= 16 && _simd_s8x16_exp_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_exp_
		} else if (S >= 8 && _simd_s8x8_exp_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_exp_
		} else if (S >= 4 && _simd_s8x4_exp_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_exp_
		} else if (S >= 2 && _simd_s8x2_exp_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log_
		} else if (S >= 64 && _simd_s8x64_log_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_log_
		} else if (S >= 32 && _simd_s8x32_log_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_log_
		} else if (S >= 16 && _simd_s8x16_log_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_log_
		} else if (S >= 8 && _simd_s8x8_log_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_log_
		} else if (S >= 4 && _simd_s8x4_log_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_log_
		} else if (S >= 2 && _simd_s8x2_log_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG2> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log2_
		} else if (S >= 64 && _simd_s8x64_log2_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_log2_
		} else if (S >= 32 && _simd_s8x32_log2_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_log2_
		} else if (S >= 16 && _simd_s8x16_log2_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_log2_
		} else if (S >= 8 && _simd_s8x8_log2_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_log2_
		} else if (S >= 4 && _simd_s8x4_log2_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_log2_
		} else if (S >= 2 && _simd_s8x2_log2_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG10> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log10_
		} else if (S >= 64 && _simd_s8x64_log10_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_log10_
		} else if (S >= 32 && _simd_s8x32_log10_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_log10_
		} else if (S >= 16 && _simd_s8x16_log10_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_log10_
		} else if (S >= 8 && _simd_s8x8_log10_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_log10_
		} else if (S >= 4 && _simd_s8x4_log10_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_log10_
		} else if (S >= 2 && _simd_s8x2_log10_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CEIL> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_ceil_
		} else if (S >= 64 && _simd_s8x64_ceil_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_ceil_
		} else if (S >= 32 && _simd_s8x32_ceil_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_ceil_
		} else if (S >= 16 && _simd_s8x16_ceil_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_ceil_
		} else if (S >= 8 && _simd_s8x8_ceil_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_ceil_
		} else if (S >= 4 && _simd_s8x4_ceil_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_ceil_
		} else if (S >= 2 && _simd_s8x2_ceil_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FLOOR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_floor_
		} else if (S >= 64 && _simd_s8x64_floor_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_floor_
		} else if (S >= 32 && _simd_s8x32_floor_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_floor_
		} else if (S >= 16 && _simd_s8x16_floor_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_floor_
		} else if (S >= 8 && _simd_s8x8_floor_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_floor_
		} else if (S >= 4 && _simd_s8x4_floor_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_floor_
		} else if (S >= 2 && _simd_s8x2_floor_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ROUND> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_round_
		} else if (S >= 64 && _simd_s8x64_round_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_round_
		} else if (S >= 32 && _simd_s8x32_round_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_round_
		} else if (S >= 16 && _simd_s8x16_round_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_round_
		} else if (S >= 8 && _simd_s8x8_round_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_round_
		} else if (S >= 4 && _simd_s8x4_round_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_round_
		} else if (S >= 2 && _simd_s8x2_round_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sin_
		} else if (S >= 64 && _simd_s8x64_sin_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_sin_
		} else if (S >= 32 && _simd_s8x32_sin_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_sin_
		} else if (S >= 16 && _simd_s8x16_sin_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_sin_
		} else if (S >= 8 && _simd_s8x8_sin_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_sin_
		} else if (S >= 4 && _simd_s8x4_sin_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_sin_
		} else if (S >= 2 && _simd_s8x2_sin_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_COS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cos_
		} else if (S >= 64 && _simd_s8x64_cos_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_cos_
		} else if (S >= 32 && _simd_s8x32_cos_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_cos_
		} else if (S >= 16 && _simd_s8x16_cos_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_cos_
		} else if (S >= 8 && _simd_s8x8_cos_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_cos_
		} else if (S >= 4 && _simd_s8x4_cos_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_cos_
		} else if (S >= 2 && _simd_s8x2_cos_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_TAN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_tan_
		} else if (S >= 64 && _simd_s8x64_tan_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_tan_
		} else if (S >= 32 && _simd_s8x32_tan_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_tan_
		} else if (S >= 16 && _simd_s8x16_tan_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_tan_
		} else if (S >= 8 && _simd_s8x8_tan_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_tan_
		} else if (S >= 4 && _simd_s8x4_tan_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_tan_
		} else if (S >= 2 && _simd_s8x2_tan_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ASIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_asin_
		} else if (S >= 64 && _simd_s8x64_asin_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_asin_
		} else if (S >= 32 && _simd_s8x32_asin_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_asin_
		} else if (S >= 16 && _simd_s8x16_asin_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_asin_
		} else if (S >= 8 && _simd_s8x8_asin_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_asin_
		} else if (S >= 4 && _simd_s8x4_asin_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_asin_
		} else if (S >= 2 && _simd_s8x2_asin_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ACOS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_acos_
		} else if (S >= 64 && _simd_s8x64_acos_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_acos_
		} else if (S >= 32 && _simd_s8x32_acos_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_acos_
		} else if (S >= 16 && _simd_s8x16_acos_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_acos_
		} else if (S >= 8 && _simd_s8x8_acos_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_acos_
		} else if (S >= 4 && _simd_s8x4_acos_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_acos_
		} else if (S >= 2 && _simd_s8x2_acos_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ATAN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_atan_
		} else if (S >= 64 && _simd_s8x64_atan_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_atan_
		} else if (S >= 32 && _simd_s8x32_atan_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_atan_
		} else if (S >= 16 && _simd_s8x16_atan_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_atan_
		} else if (S >= 8 && _simd_s8x8_atan_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_atan_
		} else if (S >= 4 && _simd_s8x4_atan_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_atan_
		} else if (S >= 2 && _simd_s8x2_atan_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SINH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sinh_
		} else if (S >= 64 && _simd_s8x64_sinh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_sinh_
		} else if (S >= 32 && _simd_s8x32_sinh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_sinh_
		} else if (S >= 16 && _simd_s8x16_sinh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_sinh_
		} else if (S >= 8 && _simd_s8x8_sinh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_sinh_
		} else if (S >= 4 && _simd_s8x4_sinh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_sinh_
		} else if (S >= 2 && _simd_s8x2_sinh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_COSH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cosh_
		} else if (S >= 64 && _simd_s8x64_cosh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_cosh_
		} else if (S >= 32 && _simd_s8x32_cosh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_cosh_
		} else if (S >= 16 && _simd_s8x16_cosh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_cosh_
		} else if (S >= 8 && _simd_s8x8_cosh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_cosh_
		} else if (S >= 4 && _simd_s8x4_cosh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_cosh_
		} else if (S >= 2 && _simd_s8x2_cosh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_TANH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_tanh_
		} else if (S >= 64 && _simd_s8x64_tanh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_tanh_
		} else if (S >= 32 && _simd_s8x32_tanh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_tanh_
		} else if (S >= 16 && _simd_s8x16_tanh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_tanh_
		} else if (S >= 8 && _simd_s8x8_tanh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_tanh_
		} else if (S >= 4 && _simd_s8x4_tanh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_tanh_
		} else if (S >= 2 && _simd_s8x2_tanh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SQRT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sqrt_
		} else if (S >= 64 && _simd_s8x64_sqrt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_sqrt_
		} else if (S >= 32 && _simd_s8x32_sqrt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_sqrt_
		} else if (S >= 16 && _simd_s8x16_sqrt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_sqrt_
		} else if (S >= 8 && _simd_s8x8_sqrt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_sqrt_
		} else if (S >= 4 && _simd_s8x4_sqrt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_sqrt_
		} else if (S >= 2 && _simd_s8x2_sqrt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CBRT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cbrt_
		} else if (S >= 64 && _simd_s8x64_cbrt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x32_cbrt_
		} else if (S >= 32 && _simd_s8x32_cbrt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x16_cbrt_
		} else if (S >= 16 && _simd_s8x16_cbrt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x8_cbrt_
		} else if (S >= 8 && _simd_s8x8_cbrt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x4_cbrt_
		} else if (S >= 4 && _simd_s8x4_cbrt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_s8x2_cbrt_
		} else if (S >= 2 && _simd_s8x2_cbrt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_s8x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cbrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FMA> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fma_
		} else if (S >= 64 && _simd_u8x64_fma_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x32_fma_
		} else if (S >= 32 && _simd_u8x32_fma_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x16_fma_
		} else if (S >= 16 && _simd_u8x16_fma_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x8_fma_
		} else if (S >= 8 && _simd_u8x8_fma_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x4_fma_
		} else if (S >= 4 && _simd_u8x4_fma_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x2_fma_
		} else if (S >= 2 && _simd_u8x2_fma_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_fma_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FMS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fms_
		} else if (S >= 64 && _simd_u8x64_fms_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x32_fms_
		} else if (S >= 32 && _simd_u8x32_fms_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x16_fms_
		} else if (S >= 16 && _simd_u8x16_fms_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x8_fms_
		} else if (S >= 8 && _simd_u8x8_fms_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x4_fms_
		} else if (S >= 4 && _simd_u8x4_fms_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
#ifdef _simd_u8x2_fms_
		} else if (S >= 2 && _simd_u8x2_fms_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			const simd_t* const z_ptr = reinterpret_cast<const simd_t*>(z);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_fms_(x_ptr[i],y_ptr[i],z_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x + offset, y + offset, z + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ADD> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_add_
		} else if (S >= 64 && _simd_u8x64_add_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_add_
		} else if (S >= 32 && _simd_u8x32_add_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_add_
		} else if (S >= 16 && _simd_u8x16_add_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_add_
		} else if (S >= 8 && _simd_u8x8_add_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_add_
		} else if (S >= 4 && _simd_u8x4_add_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_add_
		} else if (S >= 2 && _simd_u8x2_add_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_add_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_add_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SUB> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sub_
		} else if (S >= 64 && _simd_u8x64_sub_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_sub_
		} else if (S >= 32 && _simd_u8x32_sub_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_sub_
		} else if (S >= 16 && _simd_u8x16_sub_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_sub_
		} else if (S >= 8 && _simd_u8x8_sub_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_sub_
		} else if (S >= 4 && _simd_u8x4_sub_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_sub_
		} else if (S >= 2 && _simd_u8x2_sub_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_sub_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sub_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MUL> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_mul_
		} else if (S >= 64 && _simd_u8x64_mul_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_mul_
		} else if (S >= 32 && _simd_u8x32_mul_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_mul_
		} else if (S >= 16 && _simd_u8x16_mul_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_mul_
		} else if (S >= 8 && _simd_u8x8_mul_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_mul_
		} else if (S >= 4 && _simd_u8x4_mul_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_mul_
		} else if (S >= 2 && _simd_u8x2_mul_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_mul_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_mul_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_DIV> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_div_
		} else if (S >= 64 && _simd_u8x64_div_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_div_
		} else if (S >= 32 && _simd_u8x32_div_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_div_
		} else if (S >= 16 && _simd_u8x16_div_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_div_
		} else if (S >= 8 && _simd_u8x8_div_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_div_
		} else if (S >= 4 && _simd_u8x4_div_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_div_
		} else if (S >= 2 && _simd_u8x2_div_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_div_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_div_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_min_
		} else if (S >= 64 && _simd_u8x64_min_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_min_
		} else if (S >= 32 && _simd_u8x32_min_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_min_
		} else if (S >= 16 && _simd_u8x16_min_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_min_
		} else if (S >= 8 && _simd_u8x8_min_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_min_
		} else if (S >= 4 && _simd_u8x4_min_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_min_
		} else if (S >= 2 && _simd_u8x2_min_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_min_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_min_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MAX> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_max_
		} else if (S >= 64 && _simd_u8x64_max_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_max_
		} else if (S >= 32 && _simd_u8x32_max_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_max_
		} else if (S >= 16 && _simd_u8x16_max_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_max_
		} else if (S >= 8 && _simd_u8x8_max_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_max_
		} else if (S >= 4 && _simd_u8x4_max_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_max_
		} else if (S >= 2 && _simd_u8x2_max_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_max_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_max_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPEQ> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpeq_
		} else if (S >= 64 && _simd_u8x64_cmpeq_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmpeq_
		} else if (S >= 32 && _simd_u8x32_cmpeq_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmpeq_
		} else if (S >= 16 && _simd_u8x16_cmpeq_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmpeq_
		} else if (S >= 8 && _simd_u8x8_cmpeq_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmpeq_
		} else if (S >= 4 && _simd_u8x4_cmpeq_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmpeq_
		} else if (S >= 2 && _simd_u8x2_cmpeq_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmpeq_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpeq_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPNE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpne_
		} else if (S >= 64 && _simd_u8x64_cmpne_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmpne_
		} else if (S >= 32 && _simd_u8x32_cmpne_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmpne_
		} else if (S >= 16 && _simd_u8x16_cmpne_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmpne_
		} else if (S >= 8 && _simd_u8x8_cmpne_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmpne_
		} else if (S >= 4 && _simd_u8x4_cmpne_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmpne_
		} else if (S >= 2 && _simd_u8x2_cmpne_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmpne_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpne_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPLT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmplt_
		} else if (S >= 64 && _simd_u8x64_cmplt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmplt_
		} else if (S >= 32 && _simd_u8x32_cmplt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmplt_
		} else if (S >= 16 && _simd_u8x16_cmplt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmplt_
		} else if (S >= 8 && _simd_u8x8_cmplt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmplt_
		} else if (S >= 4 && _simd_u8x4_cmplt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmplt_
		} else if (S >= 2 && _simd_u8x2_cmplt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmplt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmplt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPGT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpgt_
		} else if (S >= 64 && _simd_u8x64_cmpgt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmpgt_
		} else if (S >= 32 && _simd_u8x32_cmpgt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmpgt_
		} else if (S >= 16 && _simd_u8x16_cmpgt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmpgt_
		} else if (S >= 8 && _simd_u8x8_cmpgt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmpgt_
		} else if (S >= 4 && _simd_u8x4_cmpgt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmpgt_
		} else if (S >= 2 && _simd_u8x2_cmpgt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmpgt_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpgt_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPLE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmple_
		} else if (S >= 64 && _simd_u8x64_cmple_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmple_
		} else if (S >= 32 && _simd_u8x32_cmple_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmple_
		} else if (S >= 16 && _simd_u8x16_cmple_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmple_
		} else if (S >= 8 && _simd_u8x8_cmple_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmple_
		} else if (S >= 4 && _simd_u8x4_cmple_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmple_
		} else if (S >= 2 && _simd_u8x2_cmple_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmple_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmple_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPGE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpge_
		} else if (S >= 64 && _simd_u8x64_cmpge_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_cmpge_
		} else if (S >= 32 && _simd_u8x32_cmpge_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_cmpge_
		} else if (S >= 16 && _simd_u8x16_cmpge_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_cmpge_
		} else if (S >= 8 && _simd_u8x8_cmpge_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_cmpge_
		} else if (S >= 4 && _simd_u8x4_cmpge_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_cmpge_
		} else if (S >= 2 && _simd_u8x2_cmpge_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cmpge_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpge_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_AND> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_and_
		} else if (S >= 64 && _simd_u8x64_and_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_and_
		} else if (S >= 32 && _simd_u8x32_and_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_and_
		} else if (S >= 16 && _simd_u8x16_and_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_and_
		} else if (S >= 8 && _simd_u8x8_and_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_and_
		} else if (S >= 4 && _simd_u8x4_and_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_and_
		} else if (S >= 2 && _simd_u8x2_and_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_and_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_and_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_OR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_or_
		} else if (S >= 64 && _simd_u8x64_or_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_or_
		} else if (S >= 32 && _simd_u8x32_or_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_or_
		} else if (S >= 16 && _simd_u8x16_or_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_or_
		} else if (S >= 8 && _simd_u8x8_or_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_or_
		} else if (S >= 4 && _simd_u8x4_or_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_or_
		} else if (S >= 2 && _simd_u8x2_or_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_or_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_or_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_XOR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_xor_
		} else if (S >= 64 && _simd_u8x64_xor_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_xor_
		} else if (S >= 32 && _simd_u8x32_xor_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_xor_
		} else if (S >= 16 && _simd_u8x16_xor_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_xor_
		} else if (S >= 8 && _simd_u8x8_xor_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_xor_
		} else if (S >= 4 && _simd_u8x4_xor_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_xor_
		} else if (S >= 2 && _simd_u8x2_xor_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_xor_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_xor_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_lshift_
		} else if (S >= 64 && _simd_u8x64_lshift_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_lshift_
		} else if (S >= 32 && _simd_u8x32_lshift_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_lshift_
		} else if (S >= 16 && _simd_u8x16_lshift_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_lshift_
		} else if (S >= 8 && _simd_u8x8_lshift_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_lshift_
		} else if (S >= 4 && _simd_u8x4_lshift_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_lshift_
		} else if (S >= 2 && _simd_u8x2_lshift_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_lshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_lshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_RSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_rshift_
		} else if (S >= 64 && _simd_u8x64_rshift_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_rshift_
		} else if (S >= 32 && _simd_u8x32_rshift_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_rshift_
		} else if (S >= 16 && _simd_u8x16_rshift_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_rshift_
		} else if (S >= 8 && _simd_u8x8_rshift_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_rshift_
		} else if (S >= 4 && _simd_u8x4_rshift_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_rshift_
		} else if (S >= 2 && _simd_u8x2_rshift_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_rshift_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_rshift_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ATAN2> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_atan2_
		} else if (S >= 64 && _simd_u8x64_atan2_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x32_atan2_
		} else if (S >= 32 && _simd_u8x32_atan2_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x16_atan2_
		} else if (S >= 16 && _simd_u8x16_atan2_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x8_atan2_
		} else if (S >= 8 && _simd_u8x8_atan2_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x4_atan2_
		} else if (S >= 4 && _simd_u8x4_atan2_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
#ifdef _simd_u8x2_atan2_
		} else if (S >= 2 && _simd_u8x2_atan2_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			const simd_t* const y_ptr = reinterpret_cast<const simd_t*>(y);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_atan2_(x_ptr[i],y_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x + offset, y + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_atan2_safe(x[i],y[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_REFLECT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_reflect_
		} else if (S >= 64 && _simd_u8x64_reflect_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_reflect_
		} else if (S >= 32 && _simd_u8x32_reflect_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_reflect_
		} else if (S >= 16 && _simd_u8x16_reflect_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_reflect_
		} else if (S >= 8 && _simd_u8x8_reflect_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_reflect_
		} else if (S >= 4 && _simd_u8x4_reflect_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_reflect_
		} else if (S >= 2 && _simd_u8x2_reflect_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_reflect_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_REFLECT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_reflect_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_NOT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_not_
		} else if (S >= 64 && _simd_u8x64_not_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_not_
		} else if (S >= 32 && _simd_u8x32_not_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_not_
		} else if (S >= 16 && _simd_u8x16_not_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_not_
		} else if (S >= 8 && _simd_u8x8_not_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_not_
		} else if (S >= 4 && _simd_u8x4_not_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_not_
		} else if (S >= 2 && _simd_u8x2_not_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_not_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_not_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ABS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_abs_
		} else if (S >= 64 && _simd_u8x64_abs_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_abs_
		} else if (S >= 32 && _simd_u8x32_abs_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_abs_
		} else if (S >= 16 && _simd_u8x16_abs_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_abs_
		} else if (S >= 8 && _simd_u8x8_abs_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_abs_
		} else if (S >= 4 && _simd_u8x4_abs_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_abs_
		} else if (S >= 2 && _simd_u8x2_abs_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_abs_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_abs_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_EXP> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_exp_
		} else if (S >= 64 && _simd_u8x64_exp_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_exp_
		} else if (S >= 32 && _simd_u8x32_exp_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_exp_
		} else if (S >= 16 && _simd_u8x16_exp_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_exp_
		} else if (S >= 8 && _simd_u8x8_exp_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_exp_
		} else if (S >= 4 && _simd_u8x4_exp_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_exp_
		} else if (S >= 2 && _simd_u8x2_exp_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_exp_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_exp_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log_
		} else if (S >= 64 && _simd_u8x64_log_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_log_
		} else if (S >= 32 && _simd_u8x32_log_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_log_
		} else if (S >= 16 && _simd_u8x16_log_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_log_
		} else if (S >= 8 && _simd_u8x8_log_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_log_
		} else if (S >= 4 && _simd_u8x4_log_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_log_
		} else if (S >= 2 && _simd_u8x2_log_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_log_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG2> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log2_
		} else if (S >= 64 && _simd_u8x64_log2_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_log2_
		} else if (S >= 32 && _simd_u8x32_log2_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_log2_
		} else if (S >= 16 && _simd_u8x16_log2_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_log2_
		} else if (S >= 8 && _simd_u8x8_log2_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_log2_
		} else if (S >= 4 && _simd_u8x4_log2_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_log2_
		} else if (S >= 2 && _simd_u8x2_log2_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_log2_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log2_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG10> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log10_
		} else if (S >= 64 && _simd_u8x64_log10_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_log10_
		} else if (S >= 32 && _simd_u8x32_log10_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_log10_
		} else if (S >= 16 && _simd_u8x16_log10_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_log10_
		} else if (S >= 8 && _simd_u8x8_log10_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_log10_
		} else if (S >= 4 && _simd_u8x4_log10_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_log10_
		} else if (S >= 2 && _simd_u8x2_log10_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_log10_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log10_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CEIL> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_ceil_
		} else if (S >= 64 && _simd_u8x64_ceil_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_ceil_
		} else if (S >= 32 && _simd_u8x32_ceil_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_ceil_
		} else if (S >= 16 && _simd_u8x16_ceil_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_ceil_
		} else if (S >= 8 && _simd_u8x8_ceil_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_ceil_
		} else if (S >= 4 && _simd_u8x4_ceil_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_ceil_
		} else if (S >= 2 && _simd_u8x2_ceil_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_ceil_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_ceil_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FLOOR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_floor_
		} else if (S >= 64 && _simd_u8x64_floor_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_floor_
		} else if (S >= 32 && _simd_u8x32_floor_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_floor_
		} else if (S >= 16 && _simd_u8x16_floor_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_floor_
		} else if (S >= 8 && _simd_u8x8_floor_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_floor_
		} else if (S >= 4 && _simd_u8x4_floor_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_floor_
		} else if (S >= 2 && _simd_u8x2_floor_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_floor_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_floor_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ROUND> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_round_
		} else if (S >= 64 && _simd_u8x64_round_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_round_
		} else if (S >= 32 && _simd_u8x32_round_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_round_
		} else if (S >= 16 && _simd_u8x16_round_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_round_
		} else if (S >= 8 && _simd_u8x8_round_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_round_
		} else if (S >= 4 && _simd_u8x4_round_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_round_
		} else if (S >= 2 && _simd_u8x2_round_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_round_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_round_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sin_
		} else if (S >= 64 && _simd_u8x64_sin_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_sin_
		} else if (S >= 32 && _simd_u8x32_sin_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_sin_
		} else if (S >= 16 && _simd_u8x16_sin_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_sin_
		} else if (S >= 8 && _simd_u8x8_sin_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_sin_
		} else if (S >= 4 && _simd_u8x4_sin_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_sin_
		} else if (S >= 2 && _simd_u8x2_sin_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_sin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_COS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cos_
		} else if (S >= 64 && _simd_u8x64_cos_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_cos_
		} else if (S >= 32 && _simd_u8x32_cos_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_cos_
		} else if (S >= 16 && _simd_u8x16_cos_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_cos_
		} else if (S >= 8 && _simd_u8x8_cos_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_cos_
		} else if (S >= 4 && _simd_u8x4_cos_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_cos_
		} else if (S >= 2 && _simd_u8x2_cos_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_TAN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_tan_
		} else if (S >= 64 && _simd_u8x64_tan_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_tan_
		} else if (S >= 32 && _simd_u8x32_tan_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_tan_
		} else if (S >= 16 && _simd_u8x16_tan_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_tan_
		} else if (S >= 8 && _simd_u8x8_tan_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_tan_
		} else if (S >= 4 && _simd_u8x4_tan_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_tan_
		} else if (S >= 2 && _simd_u8x2_tan_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_tan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_tan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ASIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_asin_
		} else if (S >= 64 && _simd_u8x64_asin_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_asin_
		} else if (S >= 32 && _simd_u8x32_asin_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_asin_
		} else if (S >= 16 && _simd_u8x16_asin_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_asin_
		} else if (S >= 8 && _simd_u8x8_asin_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_asin_
		} else if (S >= 4 && _simd_u8x4_asin_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_asin_
		} else if (S >= 2 && _simd_u8x2_asin_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_asin_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_asin_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ACOS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_acos_
		} else if (S >= 64 && _simd_u8x64_acos_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_acos_
		} else if (S >= 32 && _simd_u8x32_acos_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_acos_
		} else if (S >= 16 && _simd_u8x16_acos_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_acos_
		} else if (S >= 8 && _simd_u8x8_acos_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_acos_
		} else if (S >= 4 && _simd_u8x4_acos_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_acos_
		} else if (S >= 2 && _simd_u8x2_acos_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_acos_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_acos_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ATAN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_atan_
		} else if (S >= 64 && _simd_u8x64_atan_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_atan_
		} else if (S >= 32 && _simd_u8x32_atan_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_atan_
		} else if (S >= 16 && _simd_u8x16_atan_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_atan_
		} else if (S >= 8 && _simd_u8x8_atan_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_atan_
		} else if (S >= 4 && _simd_u8x4_atan_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_atan_
		} else if (S >= 2 && _simd_u8x2_atan_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_atan_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_atan_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SINH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sinh_
		} else if (S >= 64 && _simd_u8x64_sinh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_sinh_
		} else if (S >= 32 && _simd_u8x32_sinh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_sinh_
		} else if (S >= 16 && _simd_u8x16_sinh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_sinh_
		} else if (S >= 8 && _simd_u8x8_sinh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_sinh_
		} else if (S >= 4 && _simd_u8x4_sinh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_sinh_
		} else if (S >= 2 && _simd_u8x2_sinh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_sinh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sinh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_COSH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cosh_
		} else if (S >= 64 && _simd_u8x64_cosh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_cosh_
		} else if (S >= 32 && _simd_u8x32_cosh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_cosh_
		} else if (S >= 16 && _simd_u8x16_cosh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_cosh_
		} else if (S >= 8 && _simd_u8x8_cosh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_cosh_
		} else if (S >= 4 && _simd_u8x4_cosh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_cosh_
		} else if (S >= 2 && _simd_u8x2_cosh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cosh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cosh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_TANH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_tanh_
		} else if (S >= 64 && _simd_u8x64_tanh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_tanh_
		} else if (S >= 32 && _simd_u8x32_tanh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_tanh_
		} else if (S >= 16 && _simd_u8x16_tanh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_tanh_
		} else if (S >= 8 && _simd_u8x8_tanh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_tanh_
		} else if (S >= 4 && _simd_u8x4_tanh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_tanh_
		} else if (S >= 2 && _simd_u8x2_tanh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_tanh_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_tanh_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SQRT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sqrt_
		} else if (S >= 64 && _simd_u8x64_sqrt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_sqrt_
		} else if (S >= 32 && _simd_u8x32_sqrt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_sqrt_
		} else if (S >= 16 && _simd_u8x16_sqrt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_sqrt_
		} else if (S >= 8 && _simd_u8x8_sqrt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_sqrt_
		} else if (S >= 4 && _simd_u8x4_sqrt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_sqrt_
		} else if (S >= 2 && _simd_u8x2_sqrt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_sqrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sqrt_safe(x[i]);
		}
	}
};
template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CBRT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cbrt_
		} else if (S >= 64 && _simd_u8x64_cbrt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64, offset = loop * 64 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x64_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x32_cbrt_
		} else if (S >= 32 && _simd_u8x32_cbrt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32, offset = loop * 32 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x32_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x16_cbrt_
		} else if (S >= 16 && _simd_u8x16_cbrt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16, offset = loop * 16 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x16_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x8_cbrt_
		} else if (S >= 8 && _simd_u8x8_cbrt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8, offset = loop * 8 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x8_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x4_cbrt_
		} else if (S >= 4 && _simd_u8x4_cbrt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4, offset = loop * 4 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x4_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
#ifdef _simd_u8x2_cbrt_
		} else if (S >= 2 && _simd_u8x2_cbrt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2, offset = loop * 2 };
			const simd_t* const x_ptr = reinterpret_cast<const simd_t*>(x);
			simd_t* const o_ptr = reinterpret_cast<simd_t*>(o);
			for (size_t i = 0; i < loop; ++i) {
				o_ptr[i] = _simd_u8x2_cbrt_(x_ptr[i]);
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x + offset, o + offset);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cbrt_safe(x[i]);
		}
	}
};
