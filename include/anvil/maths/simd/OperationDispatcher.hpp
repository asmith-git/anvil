//Copyright 2017 Adam G. Smith
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http ://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S,OP_SUM> {
	typedef _simd_f64x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_add_
		} else if (S >= 64 && _simd_f64x64_add_enable()) {
			typedef _simd_f64x64 simd_t;
			simd_t tmp = _simd_f64x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x64_add_(tmp, _simd_f64x64_load_(o)); 
				o += 64;
			}
			return _simd_f64x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f64x32_add_
		} else if (S >= 32 && _simd_f64x32_add_enable()) {
			typedef _simd_f64x32 simd_t;
			simd_t tmp = _simd_f64x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x32_add_(tmp, _simd_f64x32_load_(o)); 
				o += 32;
			}
			return _simd_f64x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f64x16_add_
		} else if (S >= 16 && _simd_f64x16_add_enable()) {
			typedef _simd_f64x16 simd_t;
			simd_t tmp = _simd_f64x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x16_add_(tmp, _simd_f64x16_load_(o)); 
				o += 16;
			}
			return _simd_f64x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f64x8_add_
		} else if (S >= 8 && _simd_f64x8_add_enable()) {
			typedef _simd_f64x8 simd_t;
			simd_t tmp = _simd_f64x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x8_add_(tmp, _simd_f64x8_load_(o)); 
				o += 8;
			}
			return _simd_f64x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f64x4_add_
		} else if (S >= 4 && _simd_f64x4_add_enable()) {
			typedef _simd_f64x4 simd_t;
			simd_t tmp = _simd_f64x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x4_add_(tmp, _simd_f64x4_load_(o)); 
				o += 4;
			}
			return _simd_f64x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f64x2_add_
		} else if (S >= 2 && _simd_f64x2_add_enable()) {
			typedef _simd_f64x2 simd_t;
			simd_t tmp = _simd_f64x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f64x2_add_(tmp, _simd_f64x2_load_(o)); 
				o += 2;
			}
			return _simd_f64x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1,OP_SUM> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0,OP_SUM> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FILL0> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fill_zero_
		} else if (S >= 64 && _simd_f64x64_fill_zero_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f64x32_fill_zero_
		} else if (S >= 32 && _simd_f64x32_fill_zero_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f64x16_fill_zero_
		} else if (S >= 16 && _simd_f64x16_fill_zero_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f64x8_fill_zero_
		} else if (S >= 8 && _simd_f64x8_fill_zero_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f64x4_fill_zero_
		} else if (S >= 4 && _simd_f64x4_fill_zero_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f64x2_fill_zero_
		} else if (S >= 2 && _simd_f64x2_fill_zero_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FILLU> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FILLS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fill_scalar_
		} else if (S >= 64 && _simd_f64x64_fill_scalar_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f64x32_fill_scalar_
		} else if (S >= 32 && _simd_f64x32_fill_scalar_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f64x16_fill_scalar_
		} else if (S >= 16 && _simd_f64x16_fill_scalar_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f64x8_fill_scalar_
		} else if (S >= 8 && _simd_f64x8_fill_scalar_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f64x4_fill_scalar_
		} else if (S >= 4 && _simd_f64x4_fill_scalar_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f64x2_fill_scalar_
		} else if (S >= 2 && _simd_f64x2_fill_scalar_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FMA> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fma_
		} else if (S >= 64 && _simd_f64x64_fma_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_fma_(_simd_f64x64_load_(x),_simd_f64x64_load_(y),_simd_f64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x32_fma_
		} else if (S >= 32 && _simd_f64x32_fma_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_fma_(_simd_f64x32_load_(x),_simd_f64x32_load_(y),_simd_f64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x16_fma_
		} else if (S >= 16 && _simd_f64x16_fma_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_fma_(_simd_f64x16_load_(x),_simd_f64x16_load_(y),_simd_f64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x8_fma_
		} else if (S >= 8 && _simd_f64x8_fma_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_fma_(_simd_f64x8_load_(x),_simd_f64x8_load_(y),_simd_f64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x4_fma_
		} else if (S >= 4 && _simd_f64x4_fma_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_fma_(_simd_f64x4_load_(x),_simd_f64x4_load_(y),_simd_f64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x2_fma_
		} else if (S >= 2 && _simd_f64x2_fma_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_fma_(_simd_f64x2_load_(x),_simd_f64x2_load_(y),_simd_f64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_FMA> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_f64x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_FMA> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FMS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_fms_
		} else if (S >= 64 && _simd_f64x64_fms_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_fms_(_simd_f64x64_load_(x),_simd_f64x64_load_(y),_simd_f64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x32_fms_
		} else if (S >= 32 && _simd_f64x32_fms_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_fms_(_simd_f64x32_load_(x),_simd_f64x32_load_(y),_simd_f64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x16_fms_
		} else if (S >= 16 && _simd_f64x16_fms_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_fms_(_simd_f64x16_load_(x),_simd_f64x16_load_(y),_simd_f64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x8_fms_
		} else if (S >= 8 && _simd_f64x8_fms_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_fms_(_simd_f64x8_load_(x),_simd_f64x8_load_(y),_simd_f64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x4_fms_
		} else if (S >= 4 && _simd_f64x4_fms_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_fms_(_simd_f64x4_load_(x),_simd_f64x4_load_(y),_simd_f64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f64x2_fms_
		} else if (S >= 2 && _simd_f64x2_fms_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_fms_(_simd_f64x2_load_(x),_simd_f64x2_load_(y),_simd_f64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_FMS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_f64x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_FMS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ADD> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_add_
		} else if (S >= 64 && _simd_f64x64_add_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_add_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_add_
		} else if (S >= 32 && _simd_f64x32_add_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_add_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_add_
		} else if (S >= 16 && _simd_f64x16_add_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_add_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_add_
		} else if (S >= 8 && _simd_f64x8_add_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_add_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_add_
		} else if (S >= 4 && _simd_f64x4_add_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_add_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_add_
		} else if (S >= 2 && _simd_f64x2_add_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_add_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ADD> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ADD> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SUB> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sub_
		} else if (S >= 64 && _simd_f64x64_sub_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_sub_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_sub_
		} else if (S >= 32 && _simd_f64x32_sub_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_sub_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_sub_
		} else if (S >= 16 && _simd_f64x16_sub_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_sub_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_sub_
		} else if (S >= 8 && _simd_f64x8_sub_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_sub_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_sub_
		} else if (S >= 4 && _simd_f64x4_sub_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_sub_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_sub_
		} else if (S >= 2 && _simd_f64x2_sub_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_sub_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_SUB> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_SUB> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MUL> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_mul_
		} else if (S >= 64 && _simd_f64x64_mul_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_mul_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_mul_
		} else if (S >= 32 && _simd_f64x32_mul_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_mul_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_mul_
		} else if (S >= 16 && _simd_f64x16_mul_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_mul_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_mul_
		} else if (S >= 8 && _simd_f64x8_mul_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_mul_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_mul_
		} else if (S >= 4 && _simd_f64x4_mul_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_mul_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_mul_
		} else if (S >= 2 && _simd_f64x2_mul_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_mul_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_MUL> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_MUL> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_DIV> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_div_
		} else if (S >= 64 && _simd_f64x64_div_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_div_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_div_
		} else if (S >= 32 && _simd_f64x32_div_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_div_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_div_
		} else if (S >= 16 && _simd_f64x16_div_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_div_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_div_
		} else if (S >= 8 && _simd_f64x8_div_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_div_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_div_
		} else if (S >= 4 && _simd_f64x4_div_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_div_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_div_
		} else if (S >= 2 && _simd_f64x2_div_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_div_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_DIV> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_DIV> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_min_
		} else if (S >= 64 && _simd_f64x64_min_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_min_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_min_
		} else if (S >= 32 && _simd_f64x32_min_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_min_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_min_
		} else if (S >= 16 && _simd_f64x16_min_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_min_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_min_
		} else if (S >= 8 && _simd_f64x8_min_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_min_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_min_
		} else if (S >= 4 && _simd_f64x4_min_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_min_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_min_
		} else if (S >= 2 && _simd_f64x2_min_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_min_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_MIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_MIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_MAX> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_max_
		} else if (S >= 64 && _simd_f64x64_max_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_max_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_max_
		} else if (S >= 32 && _simd_f64x32_max_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_max_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_max_
		} else if (S >= 16 && _simd_f64x16_max_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_max_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_max_
		} else if (S >= 8 && _simd_f64x8_max_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_max_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_max_
		} else if (S >= 4 && _simd_f64x4_max_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_max_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_max_
		} else if (S >= 2 && _simd_f64x2_max_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_max_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_MAX> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_MAX> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPEQ> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpeq_
		} else if (S >= 64 && _simd_f64x64_cmpeq_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmpeq_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmpeq_
		} else if (S >= 32 && _simd_f64x32_cmpeq_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmpeq_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmpeq_
		} else if (S >= 16 && _simd_f64x16_cmpeq_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmpeq_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmpeq_
		} else if (S >= 8 && _simd_f64x8_cmpeq_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmpeq_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmpeq_
		} else if (S >= 4 && _simd_f64x4_cmpeq_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmpeq_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmpeq_
		} else if (S >= 2 && _simd_f64x2_cmpeq_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmpeq_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPEQ> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPEQ> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPNE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpne_
		} else if (S >= 64 && _simd_f64x64_cmpne_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmpne_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmpne_
		} else if (S >= 32 && _simd_f64x32_cmpne_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmpne_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmpne_
		} else if (S >= 16 && _simd_f64x16_cmpne_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmpne_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmpne_
		} else if (S >= 8 && _simd_f64x8_cmpne_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmpne_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmpne_
		} else if (S >= 4 && _simd_f64x4_cmpne_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmpne_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmpne_
		} else if (S >= 2 && _simd_f64x2_cmpne_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmpne_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPNE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPNE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPLT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmplt_
		} else if (S >= 64 && _simd_f64x64_cmplt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmplt_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmplt_
		} else if (S >= 32 && _simd_f64x32_cmplt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmplt_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmplt_
		} else if (S >= 16 && _simd_f64x16_cmplt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmplt_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmplt_
		} else if (S >= 8 && _simd_f64x8_cmplt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmplt_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmplt_
		} else if (S >= 4 && _simd_f64x4_cmplt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmplt_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmplt_
		} else if (S >= 2 && _simd_f64x2_cmplt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmplt_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPLT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPLT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPGT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpgt_
		} else if (S >= 64 && _simd_f64x64_cmpgt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmpgt_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmpgt_
		} else if (S >= 32 && _simd_f64x32_cmpgt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmpgt_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmpgt_
		} else if (S >= 16 && _simd_f64x16_cmpgt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmpgt_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmpgt_
		} else if (S >= 8 && _simd_f64x8_cmpgt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmpgt_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmpgt_
		} else if (S >= 4 && _simd_f64x4_cmpgt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmpgt_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmpgt_
		} else if (S >= 2 && _simd_f64x2_cmpgt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmpgt_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPGT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPGT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPLE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmple_
		} else if (S >= 64 && _simd_f64x64_cmple_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmple_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmple_
		} else if (S >= 32 && _simd_f64x32_cmple_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmple_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmple_
		} else if (S >= 16 && _simd_f64x16_cmple_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmple_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmple_
		} else if (S >= 8 && _simd_f64x8_cmple_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmple_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmple_
		} else if (S >= 4 && _simd_f64x4_cmple_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmple_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmple_
		} else if (S >= 2 && _simd_f64x2_cmple_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmple_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPLE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPLE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CMPGE> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cmpge_
		} else if (S >= 64 && _simd_f64x64_cmpge_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cmpge_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_cmpge_
		} else if (S >= 32 && _simd_f64x32_cmpge_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cmpge_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_cmpge_
		} else if (S >= 16 && _simd_f64x16_cmpge_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cmpge_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_cmpge_
		} else if (S >= 8 && _simd_f64x8_cmpge_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cmpge_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_cmpge_
		} else if (S >= 4 && _simd_f64x4_cmpge_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cmpge_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_cmpge_
		} else if (S >= 2 && _simd_f64x2_cmpge_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cmpge_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CMPGE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CMPGE> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_AND> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_and_
		} else if (S >= 64 && _simd_f64x64_and_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_and_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_and_
		} else if (S >= 32 && _simd_f64x32_and_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_and_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_and_
		} else if (S >= 16 && _simd_f64x16_and_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_and_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_and_
		} else if (S >= 8 && _simd_f64x8_and_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_and_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_and_
		} else if (S >= 4 && _simd_f64x4_and_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_and_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_and_
		} else if (S >= 2 && _simd_f64x2_and_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_and_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_AND> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_AND> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_OR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_or_
		} else if (S >= 64 && _simd_f64x64_or_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_or_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_or_
		} else if (S >= 32 && _simd_f64x32_or_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_or_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_or_
		} else if (S >= 16 && _simd_f64x16_or_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_or_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_or_
		} else if (S >= 8 && _simd_f64x8_or_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_or_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_or_
		} else if (S >= 4 && _simd_f64x4_or_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_or_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_or_
		} else if (S >= 2 && _simd_f64x2_or_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_or_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_OR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_OR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_XOR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_xor_
		} else if (S >= 64 && _simd_f64x64_xor_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_xor_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_xor_
		} else if (S >= 32 && _simd_f64x32_xor_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_xor_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_xor_
		} else if (S >= 16 && _simd_f64x16_xor_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_xor_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_xor_
		} else if (S >= 8 && _simd_f64x8_xor_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_xor_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_xor_
		} else if (S >= 4 && _simd_f64x4_xor_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_xor_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_xor_
		} else if (S >= 2 && _simd_f64x2_xor_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_xor_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_XOR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_XOR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_lshift_
		} else if (S >= 64 && _simd_f64x64_lshift_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_lshift_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_lshift_
		} else if (S >= 32 && _simd_f64x32_lshift_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_lshift_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_lshift_
		} else if (S >= 16 && _simd_f64x16_lshift_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_lshift_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_lshift_
		} else if (S >= 8 && _simd_f64x8_lshift_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_lshift_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_lshift_
		} else if (S >= 4 && _simd_f64x4_lshift_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_lshift_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_lshift_
		} else if (S >= 2 && _simd_f64x2_lshift_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_lshift_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_LSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_LSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_RSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_rshift_
		} else if (S >= 64 && _simd_f64x64_rshift_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_rshift_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_rshift_
		} else if (S >= 32 && _simd_f64x32_rshift_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_rshift_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_rshift_
		} else if (S >= 16 && _simd_f64x16_rshift_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_rshift_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_rshift_
		} else if (S >= 8 && _simd_f64x8_rshift_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_rshift_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_rshift_
		} else if (S >= 4 && _simd_f64x4_rshift_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_rshift_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_rshift_
		} else if (S >= 2 && _simd_f64x2_rshift_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_rshift_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_RSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_RSHIFT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ATAN2> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_atan2_
		} else if (S >= 64 && _simd_f64x64_atan2_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_atan2_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_atan2_
		} else if (S >= 32 && _simd_f64x32_atan2_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_atan2_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_atan2_
		} else if (S >= 16 && _simd_f64x16_atan2_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_atan2_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_atan2_
		} else if (S >= 8 && _simd_f64x8_atan2_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_atan2_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_atan2_
		} else if (S >= 4 && _simd_f64x4_atan2_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_atan2_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_atan2_
		} else if (S >= 2 && _simd_f64x2_atan2_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_atan2_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ATAN2> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ATAN2> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_POW> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_pow_
		} else if (S >= 64 && _simd_f64x64_pow_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_pow_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_pow_
		} else if (S >= 32 && _simd_f64x32_pow_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_pow_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_pow_
		} else if (S >= 16 && _simd_f64x16_pow_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_pow_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_pow_
		} else if (S >= 8 && _simd_f64x8_pow_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_pow_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_pow_
		} else if (S >= 4 && _simd_f64x4_pow_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_pow_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_pow_
		} else if (S >= 2 && _simd_f64x2_pow_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_pow_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_POW> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_POW> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_HYPOT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_hypot_
		} else if (S >= 64 && _simd_f64x64_hypot_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_hypot_(_simd_f64x64_load_(x),_simd_f64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f64x32_hypot_
		} else if (S >= 32 && _simd_f64x32_hypot_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_hypot_(_simd_f64x32_load_(x),_simd_f64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f64x16_hypot_
		} else if (S >= 16 && _simd_f64x16_hypot_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_hypot_(_simd_f64x16_load_(x),_simd_f64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f64x8_hypot_
		} else if (S >= 8 && _simd_f64x8_hypot_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_hypot_(_simd_f64x8_load_(x),_simd_f64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f64x4_hypot_
		} else if (S >= 4 && _simd_f64x4_hypot_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_hypot_(_simd_f64x4_load_(x),_simd_f64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f64x2_hypot_
		} else if (S >= 2 && _simd_f64x2_hypot_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_hypot_(_simd_f64x2_load_(x),_simd_f64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_HYPOT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f64x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_HYPOT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_NOT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_not_
		} else if (S >= 64 && _simd_f64x64_not_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_not_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f64x32_not_
		} else if (S >= 32 && _simd_f64x32_not_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_not_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f64x16_not_
		} else if (S >= 16 && _simd_f64x16_not_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_not_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f64x8_not_
		} else if (S >= 8 && _simd_f64x8_not_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_not_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f64x4_not_
		} else if (S >= 4 && _simd_f64x4_not_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_not_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f64x2_not_
		} else if (S >= 2 && _simd_f64x2_not_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_not_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_NOT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_NOT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ABS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_abs_
		} else if (S >= 64 && _simd_f64x64_abs_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_abs_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f64x32_abs_
		} else if (S >= 32 && _simd_f64x32_abs_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_abs_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f64x16_abs_
		} else if (S >= 16 && _simd_f64x16_abs_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_abs_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f64x8_abs_
		} else if (S >= 8 && _simd_f64x8_abs_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_abs_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f64x4_abs_
		} else if (S >= 4 && _simd_f64x4_abs_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_abs_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f64x2_abs_
		} else if (S >= 2 && _simd_f64x2_abs_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_abs_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ABS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ABS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_EXP> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_exp_
		} else if (S >= 64 && _simd_f64x64_exp_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_exp_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f64x32_exp_
		} else if (S >= 32 && _simd_f64x32_exp_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_exp_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f64x16_exp_
		} else if (S >= 16 && _simd_f64x16_exp_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_exp_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f64x8_exp_
		} else if (S >= 8 && _simd_f64x8_exp_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_exp_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f64x4_exp_
		} else if (S >= 4 && _simd_f64x4_exp_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_exp_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f64x2_exp_
		} else if (S >= 2 && _simd_f64x2_exp_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_exp_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_EXP> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_EXP> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log_
		} else if (S >= 64 && _simd_f64x64_log_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_log_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f64x32_log_
		} else if (S >= 32 && _simd_f64x32_log_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_log_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f64x16_log_
		} else if (S >= 16 && _simd_f64x16_log_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_log_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f64x8_log_
		} else if (S >= 8 && _simd_f64x8_log_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_log_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f64x4_log_
		} else if (S >= 4 && _simd_f64x4_log_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_log_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f64x2_log_
		} else if (S >= 2 && _simd_f64x2_log_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_log_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_LOG> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_LOG> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG2> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log2_
		} else if (S >= 64 && _simd_f64x64_log2_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_log2_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f64x32_log2_
		} else if (S >= 32 && _simd_f64x32_log2_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_log2_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f64x16_log2_
		} else if (S >= 16 && _simd_f64x16_log2_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_log2_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f64x8_log2_
		} else if (S >= 8 && _simd_f64x8_log2_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_log2_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f64x4_log2_
		} else if (S >= 4 && _simd_f64x4_log2_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_log2_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f64x2_log2_
		} else if (S >= 2 && _simd_f64x2_log2_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_log2_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_LOG2> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_LOG2> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_LOG10> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_log10_
		} else if (S >= 64 && _simd_f64x64_log10_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_log10_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f64x32_log10_
		} else if (S >= 32 && _simd_f64x32_log10_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_log10_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f64x16_log10_
		} else if (S >= 16 && _simd_f64x16_log10_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_log10_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f64x8_log10_
		} else if (S >= 8 && _simd_f64x8_log10_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_log10_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f64x4_log10_
		} else if (S >= 4 && _simd_f64x4_log10_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_log10_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f64x2_log10_
		} else if (S >= 2 && _simd_f64x2_log10_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_log10_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_LOG10> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_LOG10> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CEIL> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_ceil_
		} else if (S >= 64 && _simd_f64x64_ceil_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_ceil_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f64x32_ceil_
		} else if (S >= 32 && _simd_f64x32_ceil_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_ceil_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f64x16_ceil_
		} else if (S >= 16 && _simd_f64x16_ceil_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_ceil_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f64x8_ceil_
		} else if (S >= 8 && _simd_f64x8_ceil_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_ceil_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f64x4_ceil_
		} else if (S >= 4 && _simd_f64x4_ceil_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_ceil_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f64x2_ceil_
		} else if (S >= 2 && _simd_f64x2_ceil_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_ceil_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CEIL> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CEIL> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_FLOOR> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_floor_
		} else if (S >= 64 && _simd_f64x64_floor_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_floor_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f64x32_floor_
		} else if (S >= 32 && _simd_f64x32_floor_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_floor_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f64x16_floor_
		} else if (S >= 16 && _simd_f64x16_floor_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_floor_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f64x8_floor_
		} else if (S >= 8 && _simd_f64x8_floor_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_floor_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f64x4_floor_
		} else if (S >= 4 && _simd_f64x4_floor_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_floor_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f64x2_floor_
		} else if (S >= 2 && _simd_f64x2_floor_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_floor_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_FLOOR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_FLOOR> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ROUND> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_round_
		} else if (S >= 64 && _simd_f64x64_round_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_round_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f64x32_round_
		} else if (S >= 32 && _simd_f64x32_round_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_round_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f64x16_round_
		} else if (S >= 16 && _simd_f64x16_round_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_round_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f64x8_round_
		} else if (S >= 8 && _simd_f64x8_round_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_round_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f64x4_round_
		} else if (S >= 4 && _simd_f64x4_round_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_round_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f64x2_round_
		} else if (S >= 2 && _simd_f64x2_round_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_round_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ROUND> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ROUND> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sin_
		} else if (S >= 64 && _simd_f64x64_sin_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_sin_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f64x32_sin_
		} else if (S >= 32 && _simd_f64x32_sin_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_sin_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f64x16_sin_
		} else if (S >= 16 && _simd_f64x16_sin_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_sin_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f64x8_sin_
		} else if (S >= 8 && _simd_f64x8_sin_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_sin_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f64x4_sin_
		} else if (S >= 4 && _simd_f64x4_sin_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_sin_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f64x2_sin_
		} else if (S >= 2 && _simd_f64x2_sin_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_sin_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_SIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_SIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_COS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cos_
		} else if (S >= 64 && _simd_f64x64_cos_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cos_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f64x32_cos_
		} else if (S >= 32 && _simd_f64x32_cos_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cos_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f64x16_cos_
		} else if (S >= 16 && _simd_f64x16_cos_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cos_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f64x8_cos_
		} else if (S >= 8 && _simd_f64x8_cos_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cos_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f64x4_cos_
		} else if (S >= 4 && _simd_f64x4_cos_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cos_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f64x2_cos_
		} else if (S >= 2 && _simd_f64x2_cos_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cos_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_COS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_COS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_TAN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_tan_
		} else if (S >= 64 && _simd_f64x64_tan_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_tan_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f64x32_tan_
		} else if (S >= 32 && _simd_f64x32_tan_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_tan_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f64x16_tan_
		} else if (S >= 16 && _simd_f64x16_tan_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_tan_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f64x8_tan_
		} else if (S >= 8 && _simd_f64x8_tan_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_tan_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f64x4_tan_
		} else if (S >= 4 && _simd_f64x4_tan_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_tan_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f64x2_tan_
		} else if (S >= 2 && _simd_f64x2_tan_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_tan_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_TAN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_TAN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ASIN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_asin_
		} else if (S >= 64 && _simd_f64x64_asin_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_asin_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f64x32_asin_
		} else if (S >= 32 && _simd_f64x32_asin_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_asin_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f64x16_asin_
		} else if (S >= 16 && _simd_f64x16_asin_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_asin_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f64x8_asin_
		} else if (S >= 8 && _simd_f64x8_asin_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_asin_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f64x4_asin_
		} else if (S >= 4 && _simd_f64x4_asin_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_asin_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f64x2_asin_
		} else if (S >= 2 && _simd_f64x2_asin_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_asin_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ASIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ASIN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ACOS> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_acos_
		} else if (S >= 64 && _simd_f64x64_acos_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_acos_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f64x32_acos_
		} else if (S >= 32 && _simd_f64x32_acos_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_acos_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f64x16_acos_
		} else if (S >= 16 && _simd_f64x16_acos_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_acos_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f64x8_acos_
		} else if (S >= 8 && _simd_f64x8_acos_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_acos_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f64x4_acos_
		} else if (S >= 4 && _simd_f64x4_acos_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_acos_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f64x2_acos_
		} else if (S >= 2 && _simd_f64x2_acos_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_acos_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ACOS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ACOS> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_ATAN> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_atan_
		} else if (S >= 64 && _simd_f64x64_atan_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_atan_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f64x32_atan_
		} else if (S >= 32 && _simd_f64x32_atan_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_atan_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f64x16_atan_
		} else if (S >= 16 && _simd_f64x16_atan_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_atan_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f64x8_atan_
		} else if (S >= 8 && _simd_f64x8_atan_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_atan_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f64x4_atan_
		} else if (S >= 4 && _simd_f64x4_atan_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_atan_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f64x2_atan_
		} else if (S >= 2 && _simd_f64x2_atan_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_atan_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_ATAN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_ATAN> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SINH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sinh_
		} else if (S >= 64 && _simd_f64x64_sinh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_sinh_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f64x32_sinh_
		} else if (S >= 32 && _simd_f64x32_sinh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_sinh_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f64x16_sinh_
		} else if (S >= 16 && _simd_f64x16_sinh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_sinh_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f64x8_sinh_
		} else if (S >= 8 && _simd_f64x8_sinh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_sinh_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f64x4_sinh_
		} else if (S >= 4 && _simd_f64x4_sinh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_sinh_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f64x2_sinh_
		} else if (S >= 2 && _simd_f64x2_sinh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_sinh_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_SINH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_SINH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_COSH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cosh_
		} else if (S >= 64 && _simd_f64x64_cosh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cosh_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f64x32_cosh_
		} else if (S >= 32 && _simd_f64x32_cosh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cosh_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f64x16_cosh_
		} else if (S >= 16 && _simd_f64x16_cosh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cosh_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f64x8_cosh_
		} else if (S >= 8 && _simd_f64x8_cosh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cosh_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f64x4_cosh_
		} else if (S >= 4 && _simd_f64x4_cosh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cosh_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f64x2_cosh_
		} else if (S >= 2 && _simd_f64x2_cosh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cosh_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_COSH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_COSH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_TANH> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_tanh_
		} else if (S >= 64 && _simd_f64x64_tanh_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_tanh_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f64x32_tanh_
		} else if (S >= 32 && _simd_f64x32_tanh_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_tanh_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f64x16_tanh_
		} else if (S >= 16 && _simd_f64x16_tanh_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_tanh_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f64x8_tanh_
		} else if (S >= 8 && _simd_f64x8_tanh_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_tanh_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f64x4_tanh_
		} else if (S >= 4 && _simd_f64x4_tanh_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_tanh_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f64x2_tanh_
		} else if (S >= 2 && _simd_f64x2_tanh_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_tanh_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_TANH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_TANH> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_SQRT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_sqrt_
		} else if (S >= 64 && _simd_f64x64_sqrt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_sqrt_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f64x32_sqrt_
		} else if (S >= 32 && _simd_f64x32_sqrt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_sqrt_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f64x16_sqrt_
		} else if (S >= 16 && _simd_f64x16_sqrt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_sqrt_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f64x8_sqrt_
		} else if (S >= 8 && _simd_f64x8_sqrt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_sqrt_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f64x4_sqrt_
		} else if (S >= 4 && _simd_f64x4_sqrt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_sqrt_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f64x2_sqrt_
		} else if (S >= 2 && _simd_f64x2_sqrt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_sqrt_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_SQRT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_SQRT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f64x1, S, OP_CBRT> {
	typedef _simd_f64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f64x64_cbrt_
		} else if (S >= 64 && _simd_f64x64_cbrt_enable()) {
			typedef _simd_f64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x64_cbrt_(_simd_f64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f64x32_cbrt_
		} else if (S >= 32 && _simd_f64x32_cbrt_enable()) {
			typedef _simd_f64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x32_cbrt_(_simd_f64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f64x16_cbrt_
		} else if (S >= 16 && _simd_f64x16_cbrt_enable()) {
			typedef _simd_f64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x16_cbrt_(_simd_f64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f64x8_cbrt_
		} else if (S >= 8 && _simd_f64x8_cbrt_enable()) {
			typedef _simd_f64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x8_cbrt_(_simd_f64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f64x4_cbrt_
		} else if (S >= 4 && _simd_f64x4_cbrt_enable()) {
			typedef _simd_f64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x4_cbrt_(_simd_f64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f64x2_cbrt_
		} else if (S >= 2 && _simd_f64x2_cbrt_enable()) {
			typedef _simd_f64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f64x2_cbrt_(_simd_f64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f64x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 1, OP_CBRT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f64x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f64x1, 0, OP_CBRT> {
	typedef _simd_f64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S,OP_SUM> {
	typedef _simd_f32x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_add_
		} else if (S >= 64 && _simd_f32x64_add_enable()) {
			typedef _simd_f32x64 simd_t;
			simd_t tmp = _simd_f32x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x64_add_(tmp, _simd_f32x64_load_(o)); 
				o += 64;
			}
			return _simd_f32x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f32x32_add_
		} else if (S >= 32 && _simd_f32x32_add_enable()) {
			typedef _simd_f32x32 simd_t;
			simd_t tmp = _simd_f32x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x32_add_(tmp, _simd_f32x32_load_(o)); 
				o += 32;
			}
			return _simd_f32x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f32x16_add_
		} else if (S >= 16 && _simd_f32x16_add_enable()) {
			typedef _simd_f32x16 simd_t;
			simd_t tmp = _simd_f32x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x16_add_(tmp, _simd_f32x16_load_(o)); 
				o += 16;
			}
			return _simd_f32x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f32x8_add_
		} else if (S >= 8 && _simd_f32x8_add_enable()) {
			typedef _simd_f32x8 simd_t;
			simd_t tmp = _simd_f32x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x8_add_(tmp, _simd_f32x8_load_(o)); 
				o += 8;
			}
			return _simd_f32x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f32x4_add_
		} else if (S >= 4 && _simd_f32x4_add_enable()) {
			typedef _simd_f32x4 simd_t;
			simd_t tmp = _simd_f32x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x4_add_(tmp, _simd_f32x4_load_(o)); 
				o += 4;
			}
			return _simd_f32x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_f32x2_add_
		} else if (S >= 2 && _simd_f32x2_add_enable()) {
			typedef _simd_f32x2 simd_t;
			simd_t tmp = _simd_f32x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_f32x2_add_(tmp, _simd_f32x2_load_(o)); 
				o += 2;
			}
			return _simd_f32x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1,OP_SUM> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0,OP_SUM> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FILL0> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fill_zero_
		} else if (S >= 64 && _simd_f32x64_fill_zero_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f32x32_fill_zero_
		} else if (S >= 32 && _simd_f32x32_fill_zero_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f32x16_fill_zero_
		} else if (S >= 16 && _simd_f32x16_fill_zero_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f32x8_fill_zero_
		} else if (S >= 8 && _simd_f32x8_fill_zero_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f32x4_fill_zero_
		} else if (S >= 4 && _simd_f32x4_fill_zero_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_f32x2_fill_zero_
		} else if (S >= 2 && _simd_f32x2_fill_zero_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FILLU> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FILLS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fill_scalar_
		} else if (S >= 64 && _simd_f32x64_fill_scalar_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f32x32_fill_scalar_
		} else if (S >= 32 && _simd_f32x32_fill_scalar_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f32x16_fill_scalar_
		} else if (S >= 16 && _simd_f32x16_fill_scalar_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f32x8_fill_scalar_
		} else if (S >= 8 && _simd_f32x8_fill_scalar_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f32x4_fill_scalar_
		} else if (S >= 4 && _simd_f32x4_fill_scalar_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_f32x2_fill_scalar_
		} else if (S >= 2 && _simd_f32x2_fill_scalar_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FMA> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fma_
		} else if (S >= 64 && _simd_f32x64_fma_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_fma_(_simd_f32x64_load_(x),_simd_f32x64_load_(y),_simd_f32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x32_fma_
		} else if (S >= 32 && _simd_f32x32_fma_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_fma_(_simd_f32x32_load_(x),_simd_f32x32_load_(y),_simd_f32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x16_fma_
		} else if (S >= 16 && _simd_f32x16_fma_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_fma_(_simd_f32x16_load_(x),_simd_f32x16_load_(y),_simd_f32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x8_fma_
		} else if (S >= 8 && _simd_f32x8_fma_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_fma_(_simd_f32x8_load_(x),_simd_f32x8_load_(y),_simd_f32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x4_fma_
		} else if (S >= 4 && _simd_f32x4_fma_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_fma_(_simd_f32x4_load_(x),_simd_f32x4_load_(y),_simd_f32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x2_fma_
		} else if (S >= 2 && _simd_f32x2_fma_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_fma_(_simd_f32x2_load_(x),_simd_f32x2_load_(y),_simd_f32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_FMA> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_f32x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_FMA> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FMS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_fms_
		} else if (S >= 64 && _simd_f32x64_fms_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_fms_(_simd_f32x64_load_(x),_simd_f32x64_load_(y),_simd_f32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x32_fms_
		} else if (S >= 32 && _simd_f32x32_fms_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_fms_(_simd_f32x32_load_(x),_simd_f32x32_load_(y),_simd_f32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x16_fms_
		} else if (S >= 16 && _simd_f32x16_fms_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_fms_(_simd_f32x16_load_(x),_simd_f32x16_load_(y),_simd_f32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x8_fms_
		} else if (S >= 8 && _simd_f32x8_fms_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_fms_(_simd_f32x8_load_(x),_simd_f32x8_load_(y),_simd_f32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x4_fms_
		} else if (S >= 4 && _simd_f32x4_fms_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_fms_(_simd_f32x4_load_(x),_simd_f32x4_load_(y),_simd_f32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_f32x2_fms_
		} else if (S >= 2 && _simd_f32x2_fms_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_fms_(_simd_f32x2_load_(x),_simd_f32x2_load_(y),_simd_f32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_FMS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_f32x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_FMS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ADD> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_add_
		} else if (S >= 64 && _simd_f32x64_add_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_add_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_add_
		} else if (S >= 32 && _simd_f32x32_add_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_add_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_add_
		} else if (S >= 16 && _simd_f32x16_add_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_add_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_add_
		} else if (S >= 8 && _simd_f32x8_add_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_add_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_add_
		} else if (S >= 4 && _simd_f32x4_add_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_add_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_add_
		} else if (S >= 2 && _simd_f32x2_add_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_add_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ADD> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ADD> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SUB> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sub_
		} else if (S >= 64 && _simd_f32x64_sub_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_sub_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_sub_
		} else if (S >= 32 && _simd_f32x32_sub_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_sub_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_sub_
		} else if (S >= 16 && _simd_f32x16_sub_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_sub_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_sub_
		} else if (S >= 8 && _simd_f32x8_sub_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_sub_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_sub_
		} else if (S >= 4 && _simd_f32x4_sub_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_sub_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_sub_
		} else if (S >= 2 && _simd_f32x2_sub_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_sub_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_SUB> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_SUB> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MUL> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_mul_
		} else if (S >= 64 && _simd_f32x64_mul_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_mul_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_mul_
		} else if (S >= 32 && _simd_f32x32_mul_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_mul_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_mul_
		} else if (S >= 16 && _simd_f32x16_mul_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_mul_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_mul_
		} else if (S >= 8 && _simd_f32x8_mul_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_mul_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_mul_
		} else if (S >= 4 && _simd_f32x4_mul_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_mul_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_mul_
		} else if (S >= 2 && _simd_f32x2_mul_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_mul_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_MUL> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_MUL> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_DIV> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_div_
		} else if (S >= 64 && _simd_f32x64_div_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_div_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_div_
		} else if (S >= 32 && _simd_f32x32_div_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_div_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_div_
		} else if (S >= 16 && _simd_f32x16_div_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_div_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_div_
		} else if (S >= 8 && _simd_f32x8_div_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_div_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_div_
		} else if (S >= 4 && _simd_f32x4_div_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_div_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_div_
		} else if (S >= 2 && _simd_f32x2_div_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_div_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_DIV> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_DIV> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_min_
		} else if (S >= 64 && _simd_f32x64_min_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_min_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_min_
		} else if (S >= 32 && _simd_f32x32_min_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_min_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_min_
		} else if (S >= 16 && _simd_f32x16_min_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_min_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_min_
		} else if (S >= 8 && _simd_f32x8_min_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_min_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_min_
		} else if (S >= 4 && _simd_f32x4_min_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_min_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_min_
		} else if (S >= 2 && _simd_f32x2_min_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_min_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_MIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_MIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_MAX> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_max_
		} else if (S >= 64 && _simd_f32x64_max_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_max_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_max_
		} else if (S >= 32 && _simd_f32x32_max_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_max_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_max_
		} else if (S >= 16 && _simd_f32x16_max_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_max_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_max_
		} else if (S >= 8 && _simd_f32x8_max_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_max_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_max_
		} else if (S >= 4 && _simd_f32x4_max_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_max_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_max_
		} else if (S >= 2 && _simd_f32x2_max_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_max_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_MAX> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_MAX> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPEQ> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpeq_
		} else if (S >= 64 && _simd_f32x64_cmpeq_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmpeq_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmpeq_
		} else if (S >= 32 && _simd_f32x32_cmpeq_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmpeq_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmpeq_
		} else if (S >= 16 && _simd_f32x16_cmpeq_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmpeq_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmpeq_
		} else if (S >= 8 && _simd_f32x8_cmpeq_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmpeq_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmpeq_
		} else if (S >= 4 && _simd_f32x4_cmpeq_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmpeq_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmpeq_
		} else if (S >= 2 && _simd_f32x2_cmpeq_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmpeq_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPEQ> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPEQ> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPNE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpne_
		} else if (S >= 64 && _simd_f32x64_cmpne_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmpne_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmpne_
		} else if (S >= 32 && _simd_f32x32_cmpne_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmpne_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmpne_
		} else if (S >= 16 && _simd_f32x16_cmpne_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmpne_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmpne_
		} else if (S >= 8 && _simd_f32x8_cmpne_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmpne_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmpne_
		} else if (S >= 4 && _simd_f32x4_cmpne_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmpne_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmpne_
		} else if (S >= 2 && _simd_f32x2_cmpne_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmpne_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPNE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPNE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPLT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmplt_
		} else if (S >= 64 && _simd_f32x64_cmplt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmplt_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmplt_
		} else if (S >= 32 && _simd_f32x32_cmplt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmplt_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmplt_
		} else if (S >= 16 && _simd_f32x16_cmplt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmplt_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmplt_
		} else if (S >= 8 && _simd_f32x8_cmplt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmplt_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmplt_
		} else if (S >= 4 && _simd_f32x4_cmplt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmplt_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmplt_
		} else if (S >= 2 && _simd_f32x2_cmplt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmplt_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPLT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPLT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPGT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpgt_
		} else if (S >= 64 && _simd_f32x64_cmpgt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmpgt_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmpgt_
		} else if (S >= 32 && _simd_f32x32_cmpgt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmpgt_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmpgt_
		} else if (S >= 16 && _simd_f32x16_cmpgt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmpgt_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmpgt_
		} else if (S >= 8 && _simd_f32x8_cmpgt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmpgt_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmpgt_
		} else if (S >= 4 && _simd_f32x4_cmpgt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmpgt_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmpgt_
		} else if (S >= 2 && _simd_f32x2_cmpgt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmpgt_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPGT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPGT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPLE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmple_
		} else if (S >= 64 && _simd_f32x64_cmple_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmple_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmple_
		} else if (S >= 32 && _simd_f32x32_cmple_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmple_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmple_
		} else if (S >= 16 && _simd_f32x16_cmple_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmple_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmple_
		} else if (S >= 8 && _simd_f32x8_cmple_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmple_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmple_
		} else if (S >= 4 && _simd_f32x4_cmple_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmple_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmple_
		} else if (S >= 2 && _simd_f32x2_cmple_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmple_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPLE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPLE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CMPGE> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cmpge_
		} else if (S >= 64 && _simd_f32x64_cmpge_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cmpge_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_cmpge_
		} else if (S >= 32 && _simd_f32x32_cmpge_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cmpge_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_cmpge_
		} else if (S >= 16 && _simd_f32x16_cmpge_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cmpge_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_cmpge_
		} else if (S >= 8 && _simd_f32x8_cmpge_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cmpge_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_cmpge_
		} else if (S >= 4 && _simd_f32x4_cmpge_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cmpge_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_cmpge_
		} else if (S >= 2 && _simd_f32x2_cmpge_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cmpge_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CMPGE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CMPGE> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_AND> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_and_
		} else if (S >= 64 && _simd_f32x64_and_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_and_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_and_
		} else if (S >= 32 && _simd_f32x32_and_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_and_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_and_
		} else if (S >= 16 && _simd_f32x16_and_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_and_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_and_
		} else if (S >= 8 && _simd_f32x8_and_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_and_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_and_
		} else if (S >= 4 && _simd_f32x4_and_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_and_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_and_
		} else if (S >= 2 && _simd_f32x2_and_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_and_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_AND> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_AND> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_OR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_or_
		} else if (S >= 64 && _simd_f32x64_or_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_or_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_or_
		} else if (S >= 32 && _simd_f32x32_or_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_or_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_or_
		} else if (S >= 16 && _simd_f32x16_or_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_or_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_or_
		} else if (S >= 8 && _simd_f32x8_or_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_or_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_or_
		} else if (S >= 4 && _simd_f32x4_or_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_or_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_or_
		} else if (S >= 2 && _simd_f32x2_or_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_or_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_OR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_OR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_XOR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_xor_
		} else if (S >= 64 && _simd_f32x64_xor_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_xor_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_xor_
		} else if (S >= 32 && _simd_f32x32_xor_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_xor_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_xor_
		} else if (S >= 16 && _simd_f32x16_xor_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_xor_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_xor_
		} else if (S >= 8 && _simd_f32x8_xor_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_xor_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_xor_
		} else if (S >= 4 && _simd_f32x4_xor_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_xor_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_xor_
		} else if (S >= 2 && _simd_f32x2_xor_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_xor_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_XOR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_XOR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_lshift_
		} else if (S >= 64 && _simd_f32x64_lshift_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_lshift_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_lshift_
		} else if (S >= 32 && _simd_f32x32_lshift_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_lshift_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_lshift_
		} else if (S >= 16 && _simd_f32x16_lshift_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_lshift_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_lshift_
		} else if (S >= 8 && _simd_f32x8_lshift_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_lshift_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_lshift_
		} else if (S >= 4 && _simd_f32x4_lshift_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_lshift_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_lshift_
		} else if (S >= 2 && _simd_f32x2_lshift_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_lshift_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_LSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_LSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_RSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_rshift_
		} else if (S >= 64 && _simd_f32x64_rshift_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_rshift_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_rshift_
		} else if (S >= 32 && _simd_f32x32_rshift_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_rshift_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_rshift_
		} else if (S >= 16 && _simd_f32x16_rshift_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_rshift_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_rshift_
		} else if (S >= 8 && _simd_f32x8_rshift_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_rshift_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_rshift_
		} else if (S >= 4 && _simd_f32x4_rshift_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_rshift_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_rshift_
		} else if (S >= 2 && _simd_f32x2_rshift_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_rshift_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_RSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_RSHIFT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ATAN2> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_atan2_
		} else if (S >= 64 && _simd_f32x64_atan2_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_atan2_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_atan2_
		} else if (S >= 32 && _simd_f32x32_atan2_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_atan2_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_atan2_
		} else if (S >= 16 && _simd_f32x16_atan2_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_atan2_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_atan2_
		} else if (S >= 8 && _simd_f32x8_atan2_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_atan2_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_atan2_
		} else if (S >= 4 && _simd_f32x4_atan2_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_atan2_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_atan2_
		} else if (S >= 2 && _simd_f32x2_atan2_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_atan2_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ATAN2> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ATAN2> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_POW> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_pow_
		} else if (S >= 64 && _simd_f32x64_pow_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_pow_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_pow_
		} else if (S >= 32 && _simd_f32x32_pow_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_pow_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_pow_
		} else if (S >= 16 && _simd_f32x16_pow_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_pow_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_pow_
		} else if (S >= 8 && _simd_f32x8_pow_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_pow_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_pow_
		} else if (S >= 4 && _simd_f32x4_pow_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_pow_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_pow_
		} else if (S >= 2 && _simd_f32x2_pow_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_pow_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_POW> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_POW> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_HYPOT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_hypot_
		} else if (S >= 64 && _simd_f32x64_hypot_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_hypot_(_simd_f32x64_load_(x),_simd_f32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f32x32_hypot_
		} else if (S >= 32 && _simd_f32x32_hypot_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_hypot_(_simd_f32x32_load_(x),_simd_f32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f32x16_hypot_
		} else if (S >= 16 && _simd_f32x16_hypot_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_hypot_(_simd_f32x16_load_(x),_simd_f32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f32x8_hypot_
		} else if (S >= 8 && _simd_f32x8_hypot_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_hypot_(_simd_f32x8_load_(x),_simd_f32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f32x4_hypot_
		} else if (S >= 4 && _simd_f32x4_hypot_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_hypot_(_simd_f32x4_load_(x),_simd_f32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_f32x2_hypot_
		} else if (S >= 2 && _simd_f32x2_hypot_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_hypot_(_simd_f32x2_load_(x),_simd_f32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_HYPOT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_f32x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_HYPOT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_NOT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_not_
		} else if (S >= 64 && _simd_f32x64_not_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_not_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f32x32_not_
		} else if (S >= 32 && _simd_f32x32_not_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_not_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f32x16_not_
		} else if (S >= 16 && _simd_f32x16_not_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_not_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f32x8_not_
		} else if (S >= 8 && _simd_f32x8_not_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_not_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f32x4_not_
		} else if (S >= 4 && _simd_f32x4_not_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_not_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_f32x2_not_
		} else if (S >= 2 && _simd_f32x2_not_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_not_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_NOT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_NOT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ABS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_abs_
		} else if (S >= 64 && _simd_f32x64_abs_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_abs_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f32x32_abs_
		} else if (S >= 32 && _simd_f32x32_abs_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_abs_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f32x16_abs_
		} else if (S >= 16 && _simd_f32x16_abs_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_abs_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f32x8_abs_
		} else if (S >= 8 && _simd_f32x8_abs_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_abs_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f32x4_abs_
		} else if (S >= 4 && _simd_f32x4_abs_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_abs_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_f32x2_abs_
		} else if (S >= 2 && _simd_f32x2_abs_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_abs_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ABS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ABS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_EXP> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_exp_
		} else if (S >= 64 && _simd_f32x64_exp_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_exp_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f32x32_exp_
		} else if (S >= 32 && _simd_f32x32_exp_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_exp_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f32x16_exp_
		} else if (S >= 16 && _simd_f32x16_exp_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_exp_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f32x8_exp_
		} else if (S >= 8 && _simd_f32x8_exp_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_exp_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f32x4_exp_
		} else if (S >= 4 && _simd_f32x4_exp_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_exp_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_f32x2_exp_
		} else if (S >= 2 && _simd_f32x2_exp_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_exp_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_EXP> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_EXP> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log_
		} else if (S >= 64 && _simd_f32x64_log_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_log_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f32x32_log_
		} else if (S >= 32 && _simd_f32x32_log_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_log_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f32x16_log_
		} else if (S >= 16 && _simd_f32x16_log_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_log_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f32x8_log_
		} else if (S >= 8 && _simd_f32x8_log_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_log_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f32x4_log_
		} else if (S >= 4 && _simd_f32x4_log_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_log_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_f32x2_log_
		} else if (S >= 2 && _simd_f32x2_log_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_log_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_LOG> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_LOG> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG2> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log2_
		} else if (S >= 64 && _simd_f32x64_log2_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_log2_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f32x32_log2_
		} else if (S >= 32 && _simd_f32x32_log2_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_log2_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f32x16_log2_
		} else if (S >= 16 && _simd_f32x16_log2_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_log2_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f32x8_log2_
		} else if (S >= 8 && _simd_f32x8_log2_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_log2_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f32x4_log2_
		} else if (S >= 4 && _simd_f32x4_log2_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_log2_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_f32x2_log2_
		} else if (S >= 2 && _simd_f32x2_log2_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_log2_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_LOG2> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_LOG2> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_LOG10> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_log10_
		} else if (S >= 64 && _simd_f32x64_log10_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_log10_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f32x32_log10_
		} else if (S >= 32 && _simd_f32x32_log10_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_log10_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f32x16_log10_
		} else if (S >= 16 && _simd_f32x16_log10_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_log10_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f32x8_log10_
		} else if (S >= 8 && _simd_f32x8_log10_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_log10_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f32x4_log10_
		} else if (S >= 4 && _simd_f32x4_log10_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_log10_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_f32x2_log10_
		} else if (S >= 2 && _simd_f32x2_log10_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_log10_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_LOG10> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_LOG10> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CEIL> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_ceil_
		} else if (S >= 64 && _simd_f32x64_ceil_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_ceil_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f32x32_ceil_
		} else if (S >= 32 && _simd_f32x32_ceil_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_ceil_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f32x16_ceil_
		} else if (S >= 16 && _simd_f32x16_ceil_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_ceil_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f32x8_ceil_
		} else if (S >= 8 && _simd_f32x8_ceil_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_ceil_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f32x4_ceil_
		} else if (S >= 4 && _simd_f32x4_ceil_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_ceil_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_f32x2_ceil_
		} else if (S >= 2 && _simd_f32x2_ceil_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_ceil_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CEIL> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CEIL> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_FLOOR> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_floor_
		} else if (S >= 64 && _simd_f32x64_floor_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_floor_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f32x32_floor_
		} else if (S >= 32 && _simd_f32x32_floor_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_floor_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f32x16_floor_
		} else if (S >= 16 && _simd_f32x16_floor_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_floor_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f32x8_floor_
		} else if (S >= 8 && _simd_f32x8_floor_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_floor_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f32x4_floor_
		} else if (S >= 4 && _simd_f32x4_floor_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_floor_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_f32x2_floor_
		} else if (S >= 2 && _simd_f32x2_floor_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_floor_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_FLOOR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_FLOOR> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ROUND> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_round_
		} else if (S >= 64 && _simd_f32x64_round_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_round_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f32x32_round_
		} else if (S >= 32 && _simd_f32x32_round_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_round_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f32x16_round_
		} else if (S >= 16 && _simd_f32x16_round_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_round_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f32x8_round_
		} else if (S >= 8 && _simd_f32x8_round_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_round_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f32x4_round_
		} else if (S >= 4 && _simd_f32x4_round_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_round_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_f32x2_round_
		} else if (S >= 2 && _simd_f32x2_round_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_round_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ROUND> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ROUND> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sin_
		} else if (S >= 64 && _simd_f32x64_sin_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_sin_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f32x32_sin_
		} else if (S >= 32 && _simd_f32x32_sin_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_sin_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f32x16_sin_
		} else if (S >= 16 && _simd_f32x16_sin_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_sin_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f32x8_sin_
		} else if (S >= 8 && _simd_f32x8_sin_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_sin_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f32x4_sin_
		} else if (S >= 4 && _simd_f32x4_sin_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_sin_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_f32x2_sin_
		} else if (S >= 2 && _simd_f32x2_sin_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_sin_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_SIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_SIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_COS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cos_
		} else if (S >= 64 && _simd_f32x64_cos_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cos_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f32x32_cos_
		} else if (S >= 32 && _simd_f32x32_cos_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cos_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f32x16_cos_
		} else if (S >= 16 && _simd_f32x16_cos_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cos_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f32x8_cos_
		} else if (S >= 8 && _simd_f32x8_cos_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cos_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f32x4_cos_
		} else if (S >= 4 && _simd_f32x4_cos_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cos_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_f32x2_cos_
		} else if (S >= 2 && _simd_f32x2_cos_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cos_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_COS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_COS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_TAN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_tan_
		} else if (S >= 64 && _simd_f32x64_tan_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_tan_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f32x32_tan_
		} else if (S >= 32 && _simd_f32x32_tan_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_tan_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f32x16_tan_
		} else if (S >= 16 && _simd_f32x16_tan_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_tan_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f32x8_tan_
		} else if (S >= 8 && _simd_f32x8_tan_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_tan_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f32x4_tan_
		} else if (S >= 4 && _simd_f32x4_tan_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_tan_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_f32x2_tan_
		} else if (S >= 2 && _simd_f32x2_tan_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_tan_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_TAN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_TAN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ASIN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_asin_
		} else if (S >= 64 && _simd_f32x64_asin_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_asin_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f32x32_asin_
		} else if (S >= 32 && _simd_f32x32_asin_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_asin_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f32x16_asin_
		} else if (S >= 16 && _simd_f32x16_asin_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_asin_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f32x8_asin_
		} else if (S >= 8 && _simd_f32x8_asin_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_asin_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f32x4_asin_
		} else if (S >= 4 && _simd_f32x4_asin_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_asin_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_f32x2_asin_
		} else if (S >= 2 && _simd_f32x2_asin_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_asin_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ASIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ASIN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ACOS> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_acos_
		} else if (S >= 64 && _simd_f32x64_acos_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_acos_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f32x32_acos_
		} else if (S >= 32 && _simd_f32x32_acos_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_acos_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f32x16_acos_
		} else if (S >= 16 && _simd_f32x16_acos_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_acos_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f32x8_acos_
		} else if (S >= 8 && _simd_f32x8_acos_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_acos_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f32x4_acos_
		} else if (S >= 4 && _simd_f32x4_acos_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_acos_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_f32x2_acos_
		} else if (S >= 2 && _simd_f32x2_acos_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_acos_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ACOS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ACOS> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_ATAN> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_atan_
		} else if (S >= 64 && _simd_f32x64_atan_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_atan_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f32x32_atan_
		} else if (S >= 32 && _simd_f32x32_atan_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_atan_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f32x16_atan_
		} else if (S >= 16 && _simd_f32x16_atan_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_atan_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f32x8_atan_
		} else if (S >= 8 && _simd_f32x8_atan_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_atan_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f32x4_atan_
		} else if (S >= 4 && _simd_f32x4_atan_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_atan_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_f32x2_atan_
		} else if (S >= 2 && _simd_f32x2_atan_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_atan_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_ATAN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_ATAN> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SINH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sinh_
		} else if (S >= 64 && _simd_f32x64_sinh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_sinh_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f32x32_sinh_
		} else if (S >= 32 && _simd_f32x32_sinh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_sinh_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f32x16_sinh_
		} else if (S >= 16 && _simd_f32x16_sinh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_sinh_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f32x8_sinh_
		} else if (S >= 8 && _simd_f32x8_sinh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_sinh_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f32x4_sinh_
		} else if (S >= 4 && _simd_f32x4_sinh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_sinh_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_f32x2_sinh_
		} else if (S >= 2 && _simd_f32x2_sinh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_sinh_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_SINH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_SINH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_COSH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cosh_
		} else if (S >= 64 && _simd_f32x64_cosh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cosh_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f32x32_cosh_
		} else if (S >= 32 && _simd_f32x32_cosh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cosh_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f32x16_cosh_
		} else if (S >= 16 && _simd_f32x16_cosh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cosh_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f32x8_cosh_
		} else if (S >= 8 && _simd_f32x8_cosh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cosh_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f32x4_cosh_
		} else if (S >= 4 && _simd_f32x4_cosh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cosh_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_f32x2_cosh_
		} else if (S >= 2 && _simd_f32x2_cosh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cosh_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_COSH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_COSH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_TANH> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_tanh_
		} else if (S >= 64 && _simd_f32x64_tanh_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_tanh_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f32x32_tanh_
		} else if (S >= 32 && _simd_f32x32_tanh_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_tanh_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f32x16_tanh_
		} else if (S >= 16 && _simd_f32x16_tanh_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_tanh_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f32x8_tanh_
		} else if (S >= 8 && _simd_f32x8_tanh_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_tanh_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f32x4_tanh_
		} else if (S >= 4 && _simd_f32x4_tanh_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_tanh_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_f32x2_tanh_
		} else if (S >= 2 && _simd_f32x2_tanh_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_tanh_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_TANH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_TANH> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_SQRT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_sqrt_
		} else if (S >= 64 && _simd_f32x64_sqrt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_sqrt_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f32x32_sqrt_
		} else if (S >= 32 && _simd_f32x32_sqrt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_sqrt_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f32x16_sqrt_
		} else if (S >= 16 && _simd_f32x16_sqrt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_sqrt_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f32x8_sqrt_
		} else if (S >= 8 && _simd_f32x8_sqrt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_sqrt_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f32x4_sqrt_
		} else if (S >= 4 && _simd_f32x4_sqrt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_sqrt_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_f32x2_sqrt_
		} else if (S >= 2 && _simd_f32x2_sqrt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_sqrt_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_SQRT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_SQRT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_f32x1, S, OP_CBRT> {
	typedef _simd_f32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_f32x64_cbrt_
		} else if (S >= 64 && _simd_f32x64_cbrt_enable()) {
			typedef _simd_f32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x64_cbrt_(_simd_f32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f32x32_cbrt_
		} else if (S >= 32 && _simd_f32x32_cbrt_enable()) {
			typedef _simd_f32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x32_cbrt_(_simd_f32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f32x16_cbrt_
		} else if (S >= 16 && _simd_f32x16_cbrt_enable()) {
			typedef _simd_f32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x16_cbrt_(_simd_f32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f32x8_cbrt_
		} else if (S >= 8 && _simd_f32x8_cbrt_enable()) {
			typedef _simd_f32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x8_cbrt_(_simd_f32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f32x4_cbrt_
		} else if (S >= 4 && _simd_f32x4_cbrt_enable()) {
			typedef _simd_f32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x4_cbrt_(_simd_f32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_f32x2_cbrt_
		} else if (S >= 2 && _simd_f32x2_cbrt_enable()) {
			typedef _simd_f32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_f32x2_cbrt_(_simd_f32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_f32x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 1, OP_CBRT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_f32x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_f32x1, 0, OP_CBRT> {
	typedef _simd_f32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S,OP_SUM> {
	typedef _simd_s64x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_add_
		} else if (S >= 64 && _simd_s64x64_add_enable()) {
			typedef _simd_s64x64 simd_t;
			simd_t tmp = _simd_s64x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x64_add_(tmp, _simd_s64x64_load_(o)); 
				o += 64;
			}
			return _simd_s64x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s64x32_add_
		} else if (S >= 32 && _simd_s64x32_add_enable()) {
			typedef _simd_s64x32 simd_t;
			simd_t tmp = _simd_s64x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x32_add_(tmp, _simd_s64x32_load_(o)); 
				o += 32;
			}
			return _simd_s64x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s64x16_add_
		} else if (S >= 16 && _simd_s64x16_add_enable()) {
			typedef _simd_s64x16 simd_t;
			simd_t tmp = _simd_s64x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x16_add_(tmp, _simd_s64x16_load_(o)); 
				o += 16;
			}
			return _simd_s64x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s64x8_add_
		} else if (S >= 8 && _simd_s64x8_add_enable()) {
			typedef _simd_s64x8 simd_t;
			simd_t tmp = _simd_s64x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x8_add_(tmp, _simd_s64x8_load_(o)); 
				o += 8;
			}
			return _simd_s64x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s64x4_add_
		} else if (S >= 4 && _simd_s64x4_add_enable()) {
			typedef _simd_s64x4 simd_t;
			simd_t tmp = _simd_s64x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x4_add_(tmp, _simd_s64x4_load_(o)); 
				o += 4;
			}
			return _simd_s64x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s64x2_add_
		} else if (S >= 2 && _simd_s64x2_add_enable()) {
			typedef _simd_s64x2 simd_t;
			simd_t tmp = _simd_s64x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s64x2_add_(tmp, _simd_s64x2_load_(o)); 
				o += 2;
			}
			return _simd_s64x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1,OP_SUM> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0,OP_SUM> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FILL0> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fill_zero_
		} else if (S >= 64 && _simd_s64x64_fill_zero_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s64x32_fill_zero_
		} else if (S >= 32 && _simd_s64x32_fill_zero_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s64x16_fill_zero_
		} else if (S >= 16 && _simd_s64x16_fill_zero_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s64x8_fill_zero_
		} else if (S >= 8 && _simd_s64x8_fill_zero_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s64x4_fill_zero_
		} else if (S >= 4 && _simd_s64x4_fill_zero_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s64x2_fill_zero_
		} else if (S >= 2 && _simd_s64x2_fill_zero_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FILLU> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FILLS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fill_scalar_
		} else if (S >= 64 && _simd_s64x64_fill_scalar_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s64x32_fill_scalar_
		} else if (S >= 32 && _simd_s64x32_fill_scalar_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s64x16_fill_scalar_
		} else if (S >= 16 && _simd_s64x16_fill_scalar_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s64x8_fill_scalar_
		} else if (S >= 8 && _simd_s64x8_fill_scalar_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s64x4_fill_scalar_
		} else if (S >= 4 && _simd_s64x4_fill_scalar_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s64x2_fill_scalar_
		} else if (S >= 2 && _simd_s64x2_fill_scalar_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FMA> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fma_
		} else if (S >= 64 && _simd_s64x64_fma_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_fma_(_simd_s64x64_load_(x),_simd_s64x64_load_(y),_simd_s64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x32_fma_
		} else if (S >= 32 && _simd_s64x32_fma_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_fma_(_simd_s64x32_load_(x),_simd_s64x32_load_(y),_simd_s64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x16_fma_
		} else if (S >= 16 && _simd_s64x16_fma_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_fma_(_simd_s64x16_load_(x),_simd_s64x16_load_(y),_simd_s64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x8_fma_
		} else if (S >= 8 && _simd_s64x8_fma_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_fma_(_simd_s64x8_load_(x),_simd_s64x8_load_(y),_simd_s64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x4_fma_
		} else if (S >= 4 && _simd_s64x4_fma_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_fma_(_simd_s64x4_load_(x),_simd_s64x4_load_(y),_simd_s64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x2_fma_
		} else if (S >= 2 && _simd_s64x2_fma_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_fma_(_simd_s64x2_load_(x),_simd_s64x2_load_(y),_simd_s64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_FMA> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s64x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_FMA> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FMS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_fms_
		} else if (S >= 64 && _simd_s64x64_fms_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_fms_(_simd_s64x64_load_(x),_simd_s64x64_load_(y),_simd_s64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x32_fms_
		} else if (S >= 32 && _simd_s64x32_fms_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_fms_(_simd_s64x32_load_(x),_simd_s64x32_load_(y),_simd_s64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x16_fms_
		} else if (S >= 16 && _simd_s64x16_fms_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_fms_(_simd_s64x16_load_(x),_simd_s64x16_load_(y),_simd_s64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x8_fms_
		} else if (S >= 8 && _simd_s64x8_fms_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_fms_(_simd_s64x8_load_(x),_simd_s64x8_load_(y),_simd_s64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x4_fms_
		} else if (S >= 4 && _simd_s64x4_fms_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_fms_(_simd_s64x4_load_(x),_simd_s64x4_load_(y),_simd_s64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s64x2_fms_
		} else if (S >= 2 && _simd_s64x2_fms_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_fms_(_simd_s64x2_load_(x),_simd_s64x2_load_(y),_simd_s64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_FMS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s64x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_FMS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ADD> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_add_
		} else if (S >= 64 && _simd_s64x64_add_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_add_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_add_
		} else if (S >= 32 && _simd_s64x32_add_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_add_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_add_
		} else if (S >= 16 && _simd_s64x16_add_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_add_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_add_
		} else if (S >= 8 && _simd_s64x8_add_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_add_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_add_
		} else if (S >= 4 && _simd_s64x4_add_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_add_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_add_
		} else if (S >= 2 && _simd_s64x2_add_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_add_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ADD> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ADD> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SUB> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sub_
		} else if (S >= 64 && _simd_s64x64_sub_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_sub_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_sub_
		} else if (S >= 32 && _simd_s64x32_sub_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_sub_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_sub_
		} else if (S >= 16 && _simd_s64x16_sub_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_sub_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_sub_
		} else if (S >= 8 && _simd_s64x8_sub_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_sub_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_sub_
		} else if (S >= 4 && _simd_s64x4_sub_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_sub_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_sub_
		} else if (S >= 2 && _simd_s64x2_sub_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_sub_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_SUB> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_SUB> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MUL> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_mul_
		} else if (S >= 64 && _simd_s64x64_mul_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_mul_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_mul_
		} else if (S >= 32 && _simd_s64x32_mul_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_mul_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_mul_
		} else if (S >= 16 && _simd_s64x16_mul_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_mul_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_mul_
		} else if (S >= 8 && _simd_s64x8_mul_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_mul_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_mul_
		} else if (S >= 4 && _simd_s64x4_mul_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_mul_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_mul_
		} else if (S >= 2 && _simd_s64x2_mul_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_mul_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_MUL> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_MUL> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_DIV> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_div_
		} else if (S >= 64 && _simd_s64x64_div_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_div_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_div_
		} else if (S >= 32 && _simd_s64x32_div_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_div_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_div_
		} else if (S >= 16 && _simd_s64x16_div_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_div_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_div_
		} else if (S >= 8 && _simd_s64x8_div_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_div_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_div_
		} else if (S >= 4 && _simd_s64x4_div_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_div_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_div_
		} else if (S >= 2 && _simd_s64x2_div_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_div_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_DIV> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_DIV> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_min_
		} else if (S >= 64 && _simd_s64x64_min_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_min_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_min_
		} else if (S >= 32 && _simd_s64x32_min_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_min_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_min_
		} else if (S >= 16 && _simd_s64x16_min_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_min_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_min_
		} else if (S >= 8 && _simd_s64x8_min_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_min_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_min_
		} else if (S >= 4 && _simd_s64x4_min_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_min_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_min_
		} else if (S >= 2 && _simd_s64x2_min_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_min_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_MIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_MIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_MAX> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_max_
		} else if (S >= 64 && _simd_s64x64_max_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_max_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_max_
		} else if (S >= 32 && _simd_s64x32_max_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_max_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_max_
		} else if (S >= 16 && _simd_s64x16_max_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_max_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_max_
		} else if (S >= 8 && _simd_s64x8_max_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_max_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_max_
		} else if (S >= 4 && _simd_s64x4_max_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_max_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_max_
		} else if (S >= 2 && _simd_s64x2_max_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_max_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_MAX> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_MAX> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPEQ> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpeq_
		} else if (S >= 64 && _simd_s64x64_cmpeq_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmpeq_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmpeq_
		} else if (S >= 32 && _simd_s64x32_cmpeq_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmpeq_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmpeq_
		} else if (S >= 16 && _simd_s64x16_cmpeq_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmpeq_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmpeq_
		} else if (S >= 8 && _simd_s64x8_cmpeq_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmpeq_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmpeq_
		} else if (S >= 4 && _simd_s64x4_cmpeq_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmpeq_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmpeq_
		} else if (S >= 2 && _simd_s64x2_cmpeq_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmpeq_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPEQ> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPEQ> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPNE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpne_
		} else if (S >= 64 && _simd_s64x64_cmpne_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmpne_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmpne_
		} else if (S >= 32 && _simd_s64x32_cmpne_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmpne_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmpne_
		} else if (S >= 16 && _simd_s64x16_cmpne_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmpne_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmpne_
		} else if (S >= 8 && _simd_s64x8_cmpne_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmpne_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmpne_
		} else if (S >= 4 && _simd_s64x4_cmpne_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmpne_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmpne_
		} else if (S >= 2 && _simd_s64x2_cmpne_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmpne_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPNE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPNE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPLT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmplt_
		} else if (S >= 64 && _simd_s64x64_cmplt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmplt_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmplt_
		} else if (S >= 32 && _simd_s64x32_cmplt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmplt_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmplt_
		} else if (S >= 16 && _simd_s64x16_cmplt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmplt_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmplt_
		} else if (S >= 8 && _simd_s64x8_cmplt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmplt_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmplt_
		} else if (S >= 4 && _simd_s64x4_cmplt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmplt_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmplt_
		} else if (S >= 2 && _simd_s64x2_cmplt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmplt_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPLT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPLT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPGT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpgt_
		} else if (S >= 64 && _simd_s64x64_cmpgt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmpgt_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmpgt_
		} else if (S >= 32 && _simd_s64x32_cmpgt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmpgt_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmpgt_
		} else if (S >= 16 && _simd_s64x16_cmpgt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmpgt_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmpgt_
		} else if (S >= 8 && _simd_s64x8_cmpgt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmpgt_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmpgt_
		} else if (S >= 4 && _simd_s64x4_cmpgt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmpgt_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmpgt_
		} else if (S >= 2 && _simd_s64x2_cmpgt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmpgt_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPGT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPGT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPLE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmple_
		} else if (S >= 64 && _simd_s64x64_cmple_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmple_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmple_
		} else if (S >= 32 && _simd_s64x32_cmple_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmple_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmple_
		} else if (S >= 16 && _simd_s64x16_cmple_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmple_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmple_
		} else if (S >= 8 && _simd_s64x8_cmple_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmple_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmple_
		} else if (S >= 4 && _simd_s64x4_cmple_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmple_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmple_
		} else if (S >= 2 && _simd_s64x2_cmple_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmple_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPLE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPLE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CMPGE> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cmpge_
		} else if (S >= 64 && _simd_s64x64_cmpge_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cmpge_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_cmpge_
		} else if (S >= 32 && _simd_s64x32_cmpge_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cmpge_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_cmpge_
		} else if (S >= 16 && _simd_s64x16_cmpge_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cmpge_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_cmpge_
		} else if (S >= 8 && _simd_s64x8_cmpge_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cmpge_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_cmpge_
		} else if (S >= 4 && _simd_s64x4_cmpge_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cmpge_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_cmpge_
		} else if (S >= 2 && _simd_s64x2_cmpge_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cmpge_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CMPGE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CMPGE> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_AND> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_and_
		} else if (S >= 64 && _simd_s64x64_and_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_and_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_and_
		} else if (S >= 32 && _simd_s64x32_and_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_and_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_and_
		} else if (S >= 16 && _simd_s64x16_and_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_and_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_and_
		} else if (S >= 8 && _simd_s64x8_and_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_and_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_and_
		} else if (S >= 4 && _simd_s64x4_and_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_and_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_and_
		} else if (S >= 2 && _simd_s64x2_and_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_and_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_AND> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_AND> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_OR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_or_
		} else if (S >= 64 && _simd_s64x64_or_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_or_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_or_
		} else if (S >= 32 && _simd_s64x32_or_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_or_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_or_
		} else if (S >= 16 && _simd_s64x16_or_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_or_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_or_
		} else if (S >= 8 && _simd_s64x8_or_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_or_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_or_
		} else if (S >= 4 && _simd_s64x4_or_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_or_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_or_
		} else if (S >= 2 && _simd_s64x2_or_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_or_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_OR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_OR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_XOR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_xor_
		} else if (S >= 64 && _simd_s64x64_xor_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_xor_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_xor_
		} else if (S >= 32 && _simd_s64x32_xor_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_xor_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_xor_
		} else if (S >= 16 && _simd_s64x16_xor_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_xor_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_xor_
		} else if (S >= 8 && _simd_s64x8_xor_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_xor_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_xor_
		} else if (S >= 4 && _simd_s64x4_xor_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_xor_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_xor_
		} else if (S >= 2 && _simd_s64x2_xor_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_xor_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_XOR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_XOR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_lshift_
		} else if (S >= 64 && _simd_s64x64_lshift_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_lshift_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_lshift_
		} else if (S >= 32 && _simd_s64x32_lshift_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_lshift_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_lshift_
		} else if (S >= 16 && _simd_s64x16_lshift_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_lshift_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_lshift_
		} else if (S >= 8 && _simd_s64x8_lshift_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_lshift_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_lshift_
		} else if (S >= 4 && _simd_s64x4_lshift_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_lshift_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_lshift_
		} else if (S >= 2 && _simd_s64x2_lshift_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_lshift_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_LSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_LSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_RSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_rshift_
		} else if (S >= 64 && _simd_s64x64_rshift_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_rshift_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_rshift_
		} else if (S >= 32 && _simd_s64x32_rshift_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_rshift_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_rshift_
		} else if (S >= 16 && _simd_s64x16_rshift_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_rshift_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_rshift_
		} else if (S >= 8 && _simd_s64x8_rshift_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_rshift_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_rshift_
		} else if (S >= 4 && _simd_s64x4_rshift_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_rshift_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_rshift_
		} else if (S >= 2 && _simd_s64x2_rshift_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_rshift_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_RSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_RSHIFT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ATAN2> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_atan2_
		} else if (S >= 64 && _simd_s64x64_atan2_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_atan2_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_atan2_
		} else if (S >= 32 && _simd_s64x32_atan2_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_atan2_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_atan2_
		} else if (S >= 16 && _simd_s64x16_atan2_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_atan2_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_atan2_
		} else if (S >= 8 && _simd_s64x8_atan2_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_atan2_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_atan2_
		} else if (S >= 4 && _simd_s64x4_atan2_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_atan2_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_atan2_
		} else if (S >= 2 && _simd_s64x2_atan2_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_atan2_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ATAN2> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ATAN2> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_POW> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_pow_
		} else if (S >= 64 && _simd_s64x64_pow_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_pow_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_pow_
		} else if (S >= 32 && _simd_s64x32_pow_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_pow_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_pow_
		} else if (S >= 16 && _simd_s64x16_pow_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_pow_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_pow_
		} else if (S >= 8 && _simd_s64x8_pow_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_pow_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_pow_
		} else if (S >= 4 && _simd_s64x4_pow_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_pow_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_pow_
		} else if (S >= 2 && _simd_s64x2_pow_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_pow_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_POW> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_POW> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_HYPOT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_hypot_
		} else if (S >= 64 && _simd_s64x64_hypot_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_hypot_(_simd_s64x64_load_(x),_simd_s64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s64x32_hypot_
		} else if (S >= 32 && _simd_s64x32_hypot_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_hypot_(_simd_s64x32_load_(x),_simd_s64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s64x16_hypot_
		} else if (S >= 16 && _simd_s64x16_hypot_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_hypot_(_simd_s64x16_load_(x),_simd_s64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s64x8_hypot_
		} else if (S >= 8 && _simd_s64x8_hypot_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_hypot_(_simd_s64x8_load_(x),_simd_s64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s64x4_hypot_
		} else if (S >= 4 && _simd_s64x4_hypot_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_hypot_(_simd_s64x4_load_(x),_simd_s64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s64x2_hypot_
		} else if (S >= 2 && _simd_s64x2_hypot_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_hypot_(_simd_s64x2_load_(x),_simd_s64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_HYPOT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s64x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_HYPOT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_NOT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_not_
		} else if (S >= 64 && _simd_s64x64_not_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_not_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s64x32_not_
		} else if (S >= 32 && _simd_s64x32_not_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_not_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s64x16_not_
		} else if (S >= 16 && _simd_s64x16_not_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_not_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s64x8_not_
		} else if (S >= 8 && _simd_s64x8_not_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_not_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s64x4_not_
		} else if (S >= 4 && _simd_s64x4_not_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_not_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s64x2_not_
		} else if (S >= 2 && _simd_s64x2_not_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_not_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_NOT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_NOT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ABS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_abs_
		} else if (S >= 64 && _simd_s64x64_abs_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_abs_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s64x32_abs_
		} else if (S >= 32 && _simd_s64x32_abs_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_abs_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s64x16_abs_
		} else if (S >= 16 && _simd_s64x16_abs_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_abs_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s64x8_abs_
		} else if (S >= 8 && _simd_s64x8_abs_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_abs_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s64x4_abs_
		} else if (S >= 4 && _simd_s64x4_abs_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_abs_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s64x2_abs_
		} else if (S >= 2 && _simd_s64x2_abs_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_abs_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ABS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ABS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_EXP> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_exp_
		} else if (S >= 64 && _simd_s64x64_exp_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_exp_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s64x32_exp_
		} else if (S >= 32 && _simd_s64x32_exp_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_exp_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s64x16_exp_
		} else if (S >= 16 && _simd_s64x16_exp_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_exp_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s64x8_exp_
		} else if (S >= 8 && _simd_s64x8_exp_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_exp_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s64x4_exp_
		} else if (S >= 4 && _simd_s64x4_exp_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_exp_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s64x2_exp_
		} else if (S >= 2 && _simd_s64x2_exp_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_exp_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_EXP> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_EXP> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log_
		} else if (S >= 64 && _simd_s64x64_log_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_log_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s64x32_log_
		} else if (S >= 32 && _simd_s64x32_log_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_log_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s64x16_log_
		} else if (S >= 16 && _simd_s64x16_log_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_log_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s64x8_log_
		} else if (S >= 8 && _simd_s64x8_log_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_log_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s64x4_log_
		} else if (S >= 4 && _simd_s64x4_log_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_log_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s64x2_log_
		} else if (S >= 2 && _simd_s64x2_log_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_log_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_LOG> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_LOG> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG2> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log2_
		} else if (S >= 64 && _simd_s64x64_log2_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_log2_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s64x32_log2_
		} else if (S >= 32 && _simd_s64x32_log2_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_log2_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s64x16_log2_
		} else if (S >= 16 && _simd_s64x16_log2_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_log2_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s64x8_log2_
		} else if (S >= 8 && _simd_s64x8_log2_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_log2_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s64x4_log2_
		} else if (S >= 4 && _simd_s64x4_log2_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_log2_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s64x2_log2_
		} else if (S >= 2 && _simd_s64x2_log2_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_log2_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_LOG2> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_LOG2> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_LOG10> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_log10_
		} else if (S >= 64 && _simd_s64x64_log10_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_log10_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s64x32_log10_
		} else if (S >= 32 && _simd_s64x32_log10_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_log10_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s64x16_log10_
		} else if (S >= 16 && _simd_s64x16_log10_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_log10_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s64x8_log10_
		} else if (S >= 8 && _simd_s64x8_log10_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_log10_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s64x4_log10_
		} else if (S >= 4 && _simd_s64x4_log10_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_log10_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s64x2_log10_
		} else if (S >= 2 && _simd_s64x2_log10_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_log10_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_LOG10> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_LOG10> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CEIL> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_ceil_
		} else if (S >= 64 && _simd_s64x64_ceil_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_ceil_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s64x32_ceil_
		} else if (S >= 32 && _simd_s64x32_ceil_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_ceil_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s64x16_ceil_
		} else if (S >= 16 && _simd_s64x16_ceil_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_ceil_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s64x8_ceil_
		} else if (S >= 8 && _simd_s64x8_ceil_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_ceil_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s64x4_ceil_
		} else if (S >= 4 && _simd_s64x4_ceil_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_ceil_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s64x2_ceil_
		} else if (S >= 2 && _simd_s64x2_ceil_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_ceil_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CEIL> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CEIL> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_FLOOR> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_floor_
		} else if (S >= 64 && _simd_s64x64_floor_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_floor_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s64x32_floor_
		} else if (S >= 32 && _simd_s64x32_floor_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_floor_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s64x16_floor_
		} else if (S >= 16 && _simd_s64x16_floor_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_floor_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s64x8_floor_
		} else if (S >= 8 && _simd_s64x8_floor_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_floor_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s64x4_floor_
		} else if (S >= 4 && _simd_s64x4_floor_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_floor_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s64x2_floor_
		} else if (S >= 2 && _simd_s64x2_floor_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_floor_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_FLOOR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_FLOOR> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ROUND> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_round_
		} else if (S >= 64 && _simd_s64x64_round_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_round_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s64x32_round_
		} else if (S >= 32 && _simd_s64x32_round_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_round_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s64x16_round_
		} else if (S >= 16 && _simd_s64x16_round_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_round_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s64x8_round_
		} else if (S >= 8 && _simd_s64x8_round_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_round_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s64x4_round_
		} else if (S >= 4 && _simd_s64x4_round_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_round_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s64x2_round_
		} else if (S >= 2 && _simd_s64x2_round_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_round_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ROUND> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ROUND> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sin_
		} else if (S >= 64 && _simd_s64x64_sin_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_sin_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s64x32_sin_
		} else if (S >= 32 && _simd_s64x32_sin_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_sin_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s64x16_sin_
		} else if (S >= 16 && _simd_s64x16_sin_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_sin_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s64x8_sin_
		} else if (S >= 8 && _simd_s64x8_sin_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_sin_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s64x4_sin_
		} else if (S >= 4 && _simd_s64x4_sin_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_sin_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s64x2_sin_
		} else if (S >= 2 && _simd_s64x2_sin_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_sin_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_SIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_SIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_COS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cos_
		} else if (S >= 64 && _simd_s64x64_cos_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cos_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s64x32_cos_
		} else if (S >= 32 && _simd_s64x32_cos_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cos_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s64x16_cos_
		} else if (S >= 16 && _simd_s64x16_cos_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cos_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s64x8_cos_
		} else if (S >= 8 && _simd_s64x8_cos_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cos_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s64x4_cos_
		} else if (S >= 4 && _simd_s64x4_cos_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cos_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s64x2_cos_
		} else if (S >= 2 && _simd_s64x2_cos_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cos_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_COS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_COS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_TAN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_tan_
		} else if (S >= 64 && _simd_s64x64_tan_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_tan_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s64x32_tan_
		} else if (S >= 32 && _simd_s64x32_tan_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_tan_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s64x16_tan_
		} else if (S >= 16 && _simd_s64x16_tan_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_tan_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s64x8_tan_
		} else if (S >= 8 && _simd_s64x8_tan_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_tan_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s64x4_tan_
		} else if (S >= 4 && _simd_s64x4_tan_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_tan_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s64x2_tan_
		} else if (S >= 2 && _simd_s64x2_tan_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_tan_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_TAN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_TAN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ASIN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_asin_
		} else if (S >= 64 && _simd_s64x64_asin_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_asin_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s64x32_asin_
		} else if (S >= 32 && _simd_s64x32_asin_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_asin_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s64x16_asin_
		} else if (S >= 16 && _simd_s64x16_asin_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_asin_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s64x8_asin_
		} else if (S >= 8 && _simd_s64x8_asin_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_asin_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s64x4_asin_
		} else if (S >= 4 && _simd_s64x4_asin_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_asin_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s64x2_asin_
		} else if (S >= 2 && _simd_s64x2_asin_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_asin_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ASIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ASIN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ACOS> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_acos_
		} else if (S >= 64 && _simd_s64x64_acos_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_acos_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s64x32_acos_
		} else if (S >= 32 && _simd_s64x32_acos_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_acos_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s64x16_acos_
		} else if (S >= 16 && _simd_s64x16_acos_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_acos_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s64x8_acos_
		} else if (S >= 8 && _simd_s64x8_acos_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_acos_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s64x4_acos_
		} else if (S >= 4 && _simd_s64x4_acos_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_acos_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s64x2_acos_
		} else if (S >= 2 && _simd_s64x2_acos_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_acos_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ACOS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ACOS> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_ATAN> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_atan_
		} else if (S >= 64 && _simd_s64x64_atan_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_atan_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s64x32_atan_
		} else if (S >= 32 && _simd_s64x32_atan_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_atan_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s64x16_atan_
		} else if (S >= 16 && _simd_s64x16_atan_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_atan_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s64x8_atan_
		} else if (S >= 8 && _simd_s64x8_atan_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_atan_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s64x4_atan_
		} else if (S >= 4 && _simd_s64x4_atan_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_atan_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s64x2_atan_
		} else if (S >= 2 && _simd_s64x2_atan_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_atan_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_ATAN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_ATAN> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SINH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sinh_
		} else if (S >= 64 && _simd_s64x64_sinh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_sinh_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s64x32_sinh_
		} else if (S >= 32 && _simd_s64x32_sinh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_sinh_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s64x16_sinh_
		} else if (S >= 16 && _simd_s64x16_sinh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_sinh_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s64x8_sinh_
		} else if (S >= 8 && _simd_s64x8_sinh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_sinh_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s64x4_sinh_
		} else if (S >= 4 && _simd_s64x4_sinh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_sinh_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s64x2_sinh_
		} else if (S >= 2 && _simd_s64x2_sinh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_sinh_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_SINH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_SINH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_COSH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cosh_
		} else if (S >= 64 && _simd_s64x64_cosh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cosh_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s64x32_cosh_
		} else if (S >= 32 && _simd_s64x32_cosh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cosh_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s64x16_cosh_
		} else if (S >= 16 && _simd_s64x16_cosh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cosh_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s64x8_cosh_
		} else if (S >= 8 && _simd_s64x8_cosh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cosh_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s64x4_cosh_
		} else if (S >= 4 && _simd_s64x4_cosh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cosh_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s64x2_cosh_
		} else if (S >= 2 && _simd_s64x2_cosh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cosh_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_COSH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_COSH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_TANH> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_tanh_
		} else if (S >= 64 && _simd_s64x64_tanh_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_tanh_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s64x32_tanh_
		} else if (S >= 32 && _simd_s64x32_tanh_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_tanh_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s64x16_tanh_
		} else if (S >= 16 && _simd_s64x16_tanh_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_tanh_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s64x8_tanh_
		} else if (S >= 8 && _simd_s64x8_tanh_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_tanh_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s64x4_tanh_
		} else if (S >= 4 && _simd_s64x4_tanh_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_tanh_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s64x2_tanh_
		} else if (S >= 2 && _simd_s64x2_tanh_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_tanh_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_TANH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_TANH> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_SQRT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_sqrt_
		} else if (S >= 64 && _simd_s64x64_sqrt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_sqrt_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s64x32_sqrt_
		} else if (S >= 32 && _simd_s64x32_sqrt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_sqrt_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s64x16_sqrt_
		} else if (S >= 16 && _simd_s64x16_sqrt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_sqrt_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s64x8_sqrt_
		} else if (S >= 8 && _simd_s64x8_sqrt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_sqrt_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s64x4_sqrt_
		} else if (S >= 4 && _simd_s64x4_sqrt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_sqrt_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s64x2_sqrt_
		} else if (S >= 2 && _simd_s64x2_sqrt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_sqrt_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_SQRT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_SQRT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s64x1, S, OP_CBRT> {
	typedef _simd_s64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s64x64_cbrt_
		} else if (S >= 64 && _simd_s64x64_cbrt_enable()) {
			typedef _simd_s64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x64_cbrt_(_simd_s64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s64x32_cbrt_
		} else if (S >= 32 && _simd_s64x32_cbrt_enable()) {
			typedef _simd_s64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x32_cbrt_(_simd_s64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s64x16_cbrt_
		} else if (S >= 16 && _simd_s64x16_cbrt_enable()) {
			typedef _simd_s64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x16_cbrt_(_simd_s64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s64x8_cbrt_
		} else if (S >= 8 && _simd_s64x8_cbrt_enable()) {
			typedef _simd_s64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x8_cbrt_(_simd_s64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s64x4_cbrt_
		} else if (S >= 4 && _simd_s64x4_cbrt_enable()) {
			typedef _simd_s64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x4_cbrt_(_simd_s64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s64x2_cbrt_
		} else if (S >= 2 && _simd_s64x2_cbrt_enable()) {
			typedef _simd_s64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s64x2_cbrt_(_simd_s64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s64x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 1, OP_CBRT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s64x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s64x1, 0, OP_CBRT> {
	typedef _simd_s64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S,OP_SUM> {
	typedef _simd_u64x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_add_
		} else if (S >= 64 && _simd_u64x64_add_enable()) {
			typedef _simd_u64x64 simd_t;
			simd_t tmp = _simd_u64x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x64_add_(tmp, _simd_u64x64_load_(o)); 
				o += 64;
			}
			return _simd_u64x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u64x32_add_
		} else if (S >= 32 && _simd_u64x32_add_enable()) {
			typedef _simd_u64x32 simd_t;
			simd_t tmp = _simd_u64x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x32_add_(tmp, _simd_u64x32_load_(o)); 
				o += 32;
			}
			return _simd_u64x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u64x16_add_
		} else if (S >= 16 && _simd_u64x16_add_enable()) {
			typedef _simd_u64x16 simd_t;
			simd_t tmp = _simd_u64x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x16_add_(tmp, _simd_u64x16_load_(o)); 
				o += 16;
			}
			return _simd_u64x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u64x8_add_
		} else if (S >= 8 && _simd_u64x8_add_enable()) {
			typedef _simd_u64x8 simd_t;
			simd_t tmp = _simd_u64x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x8_add_(tmp, _simd_u64x8_load_(o)); 
				o += 8;
			}
			return _simd_u64x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u64x4_add_
		} else if (S >= 4 && _simd_u64x4_add_enable()) {
			typedef _simd_u64x4 simd_t;
			simd_t tmp = _simd_u64x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x4_add_(tmp, _simd_u64x4_load_(o)); 
				o += 4;
			}
			return _simd_u64x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u64x2_add_
		} else if (S >= 2 && _simd_u64x2_add_enable()) {
			typedef _simd_u64x2 simd_t;
			simd_t tmp = _simd_u64x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u64x2_add_(tmp, _simd_u64x2_load_(o)); 
				o += 2;
			}
			return _simd_u64x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1,OP_SUM> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0,OP_SUM> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FILL0> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fill_zero_
		} else if (S >= 64 && _simd_u64x64_fill_zero_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u64x32_fill_zero_
		} else if (S >= 32 && _simd_u64x32_fill_zero_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u64x16_fill_zero_
		} else if (S >= 16 && _simd_u64x16_fill_zero_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u64x8_fill_zero_
		} else if (S >= 8 && _simd_u64x8_fill_zero_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u64x4_fill_zero_
		} else if (S >= 4 && _simd_u64x4_fill_zero_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u64x2_fill_zero_
		} else if (S >= 2 && _simd_u64x2_fill_zero_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FILLU> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FILLS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fill_scalar_
		} else if (S >= 64 && _simd_u64x64_fill_scalar_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u64x32_fill_scalar_
		} else if (S >= 32 && _simd_u64x32_fill_scalar_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u64x16_fill_scalar_
		} else if (S >= 16 && _simd_u64x16_fill_scalar_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u64x8_fill_scalar_
		} else if (S >= 8 && _simd_u64x8_fill_scalar_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u64x4_fill_scalar_
		} else if (S >= 4 && _simd_u64x4_fill_scalar_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u64x2_fill_scalar_
		} else if (S >= 2 && _simd_u64x2_fill_scalar_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FMA> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fma_
		} else if (S >= 64 && _simd_u64x64_fma_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_fma_(_simd_u64x64_load_(x),_simd_u64x64_load_(y),_simd_u64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x32_fma_
		} else if (S >= 32 && _simd_u64x32_fma_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_fma_(_simd_u64x32_load_(x),_simd_u64x32_load_(y),_simd_u64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x16_fma_
		} else if (S >= 16 && _simd_u64x16_fma_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_fma_(_simd_u64x16_load_(x),_simd_u64x16_load_(y),_simd_u64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x8_fma_
		} else if (S >= 8 && _simd_u64x8_fma_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_fma_(_simd_u64x8_load_(x),_simd_u64x8_load_(y),_simd_u64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x4_fma_
		} else if (S >= 4 && _simd_u64x4_fma_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_fma_(_simd_u64x4_load_(x),_simd_u64x4_load_(y),_simd_u64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x2_fma_
		} else if (S >= 2 && _simd_u64x2_fma_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_fma_(_simd_u64x2_load_(x),_simd_u64x2_load_(y),_simd_u64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_FMA> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u64x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_FMA> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FMS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_fms_
		} else if (S >= 64 && _simd_u64x64_fms_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_fms_(_simd_u64x64_load_(x),_simd_u64x64_load_(y),_simd_u64x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x32_fms_
		} else if (S >= 32 && _simd_u64x32_fms_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_fms_(_simd_u64x32_load_(x),_simd_u64x32_load_(y),_simd_u64x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x16_fms_
		} else if (S >= 16 && _simd_u64x16_fms_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_fms_(_simd_u64x16_load_(x),_simd_u64x16_load_(y),_simd_u64x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x8_fms_
		} else if (S >= 8 && _simd_u64x8_fms_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_fms_(_simd_u64x8_load_(x),_simd_u64x8_load_(y),_simd_u64x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x4_fms_
		} else if (S >= 4 && _simd_u64x4_fms_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_fms_(_simd_u64x4_load_(x),_simd_u64x4_load_(y),_simd_u64x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u64x2_fms_
		} else if (S >= 2 && _simd_u64x2_fms_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_fms_(_simd_u64x2_load_(x),_simd_u64x2_load_(y),_simd_u64x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_FMS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u64x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_FMS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ADD> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_add_
		} else if (S >= 64 && _simd_u64x64_add_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_add_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_add_
		} else if (S >= 32 && _simd_u64x32_add_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_add_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_add_
		} else if (S >= 16 && _simd_u64x16_add_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_add_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_add_
		} else if (S >= 8 && _simd_u64x8_add_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_add_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_add_
		} else if (S >= 4 && _simd_u64x4_add_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_add_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_add_
		} else if (S >= 2 && _simd_u64x2_add_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_add_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ADD> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ADD> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SUB> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sub_
		} else if (S >= 64 && _simd_u64x64_sub_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_sub_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_sub_
		} else if (S >= 32 && _simd_u64x32_sub_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_sub_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_sub_
		} else if (S >= 16 && _simd_u64x16_sub_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_sub_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_sub_
		} else if (S >= 8 && _simd_u64x8_sub_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_sub_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_sub_
		} else if (S >= 4 && _simd_u64x4_sub_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_sub_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_sub_
		} else if (S >= 2 && _simd_u64x2_sub_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_sub_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_SUB> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_SUB> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MUL> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_mul_
		} else if (S >= 64 && _simd_u64x64_mul_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_mul_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_mul_
		} else if (S >= 32 && _simd_u64x32_mul_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_mul_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_mul_
		} else if (S >= 16 && _simd_u64x16_mul_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_mul_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_mul_
		} else if (S >= 8 && _simd_u64x8_mul_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_mul_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_mul_
		} else if (S >= 4 && _simd_u64x4_mul_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_mul_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_mul_
		} else if (S >= 2 && _simd_u64x2_mul_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_mul_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_MUL> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_MUL> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_DIV> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_div_
		} else if (S >= 64 && _simd_u64x64_div_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_div_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_div_
		} else if (S >= 32 && _simd_u64x32_div_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_div_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_div_
		} else if (S >= 16 && _simd_u64x16_div_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_div_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_div_
		} else if (S >= 8 && _simd_u64x8_div_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_div_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_div_
		} else if (S >= 4 && _simd_u64x4_div_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_div_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_div_
		} else if (S >= 2 && _simd_u64x2_div_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_div_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_DIV> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_DIV> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_min_
		} else if (S >= 64 && _simd_u64x64_min_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_min_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_min_
		} else if (S >= 32 && _simd_u64x32_min_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_min_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_min_
		} else if (S >= 16 && _simd_u64x16_min_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_min_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_min_
		} else if (S >= 8 && _simd_u64x8_min_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_min_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_min_
		} else if (S >= 4 && _simd_u64x4_min_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_min_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_min_
		} else if (S >= 2 && _simd_u64x2_min_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_min_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_MIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_MIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_MAX> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_max_
		} else if (S >= 64 && _simd_u64x64_max_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_max_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_max_
		} else if (S >= 32 && _simd_u64x32_max_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_max_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_max_
		} else if (S >= 16 && _simd_u64x16_max_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_max_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_max_
		} else if (S >= 8 && _simd_u64x8_max_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_max_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_max_
		} else if (S >= 4 && _simd_u64x4_max_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_max_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_max_
		} else if (S >= 2 && _simd_u64x2_max_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_max_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_MAX> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_MAX> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPEQ> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpeq_
		} else if (S >= 64 && _simd_u64x64_cmpeq_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmpeq_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmpeq_
		} else if (S >= 32 && _simd_u64x32_cmpeq_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmpeq_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmpeq_
		} else if (S >= 16 && _simd_u64x16_cmpeq_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmpeq_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmpeq_
		} else if (S >= 8 && _simd_u64x8_cmpeq_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmpeq_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmpeq_
		} else if (S >= 4 && _simd_u64x4_cmpeq_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmpeq_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmpeq_
		} else if (S >= 2 && _simd_u64x2_cmpeq_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmpeq_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPEQ> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPEQ> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPNE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpne_
		} else if (S >= 64 && _simd_u64x64_cmpne_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmpne_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmpne_
		} else if (S >= 32 && _simd_u64x32_cmpne_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmpne_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmpne_
		} else if (S >= 16 && _simd_u64x16_cmpne_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmpne_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmpne_
		} else if (S >= 8 && _simd_u64x8_cmpne_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmpne_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmpne_
		} else if (S >= 4 && _simd_u64x4_cmpne_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmpne_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmpne_
		} else if (S >= 2 && _simd_u64x2_cmpne_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmpne_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPNE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPNE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPLT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmplt_
		} else if (S >= 64 && _simd_u64x64_cmplt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmplt_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmplt_
		} else if (S >= 32 && _simd_u64x32_cmplt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmplt_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmplt_
		} else if (S >= 16 && _simd_u64x16_cmplt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmplt_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmplt_
		} else if (S >= 8 && _simd_u64x8_cmplt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmplt_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmplt_
		} else if (S >= 4 && _simd_u64x4_cmplt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmplt_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmplt_
		} else if (S >= 2 && _simd_u64x2_cmplt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmplt_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPLT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPLT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPGT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpgt_
		} else if (S >= 64 && _simd_u64x64_cmpgt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmpgt_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmpgt_
		} else if (S >= 32 && _simd_u64x32_cmpgt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmpgt_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmpgt_
		} else if (S >= 16 && _simd_u64x16_cmpgt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmpgt_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmpgt_
		} else if (S >= 8 && _simd_u64x8_cmpgt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmpgt_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmpgt_
		} else if (S >= 4 && _simd_u64x4_cmpgt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmpgt_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmpgt_
		} else if (S >= 2 && _simd_u64x2_cmpgt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmpgt_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPGT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPGT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPLE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmple_
		} else if (S >= 64 && _simd_u64x64_cmple_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmple_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmple_
		} else if (S >= 32 && _simd_u64x32_cmple_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmple_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmple_
		} else if (S >= 16 && _simd_u64x16_cmple_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmple_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmple_
		} else if (S >= 8 && _simd_u64x8_cmple_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmple_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmple_
		} else if (S >= 4 && _simd_u64x4_cmple_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmple_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmple_
		} else if (S >= 2 && _simd_u64x2_cmple_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmple_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPLE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPLE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CMPGE> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cmpge_
		} else if (S >= 64 && _simd_u64x64_cmpge_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cmpge_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_cmpge_
		} else if (S >= 32 && _simd_u64x32_cmpge_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cmpge_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_cmpge_
		} else if (S >= 16 && _simd_u64x16_cmpge_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cmpge_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_cmpge_
		} else if (S >= 8 && _simd_u64x8_cmpge_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cmpge_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_cmpge_
		} else if (S >= 4 && _simd_u64x4_cmpge_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cmpge_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_cmpge_
		} else if (S >= 2 && _simd_u64x2_cmpge_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cmpge_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CMPGE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CMPGE> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_AND> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_and_
		} else if (S >= 64 && _simd_u64x64_and_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_and_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_and_
		} else if (S >= 32 && _simd_u64x32_and_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_and_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_and_
		} else if (S >= 16 && _simd_u64x16_and_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_and_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_and_
		} else if (S >= 8 && _simd_u64x8_and_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_and_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_and_
		} else if (S >= 4 && _simd_u64x4_and_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_and_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_and_
		} else if (S >= 2 && _simd_u64x2_and_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_and_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_AND> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_AND> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_OR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_or_
		} else if (S >= 64 && _simd_u64x64_or_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_or_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_or_
		} else if (S >= 32 && _simd_u64x32_or_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_or_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_or_
		} else if (S >= 16 && _simd_u64x16_or_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_or_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_or_
		} else if (S >= 8 && _simd_u64x8_or_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_or_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_or_
		} else if (S >= 4 && _simd_u64x4_or_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_or_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_or_
		} else if (S >= 2 && _simd_u64x2_or_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_or_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_OR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_OR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_XOR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_xor_
		} else if (S >= 64 && _simd_u64x64_xor_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_xor_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_xor_
		} else if (S >= 32 && _simd_u64x32_xor_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_xor_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_xor_
		} else if (S >= 16 && _simd_u64x16_xor_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_xor_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_xor_
		} else if (S >= 8 && _simd_u64x8_xor_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_xor_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_xor_
		} else if (S >= 4 && _simd_u64x4_xor_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_xor_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_xor_
		} else if (S >= 2 && _simd_u64x2_xor_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_xor_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_XOR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_XOR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_lshift_
		} else if (S >= 64 && _simd_u64x64_lshift_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_lshift_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_lshift_
		} else if (S >= 32 && _simd_u64x32_lshift_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_lshift_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_lshift_
		} else if (S >= 16 && _simd_u64x16_lshift_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_lshift_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_lshift_
		} else if (S >= 8 && _simd_u64x8_lshift_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_lshift_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_lshift_
		} else if (S >= 4 && _simd_u64x4_lshift_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_lshift_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_lshift_
		} else if (S >= 2 && _simd_u64x2_lshift_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_lshift_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_LSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_LSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_RSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_rshift_
		} else if (S >= 64 && _simd_u64x64_rshift_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_rshift_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_rshift_
		} else if (S >= 32 && _simd_u64x32_rshift_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_rshift_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_rshift_
		} else if (S >= 16 && _simd_u64x16_rshift_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_rshift_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_rshift_
		} else if (S >= 8 && _simd_u64x8_rshift_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_rshift_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_rshift_
		} else if (S >= 4 && _simd_u64x4_rshift_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_rshift_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_rshift_
		} else if (S >= 2 && _simd_u64x2_rshift_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_rshift_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_RSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_RSHIFT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ATAN2> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_atan2_
		} else if (S >= 64 && _simd_u64x64_atan2_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_atan2_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_atan2_
		} else if (S >= 32 && _simd_u64x32_atan2_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_atan2_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_atan2_
		} else if (S >= 16 && _simd_u64x16_atan2_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_atan2_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_atan2_
		} else if (S >= 8 && _simd_u64x8_atan2_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_atan2_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_atan2_
		} else if (S >= 4 && _simd_u64x4_atan2_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_atan2_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_atan2_
		} else if (S >= 2 && _simd_u64x2_atan2_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_atan2_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ATAN2> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ATAN2> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_POW> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_pow_
		} else if (S >= 64 && _simd_u64x64_pow_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_pow_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_pow_
		} else if (S >= 32 && _simd_u64x32_pow_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_pow_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_pow_
		} else if (S >= 16 && _simd_u64x16_pow_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_pow_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_pow_
		} else if (S >= 8 && _simd_u64x8_pow_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_pow_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_pow_
		} else if (S >= 4 && _simd_u64x4_pow_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_pow_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_pow_
		} else if (S >= 2 && _simd_u64x2_pow_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_pow_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_POW> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_POW> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_HYPOT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_hypot_
		} else if (S >= 64 && _simd_u64x64_hypot_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_hypot_(_simd_u64x64_load_(x),_simd_u64x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u64x32_hypot_
		} else if (S >= 32 && _simd_u64x32_hypot_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_hypot_(_simd_u64x32_load_(x),_simd_u64x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u64x16_hypot_
		} else if (S >= 16 && _simd_u64x16_hypot_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_hypot_(_simd_u64x16_load_(x),_simd_u64x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u64x8_hypot_
		} else if (S >= 8 && _simd_u64x8_hypot_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_hypot_(_simd_u64x8_load_(x),_simd_u64x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u64x4_hypot_
		} else if (S >= 4 && _simd_u64x4_hypot_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_hypot_(_simd_u64x4_load_(x),_simd_u64x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u64x2_hypot_
		} else if (S >= 2 && _simd_u64x2_hypot_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_hypot_(_simd_u64x2_load_(x),_simd_u64x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_HYPOT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u64x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_HYPOT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_NOT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_not_
		} else if (S >= 64 && _simd_u64x64_not_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_not_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u64x32_not_
		} else if (S >= 32 && _simd_u64x32_not_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_not_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u64x16_not_
		} else if (S >= 16 && _simd_u64x16_not_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_not_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u64x8_not_
		} else if (S >= 8 && _simd_u64x8_not_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_not_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u64x4_not_
		} else if (S >= 4 && _simd_u64x4_not_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_not_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u64x2_not_
		} else if (S >= 2 && _simd_u64x2_not_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_not_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_NOT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_NOT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ABS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_abs_
		} else if (S >= 64 && _simd_u64x64_abs_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_abs_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u64x32_abs_
		} else if (S >= 32 && _simd_u64x32_abs_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_abs_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u64x16_abs_
		} else if (S >= 16 && _simd_u64x16_abs_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_abs_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u64x8_abs_
		} else if (S >= 8 && _simd_u64x8_abs_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_abs_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u64x4_abs_
		} else if (S >= 4 && _simd_u64x4_abs_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_abs_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u64x2_abs_
		} else if (S >= 2 && _simd_u64x2_abs_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_abs_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ABS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ABS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_EXP> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_exp_
		} else if (S >= 64 && _simd_u64x64_exp_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_exp_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u64x32_exp_
		} else if (S >= 32 && _simd_u64x32_exp_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_exp_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u64x16_exp_
		} else if (S >= 16 && _simd_u64x16_exp_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_exp_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u64x8_exp_
		} else if (S >= 8 && _simd_u64x8_exp_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_exp_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u64x4_exp_
		} else if (S >= 4 && _simd_u64x4_exp_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_exp_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u64x2_exp_
		} else if (S >= 2 && _simd_u64x2_exp_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_exp_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_EXP> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_EXP> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log_
		} else if (S >= 64 && _simd_u64x64_log_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_log_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u64x32_log_
		} else if (S >= 32 && _simd_u64x32_log_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_log_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u64x16_log_
		} else if (S >= 16 && _simd_u64x16_log_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_log_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u64x8_log_
		} else if (S >= 8 && _simd_u64x8_log_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_log_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u64x4_log_
		} else if (S >= 4 && _simd_u64x4_log_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_log_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u64x2_log_
		} else if (S >= 2 && _simd_u64x2_log_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_log_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_LOG> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_LOG> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG2> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log2_
		} else if (S >= 64 && _simd_u64x64_log2_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_log2_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u64x32_log2_
		} else if (S >= 32 && _simd_u64x32_log2_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_log2_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u64x16_log2_
		} else if (S >= 16 && _simd_u64x16_log2_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_log2_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u64x8_log2_
		} else if (S >= 8 && _simd_u64x8_log2_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_log2_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u64x4_log2_
		} else if (S >= 4 && _simd_u64x4_log2_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_log2_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u64x2_log2_
		} else if (S >= 2 && _simd_u64x2_log2_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_log2_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_LOG2> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_LOG2> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_LOG10> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_log10_
		} else if (S >= 64 && _simd_u64x64_log10_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_log10_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u64x32_log10_
		} else if (S >= 32 && _simd_u64x32_log10_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_log10_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u64x16_log10_
		} else if (S >= 16 && _simd_u64x16_log10_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_log10_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u64x8_log10_
		} else if (S >= 8 && _simd_u64x8_log10_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_log10_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u64x4_log10_
		} else if (S >= 4 && _simd_u64x4_log10_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_log10_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u64x2_log10_
		} else if (S >= 2 && _simd_u64x2_log10_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_log10_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_LOG10> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_LOG10> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CEIL> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_ceil_
		} else if (S >= 64 && _simd_u64x64_ceil_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_ceil_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u64x32_ceil_
		} else if (S >= 32 && _simd_u64x32_ceil_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_ceil_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u64x16_ceil_
		} else if (S >= 16 && _simd_u64x16_ceil_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_ceil_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u64x8_ceil_
		} else if (S >= 8 && _simd_u64x8_ceil_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_ceil_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u64x4_ceil_
		} else if (S >= 4 && _simd_u64x4_ceil_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_ceil_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u64x2_ceil_
		} else if (S >= 2 && _simd_u64x2_ceil_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_ceil_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CEIL> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CEIL> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_FLOOR> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_floor_
		} else if (S >= 64 && _simd_u64x64_floor_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_floor_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u64x32_floor_
		} else if (S >= 32 && _simd_u64x32_floor_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_floor_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u64x16_floor_
		} else if (S >= 16 && _simd_u64x16_floor_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_floor_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u64x8_floor_
		} else if (S >= 8 && _simd_u64x8_floor_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_floor_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u64x4_floor_
		} else if (S >= 4 && _simd_u64x4_floor_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_floor_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u64x2_floor_
		} else if (S >= 2 && _simd_u64x2_floor_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_floor_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_FLOOR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_FLOOR> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ROUND> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_round_
		} else if (S >= 64 && _simd_u64x64_round_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_round_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u64x32_round_
		} else if (S >= 32 && _simd_u64x32_round_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_round_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u64x16_round_
		} else if (S >= 16 && _simd_u64x16_round_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_round_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u64x8_round_
		} else if (S >= 8 && _simd_u64x8_round_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_round_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u64x4_round_
		} else if (S >= 4 && _simd_u64x4_round_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_round_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u64x2_round_
		} else if (S >= 2 && _simd_u64x2_round_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_round_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ROUND> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ROUND> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sin_
		} else if (S >= 64 && _simd_u64x64_sin_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_sin_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u64x32_sin_
		} else if (S >= 32 && _simd_u64x32_sin_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_sin_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u64x16_sin_
		} else if (S >= 16 && _simd_u64x16_sin_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_sin_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u64x8_sin_
		} else if (S >= 8 && _simd_u64x8_sin_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_sin_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u64x4_sin_
		} else if (S >= 4 && _simd_u64x4_sin_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_sin_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u64x2_sin_
		} else if (S >= 2 && _simd_u64x2_sin_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_sin_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_SIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_SIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_COS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cos_
		} else if (S >= 64 && _simd_u64x64_cos_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cos_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u64x32_cos_
		} else if (S >= 32 && _simd_u64x32_cos_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cos_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u64x16_cos_
		} else if (S >= 16 && _simd_u64x16_cos_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cos_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u64x8_cos_
		} else if (S >= 8 && _simd_u64x8_cos_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cos_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u64x4_cos_
		} else if (S >= 4 && _simd_u64x4_cos_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cos_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u64x2_cos_
		} else if (S >= 2 && _simd_u64x2_cos_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cos_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_COS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_COS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_TAN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_tan_
		} else if (S >= 64 && _simd_u64x64_tan_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_tan_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u64x32_tan_
		} else if (S >= 32 && _simd_u64x32_tan_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_tan_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u64x16_tan_
		} else if (S >= 16 && _simd_u64x16_tan_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_tan_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u64x8_tan_
		} else if (S >= 8 && _simd_u64x8_tan_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_tan_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u64x4_tan_
		} else if (S >= 4 && _simd_u64x4_tan_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_tan_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u64x2_tan_
		} else if (S >= 2 && _simd_u64x2_tan_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_tan_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_TAN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_TAN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ASIN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_asin_
		} else if (S >= 64 && _simd_u64x64_asin_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_asin_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u64x32_asin_
		} else if (S >= 32 && _simd_u64x32_asin_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_asin_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u64x16_asin_
		} else if (S >= 16 && _simd_u64x16_asin_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_asin_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u64x8_asin_
		} else if (S >= 8 && _simd_u64x8_asin_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_asin_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u64x4_asin_
		} else if (S >= 4 && _simd_u64x4_asin_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_asin_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u64x2_asin_
		} else if (S >= 2 && _simd_u64x2_asin_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_asin_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ASIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ASIN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ACOS> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_acos_
		} else if (S >= 64 && _simd_u64x64_acos_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_acos_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u64x32_acos_
		} else if (S >= 32 && _simd_u64x32_acos_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_acos_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u64x16_acos_
		} else if (S >= 16 && _simd_u64x16_acos_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_acos_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u64x8_acos_
		} else if (S >= 8 && _simd_u64x8_acos_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_acos_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u64x4_acos_
		} else if (S >= 4 && _simd_u64x4_acos_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_acos_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u64x2_acos_
		} else if (S >= 2 && _simd_u64x2_acos_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_acos_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ACOS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ACOS> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_ATAN> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_atan_
		} else if (S >= 64 && _simd_u64x64_atan_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_atan_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u64x32_atan_
		} else if (S >= 32 && _simd_u64x32_atan_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_atan_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u64x16_atan_
		} else if (S >= 16 && _simd_u64x16_atan_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_atan_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u64x8_atan_
		} else if (S >= 8 && _simd_u64x8_atan_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_atan_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u64x4_atan_
		} else if (S >= 4 && _simd_u64x4_atan_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_atan_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u64x2_atan_
		} else if (S >= 2 && _simd_u64x2_atan_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_atan_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_ATAN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_ATAN> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SINH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sinh_
		} else if (S >= 64 && _simd_u64x64_sinh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_sinh_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u64x32_sinh_
		} else if (S >= 32 && _simd_u64x32_sinh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_sinh_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u64x16_sinh_
		} else if (S >= 16 && _simd_u64x16_sinh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_sinh_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u64x8_sinh_
		} else if (S >= 8 && _simd_u64x8_sinh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_sinh_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u64x4_sinh_
		} else if (S >= 4 && _simd_u64x4_sinh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_sinh_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u64x2_sinh_
		} else if (S >= 2 && _simd_u64x2_sinh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_sinh_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_SINH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_SINH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_COSH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cosh_
		} else if (S >= 64 && _simd_u64x64_cosh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cosh_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u64x32_cosh_
		} else if (S >= 32 && _simd_u64x32_cosh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cosh_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u64x16_cosh_
		} else if (S >= 16 && _simd_u64x16_cosh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cosh_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u64x8_cosh_
		} else if (S >= 8 && _simd_u64x8_cosh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cosh_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u64x4_cosh_
		} else if (S >= 4 && _simd_u64x4_cosh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cosh_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u64x2_cosh_
		} else if (S >= 2 && _simd_u64x2_cosh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cosh_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_COSH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_COSH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_TANH> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_tanh_
		} else if (S >= 64 && _simd_u64x64_tanh_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_tanh_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u64x32_tanh_
		} else if (S >= 32 && _simd_u64x32_tanh_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_tanh_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u64x16_tanh_
		} else if (S >= 16 && _simd_u64x16_tanh_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_tanh_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u64x8_tanh_
		} else if (S >= 8 && _simd_u64x8_tanh_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_tanh_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u64x4_tanh_
		} else if (S >= 4 && _simd_u64x4_tanh_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_tanh_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u64x2_tanh_
		} else if (S >= 2 && _simd_u64x2_tanh_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_tanh_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_TANH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_TANH> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_SQRT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_sqrt_
		} else if (S >= 64 && _simd_u64x64_sqrt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_sqrt_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u64x32_sqrt_
		} else if (S >= 32 && _simd_u64x32_sqrt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_sqrt_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u64x16_sqrt_
		} else if (S >= 16 && _simd_u64x16_sqrt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_sqrt_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u64x8_sqrt_
		} else if (S >= 8 && _simd_u64x8_sqrt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_sqrt_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u64x4_sqrt_
		} else if (S >= 4 && _simd_u64x4_sqrt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_sqrt_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u64x2_sqrt_
		} else if (S >= 2 && _simd_u64x2_sqrt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_sqrt_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_SQRT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_SQRT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u64x1, S, OP_CBRT> {
	typedef _simd_u64x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u64x64_cbrt_
		} else if (S >= 64 && _simd_u64x64_cbrt_enable()) {
			typedef _simd_u64x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x64_cbrt_(_simd_u64x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u64x32_cbrt_
		} else if (S >= 32 && _simd_u64x32_cbrt_enable()) {
			typedef _simd_u64x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x32_cbrt_(_simd_u64x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u64x16_cbrt_
		} else if (S >= 16 && _simd_u64x16_cbrt_enable()) {
			typedef _simd_u64x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x16_cbrt_(_simd_u64x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u64x8_cbrt_
		} else if (S >= 8 && _simd_u64x8_cbrt_enable()) {
			typedef _simd_u64x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x8_cbrt_(_simd_u64x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u64x4_cbrt_
		} else if (S >= 4 && _simd_u64x4_cbrt_enable()) {
			typedef _simd_u64x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x4_cbrt_(_simd_u64x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u64x2_cbrt_
		} else if (S >= 2 && _simd_u64x2_cbrt_enable()) {
			typedef _simd_u64x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u64x2_cbrt_(_simd_u64x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u64x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 1, OP_CBRT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u64x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u64x1, 0, OP_CBRT> {
	typedef _simd_u64x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S,OP_SUM> {
	typedef _simd_s32x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_add_
		} else if (S >= 64 && _simd_s32x64_add_enable()) {
			typedef _simd_s32x64 simd_t;
			simd_t tmp = _simd_s32x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x64_add_(tmp, _simd_s32x64_load_(o)); 
				o += 64;
			}
			return _simd_s32x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s32x32_add_
		} else if (S >= 32 && _simd_s32x32_add_enable()) {
			typedef _simd_s32x32 simd_t;
			simd_t tmp = _simd_s32x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x32_add_(tmp, _simd_s32x32_load_(o)); 
				o += 32;
			}
			return _simd_s32x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s32x16_add_
		} else if (S >= 16 && _simd_s32x16_add_enable()) {
			typedef _simd_s32x16 simd_t;
			simd_t tmp = _simd_s32x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x16_add_(tmp, _simd_s32x16_load_(o)); 
				o += 16;
			}
			return _simd_s32x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s32x8_add_
		} else if (S >= 8 && _simd_s32x8_add_enable()) {
			typedef _simd_s32x8 simd_t;
			simd_t tmp = _simd_s32x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x8_add_(tmp, _simd_s32x8_load_(o)); 
				o += 8;
			}
			return _simd_s32x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s32x4_add_
		} else if (S >= 4 && _simd_s32x4_add_enable()) {
			typedef _simd_s32x4 simd_t;
			simd_t tmp = _simd_s32x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x4_add_(tmp, _simd_s32x4_load_(o)); 
				o += 4;
			}
			return _simd_s32x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s32x2_add_
		} else if (S >= 2 && _simd_s32x2_add_enable()) {
			typedef _simd_s32x2 simd_t;
			simd_t tmp = _simd_s32x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s32x2_add_(tmp, _simd_s32x2_load_(o)); 
				o += 2;
			}
			return _simd_s32x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1,OP_SUM> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0,OP_SUM> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FILL0> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fill_zero_
		} else if (S >= 64 && _simd_s32x64_fill_zero_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s32x32_fill_zero_
		} else if (S >= 32 && _simd_s32x32_fill_zero_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s32x16_fill_zero_
		} else if (S >= 16 && _simd_s32x16_fill_zero_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s32x8_fill_zero_
		} else if (S >= 8 && _simd_s32x8_fill_zero_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s32x4_fill_zero_
		} else if (S >= 4 && _simd_s32x4_fill_zero_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s32x2_fill_zero_
		} else if (S >= 2 && _simd_s32x2_fill_zero_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FILLU> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FILLS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fill_scalar_
		} else if (S >= 64 && _simd_s32x64_fill_scalar_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s32x32_fill_scalar_
		} else if (S >= 32 && _simd_s32x32_fill_scalar_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s32x16_fill_scalar_
		} else if (S >= 16 && _simd_s32x16_fill_scalar_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s32x8_fill_scalar_
		} else if (S >= 8 && _simd_s32x8_fill_scalar_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s32x4_fill_scalar_
		} else if (S >= 4 && _simd_s32x4_fill_scalar_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s32x2_fill_scalar_
		} else if (S >= 2 && _simd_s32x2_fill_scalar_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FMA> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fma_
		} else if (S >= 64 && _simd_s32x64_fma_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_fma_(_simd_s32x64_load_(x),_simd_s32x64_load_(y),_simd_s32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x32_fma_
		} else if (S >= 32 && _simd_s32x32_fma_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_fma_(_simd_s32x32_load_(x),_simd_s32x32_load_(y),_simd_s32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x16_fma_
		} else if (S >= 16 && _simd_s32x16_fma_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_fma_(_simd_s32x16_load_(x),_simd_s32x16_load_(y),_simd_s32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x8_fma_
		} else if (S >= 8 && _simd_s32x8_fma_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_fma_(_simd_s32x8_load_(x),_simd_s32x8_load_(y),_simd_s32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x4_fma_
		} else if (S >= 4 && _simd_s32x4_fma_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_fma_(_simd_s32x4_load_(x),_simd_s32x4_load_(y),_simd_s32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x2_fma_
		} else if (S >= 2 && _simd_s32x2_fma_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_fma_(_simd_s32x2_load_(x),_simd_s32x2_load_(y),_simd_s32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_FMA> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s32x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_FMA> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FMS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_fms_
		} else if (S >= 64 && _simd_s32x64_fms_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_fms_(_simd_s32x64_load_(x),_simd_s32x64_load_(y),_simd_s32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x32_fms_
		} else if (S >= 32 && _simd_s32x32_fms_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_fms_(_simd_s32x32_load_(x),_simd_s32x32_load_(y),_simd_s32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x16_fms_
		} else if (S >= 16 && _simd_s32x16_fms_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_fms_(_simd_s32x16_load_(x),_simd_s32x16_load_(y),_simd_s32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x8_fms_
		} else if (S >= 8 && _simd_s32x8_fms_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_fms_(_simd_s32x8_load_(x),_simd_s32x8_load_(y),_simd_s32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x4_fms_
		} else if (S >= 4 && _simd_s32x4_fms_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_fms_(_simd_s32x4_load_(x),_simd_s32x4_load_(y),_simd_s32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s32x2_fms_
		} else if (S >= 2 && _simd_s32x2_fms_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_fms_(_simd_s32x2_load_(x),_simd_s32x2_load_(y),_simd_s32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_FMS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s32x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_FMS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ADD> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_add_
		} else if (S >= 64 && _simd_s32x64_add_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_add_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_add_
		} else if (S >= 32 && _simd_s32x32_add_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_add_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_add_
		} else if (S >= 16 && _simd_s32x16_add_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_add_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_add_
		} else if (S >= 8 && _simd_s32x8_add_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_add_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_add_
		} else if (S >= 4 && _simd_s32x4_add_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_add_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_add_
		} else if (S >= 2 && _simd_s32x2_add_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_add_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ADD> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ADD> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SUB> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sub_
		} else if (S >= 64 && _simd_s32x64_sub_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_sub_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_sub_
		} else if (S >= 32 && _simd_s32x32_sub_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_sub_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_sub_
		} else if (S >= 16 && _simd_s32x16_sub_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_sub_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_sub_
		} else if (S >= 8 && _simd_s32x8_sub_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_sub_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_sub_
		} else if (S >= 4 && _simd_s32x4_sub_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_sub_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_sub_
		} else if (S >= 2 && _simd_s32x2_sub_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_sub_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_SUB> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_SUB> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MUL> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_mul_
		} else if (S >= 64 && _simd_s32x64_mul_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_mul_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_mul_
		} else if (S >= 32 && _simd_s32x32_mul_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_mul_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_mul_
		} else if (S >= 16 && _simd_s32x16_mul_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_mul_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_mul_
		} else if (S >= 8 && _simd_s32x8_mul_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_mul_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_mul_
		} else if (S >= 4 && _simd_s32x4_mul_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_mul_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_mul_
		} else if (S >= 2 && _simd_s32x2_mul_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_mul_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_MUL> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_MUL> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_DIV> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_div_
		} else if (S >= 64 && _simd_s32x64_div_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_div_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_div_
		} else if (S >= 32 && _simd_s32x32_div_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_div_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_div_
		} else if (S >= 16 && _simd_s32x16_div_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_div_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_div_
		} else if (S >= 8 && _simd_s32x8_div_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_div_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_div_
		} else if (S >= 4 && _simd_s32x4_div_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_div_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_div_
		} else if (S >= 2 && _simd_s32x2_div_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_div_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_DIV> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_DIV> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_min_
		} else if (S >= 64 && _simd_s32x64_min_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_min_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_min_
		} else if (S >= 32 && _simd_s32x32_min_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_min_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_min_
		} else if (S >= 16 && _simd_s32x16_min_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_min_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_min_
		} else if (S >= 8 && _simd_s32x8_min_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_min_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_min_
		} else if (S >= 4 && _simd_s32x4_min_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_min_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_min_
		} else if (S >= 2 && _simd_s32x2_min_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_min_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_MIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_MIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_MAX> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_max_
		} else if (S >= 64 && _simd_s32x64_max_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_max_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_max_
		} else if (S >= 32 && _simd_s32x32_max_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_max_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_max_
		} else if (S >= 16 && _simd_s32x16_max_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_max_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_max_
		} else if (S >= 8 && _simd_s32x8_max_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_max_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_max_
		} else if (S >= 4 && _simd_s32x4_max_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_max_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_max_
		} else if (S >= 2 && _simd_s32x2_max_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_max_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_MAX> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_MAX> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPEQ> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpeq_
		} else if (S >= 64 && _simd_s32x64_cmpeq_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmpeq_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmpeq_
		} else if (S >= 32 && _simd_s32x32_cmpeq_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmpeq_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmpeq_
		} else if (S >= 16 && _simd_s32x16_cmpeq_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmpeq_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmpeq_
		} else if (S >= 8 && _simd_s32x8_cmpeq_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmpeq_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmpeq_
		} else if (S >= 4 && _simd_s32x4_cmpeq_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmpeq_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmpeq_
		} else if (S >= 2 && _simd_s32x2_cmpeq_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmpeq_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPEQ> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPEQ> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPNE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpne_
		} else if (S >= 64 && _simd_s32x64_cmpne_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmpne_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmpne_
		} else if (S >= 32 && _simd_s32x32_cmpne_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmpne_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmpne_
		} else if (S >= 16 && _simd_s32x16_cmpne_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmpne_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmpne_
		} else if (S >= 8 && _simd_s32x8_cmpne_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmpne_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmpne_
		} else if (S >= 4 && _simd_s32x4_cmpne_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmpne_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmpne_
		} else if (S >= 2 && _simd_s32x2_cmpne_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmpne_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPNE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPNE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPLT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmplt_
		} else if (S >= 64 && _simd_s32x64_cmplt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmplt_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmplt_
		} else if (S >= 32 && _simd_s32x32_cmplt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmplt_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmplt_
		} else if (S >= 16 && _simd_s32x16_cmplt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmplt_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmplt_
		} else if (S >= 8 && _simd_s32x8_cmplt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmplt_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmplt_
		} else if (S >= 4 && _simd_s32x4_cmplt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmplt_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmplt_
		} else if (S >= 2 && _simd_s32x2_cmplt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmplt_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPLT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPLT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPGT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpgt_
		} else if (S >= 64 && _simd_s32x64_cmpgt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmpgt_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmpgt_
		} else if (S >= 32 && _simd_s32x32_cmpgt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmpgt_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmpgt_
		} else if (S >= 16 && _simd_s32x16_cmpgt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmpgt_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmpgt_
		} else if (S >= 8 && _simd_s32x8_cmpgt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmpgt_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmpgt_
		} else if (S >= 4 && _simd_s32x4_cmpgt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmpgt_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmpgt_
		} else if (S >= 2 && _simd_s32x2_cmpgt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmpgt_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPGT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPGT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPLE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmple_
		} else if (S >= 64 && _simd_s32x64_cmple_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmple_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmple_
		} else if (S >= 32 && _simd_s32x32_cmple_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmple_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmple_
		} else if (S >= 16 && _simd_s32x16_cmple_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmple_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmple_
		} else if (S >= 8 && _simd_s32x8_cmple_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmple_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmple_
		} else if (S >= 4 && _simd_s32x4_cmple_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmple_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmple_
		} else if (S >= 2 && _simd_s32x2_cmple_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmple_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPLE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPLE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CMPGE> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cmpge_
		} else if (S >= 64 && _simd_s32x64_cmpge_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cmpge_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_cmpge_
		} else if (S >= 32 && _simd_s32x32_cmpge_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cmpge_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_cmpge_
		} else if (S >= 16 && _simd_s32x16_cmpge_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cmpge_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_cmpge_
		} else if (S >= 8 && _simd_s32x8_cmpge_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cmpge_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_cmpge_
		} else if (S >= 4 && _simd_s32x4_cmpge_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cmpge_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_cmpge_
		} else if (S >= 2 && _simd_s32x2_cmpge_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cmpge_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CMPGE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CMPGE> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_AND> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_and_
		} else if (S >= 64 && _simd_s32x64_and_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_and_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_and_
		} else if (S >= 32 && _simd_s32x32_and_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_and_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_and_
		} else if (S >= 16 && _simd_s32x16_and_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_and_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_and_
		} else if (S >= 8 && _simd_s32x8_and_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_and_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_and_
		} else if (S >= 4 && _simd_s32x4_and_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_and_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_and_
		} else if (S >= 2 && _simd_s32x2_and_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_and_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_AND> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_AND> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_OR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_or_
		} else if (S >= 64 && _simd_s32x64_or_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_or_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_or_
		} else if (S >= 32 && _simd_s32x32_or_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_or_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_or_
		} else if (S >= 16 && _simd_s32x16_or_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_or_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_or_
		} else if (S >= 8 && _simd_s32x8_or_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_or_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_or_
		} else if (S >= 4 && _simd_s32x4_or_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_or_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_or_
		} else if (S >= 2 && _simd_s32x2_or_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_or_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_OR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_OR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_XOR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_xor_
		} else if (S >= 64 && _simd_s32x64_xor_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_xor_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_xor_
		} else if (S >= 32 && _simd_s32x32_xor_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_xor_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_xor_
		} else if (S >= 16 && _simd_s32x16_xor_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_xor_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_xor_
		} else if (S >= 8 && _simd_s32x8_xor_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_xor_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_xor_
		} else if (S >= 4 && _simd_s32x4_xor_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_xor_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_xor_
		} else if (S >= 2 && _simd_s32x2_xor_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_xor_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_XOR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_XOR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_lshift_
		} else if (S >= 64 && _simd_s32x64_lshift_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_lshift_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_lshift_
		} else if (S >= 32 && _simd_s32x32_lshift_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_lshift_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_lshift_
		} else if (S >= 16 && _simd_s32x16_lshift_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_lshift_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_lshift_
		} else if (S >= 8 && _simd_s32x8_lshift_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_lshift_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_lshift_
		} else if (S >= 4 && _simd_s32x4_lshift_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_lshift_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_lshift_
		} else if (S >= 2 && _simd_s32x2_lshift_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_lshift_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_LSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_LSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_RSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_rshift_
		} else if (S >= 64 && _simd_s32x64_rshift_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_rshift_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_rshift_
		} else if (S >= 32 && _simd_s32x32_rshift_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_rshift_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_rshift_
		} else if (S >= 16 && _simd_s32x16_rshift_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_rshift_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_rshift_
		} else if (S >= 8 && _simd_s32x8_rshift_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_rshift_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_rshift_
		} else if (S >= 4 && _simd_s32x4_rshift_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_rshift_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_rshift_
		} else if (S >= 2 && _simd_s32x2_rshift_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_rshift_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_RSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_RSHIFT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ATAN2> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_atan2_
		} else if (S >= 64 && _simd_s32x64_atan2_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_atan2_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_atan2_
		} else if (S >= 32 && _simd_s32x32_atan2_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_atan2_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_atan2_
		} else if (S >= 16 && _simd_s32x16_atan2_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_atan2_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_atan2_
		} else if (S >= 8 && _simd_s32x8_atan2_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_atan2_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_atan2_
		} else if (S >= 4 && _simd_s32x4_atan2_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_atan2_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_atan2_
		} else if (S >= 2 && _simd_s32x2_atan2_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_atan2_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ATAN2> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ATAN2> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_POW> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_pow_
		} else if (S >= 64 && _simd_s32x64_pow_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_pow_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_pow_
		} else if (S >= 32 && _simd_s32x32_pow_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_pow_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_pow_
		} else if (S >= 16 && _simd_s32x16_pow_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_pow_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_pow_
		} else if (S >= 8 && _simd_s32x8_pow_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_pow_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_pow_
		} else if (S >= 4 && _simd_s32x4_pow_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_pow_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_pow_
		} else if (S >= 2 && _simd_s32x2_pow_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_pow_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_POW> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_POW> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_HYPOT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_hypot_
		} else if (S >= 64 && _simd_s32x64_hypot_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_hypot_(_simd_s32x64_load_(x),_simd_s32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s32x32_hypot_
		} else if (S >= 32 && _simd_s32x32_hypot_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_hypot_(_simd_s32x32_load_(x),_simd_s32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s32x16_hypot_
		} else if (S >= 16 && _simd_s32x16_hypot_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_hypot_(_simd_s32x16_load_(x),_simd_s32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s32x8_hypot_
		} else if (S >= 8 && _simd_s32x8_hypot_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_hypot_(_simd_s32x8_load_(x),_simd_s32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s32x4_hypot_
		} else if (S >= 4 && _simd_s32x4_hypot_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_hypot_(_simd_s32x4_load_(x),_simd_s32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s32x2_hypot_
		} else if (S >= 2 && _simd_s32x2_hypot_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_hypot_(_simd_s32x2_load_(x),_simd_s32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_HYPOT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s32x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_HYPOT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_NOT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_not_
		} else if (S >= 64 && _simd_s32x64_not_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_not_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s32x32_not_
		} else if (S >= 32 && _simd_s32x32_not_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_not_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s32x16_not_
		} else if (S >= 16 && _simd_s32x16_not_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_not_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s32x8_not_
		} else if (S >= 8 && _simd_s32x8_not_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_not_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s32x4_not_
		} else if (S >= 4 && _simd_s32x4_not_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_not_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s32x2_not_
		} else if (S >= 2 && _simd_s32x2_not_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_not_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_NOT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_NOT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ABS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_abs_
		} else if (S >= 64 && _simd_s32x64_abs_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_abs_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s32x32_abs_
		} else if (S >= 32 && _simd_s32x32_abs_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_abs_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s32x16_abs_
		} else if (S >= 16 && _simd_s32x16_abs_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_abs_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s32x8_abs_
		} else if (S >= 8 && _simd_s32x8_abs_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_abs_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s32x4_abs_
		} else if (S >= 4 && _simd_s32x4_abs_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_abs_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s32x2_abs_
		} else if (S >= 2 && _simd_s32x2_abs_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_abs_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ABS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ABS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_EXP> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_exp_
		} else if (S >= 64 && _simd_s32x64_exp_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_exp_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s32x32_exp_
		} else if (S >= 32 && _simd_s32x32_exp_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_exp_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s32x16_exp_
		} else if (S >= 16 && _simd_s32x16_exp_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_exp_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s32x8_exp_
		} else if (S >= 8 && _simd_s32x8_exp_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_exp_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s32x4_exp_
		} else if (S >= 4 && _simd_s32x4_exp_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_exp_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s32x2_exp_
		} else if (S >= 2 && _simd_s32x2_exp_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_exp_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_EXP> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_EXP> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log_
		} else if (S >= 64 && _simd_s32x64_log_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_log_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s32x32_log_
		} else if (S >= 32 && _simd_s32x32_log_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_log_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s32x16_log_
		} else if (S >= 16 && _simd_s32x16_log_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_log_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s32x8_log_
		} else if (S >= 8 && _simd_s32x8_log_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_log_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s32x4_log_
		} else if (S >= 4 && _simd_s32x4_log_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_log_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s32x2_log_
		} else if (S >= 2 && _simd_s32x2_log_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_log_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_LOG> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_LOG> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG2> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log2_
		} else if (S >= 64 && _simd_s32x64_log2_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_log2_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s32x32_log2_
		} else if (S >= 32 && _simd_s32x32_log2_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_log2_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s32x16_log2_
		} else if (S >= 16 && _simd_s32x16_log2_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_log2_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s32x8_log2_
		} else if (S >= 8 && _simd_s32x8_log2_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_log2_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s32x4_log2_
		} else if (S >= 4 && _simd_s32x4_log2_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_log2_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s32x2_log2_
		} else if (S >= 2 && _simd_s32x2_log2_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_log2_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_LOG2> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_LOG2> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_LOG10> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_log10_
		} else if (S >= 64 && _simd_s32x64_log10_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_log10_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s32x32_log10_
		} else if (S >= 32 && _simd_s32x32_log10_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_log10_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s32x16_log10_
		} else if (S >= 16 && _simd_s32x16_log10_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_log10_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s32x8_log10_
		} else if (S >= 8 && _simd_s32x8_log10_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_log10_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s32x4_log10_
		} else if (S >= 4 && _simd_s32x4_log10_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_log10_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s32x2_log10_
		} else if (S >= 2 && _simd_s32x2_log10_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_log10_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_LOG10> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_LOG10> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CEIL> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_ceil_
		} else if (S >= 64 && _simd_s32x64_ceil_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_ceil_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s32x32_ceil_
		} else if (S >= 32 && _simd_s32x32_ceil_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_ceil_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s32x16_ceil_
		} else if (S >= 16 && _simd_s32x16_ceil_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_ceil_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s32x8_ceil_
		} else if (S >= 8 && _simd_s32x8_ceil_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_ceil_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s32x4_ceil_
		} else if (S >= 4 && _simd_s32x4_ceil_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_ceil_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s32x2_ceil_
		} else if (S >= 2 && _simd_s32x2_ceil_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_ceil_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CEIL> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CEIL> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_FLOOR> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_floor_
		} else if (S >= 64 && _simd_s32x64_floor_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_floor_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s32x32_floor_
		} else if (S >= 32 && _simd_s32x32_floor_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_floor_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s32x16_floor_
		} else if (S >= 16 && _simd_s32x16_floor_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_floor_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s32x8_floor_
		} else if (S >= 8 && _simd_s32x8_floor_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_floor_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s32x4_floor_
		} else if (S >= 4 && _simd_s32x4_floor_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_floor_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s32x2_floor_
		} else if (S >= 2 && _simd_s32x2_floor_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_floor_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_FLOOR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_FLOOR> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ROUND> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_round_
		} else if (S >= 64 && _simd_s32x64_round_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_round_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s32x32_round_
		} else if (S >= 32 && _simd_s32x32_round_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_round_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s32x16_round_
		} else if (S >= 16 && _simd_s32x16_round_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_round_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s32x8_round_
		} else if (S >= 8 && _simd_s32x8_round_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_round_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s32x4_round_
		} else if (S >= 4 && _simd_s32x4_round_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_round_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s32x2_round_
		} else if (S >= 2 && _simd_s32x2_round_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_round_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ROUND> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ROUND> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sin_
		} else if (S >= 64 && _simd_s32x64_sin_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_sin_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s32x32_sin_
		} else if (S >= 32 && _simd_s32x32_sin_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_sin_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s32x16_sin_
		} else if (S >= 16 && _simd_s32x16_sin_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_sin_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s32x8_sin_
		} else if (S >= 8 && _simd_s32x8_sin_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_sin_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s32x4_sin_
		} else if (S >= 4 && _simd_s32x4_sin_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_sin_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s32x2_sin_
		} else if (S >= 2 && _simd_s32x2_sin_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_sin_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_SIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_SIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_COS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cos_
		} else if (S >= 64 && _simd_s32x64_cos_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cos_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s32x32_cos_
		} else if (S >= 32 && _simd_s32x32_cos_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cos_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s32x16_cos_
		} else if (S >= 16 && _simd_s32x16_cos_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cos_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s32x8_cos_
		} else if (S >= 8 && _simd_s32x8_cos_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cos_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s32x4_cos_
		} else if (S >= 4 && _simd_s32x4_cos_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cos_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s32x2_cos_
		} else if (S >= 2 && _simd_s32x2_cos_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cos_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_COS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_COS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_TAN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_tan_
		} else if (S >= 64 && _simd_s32x64_tan_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_tan_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s32x32_tan_
		} else if (S >= 32 && _simd_s32x32_tan_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_tan_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s32x16_tan_
		} else if (S >= 16 && _simd_s32x16_tan_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_tan_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s32x8_tan_
		} else if (S >= 8 && _simd_s32x8_tan_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_tan_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s32x4_tan_
		} else if (S >= 4 && _simd_s32x4_tan_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_tan_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s32x2_tan_
		} else if (S >= 2 && _simd_s32x2_tan_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_tan_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_TAN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_TAN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ASIN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_asin_
		} else if (S >= 64 && _simd_s32x64_asin_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_asin_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s32x32_asin_
		} else if (S >= 32 && _simd_s32x32_asin_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_asin_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s32x16_asin_
		} else if (S >= 16 && _simd_s32x16_asin_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_asin_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s32x8_asin_
		} else if (S >= 8 && _simd_s32x8_asin_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_asin_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s32x4_asin_
		} else if (S >= 4 && _simd_s32x4_asin_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_asin_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s32x2_asin_
		} else if (S >= 2 && _simd_s32x2_asin_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_asin_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ASIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ASIN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ACOS> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_acos_
		} else if (S >= 64 && _simd_s32x64_acos_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_acos_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s32x32_acos_
		} else if (S >= 32 && _simd_s32x32_acos_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_acos_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s32x16_acos_
		} else if (S >= 16 && _simd_s32x16_acos_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_acos_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s32x8_acos_
		} else if (S >= 8 && _simd_s32x8_acos_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_acos_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s32x4_acos_
		} else if (S >= 4 && _simd_s32x4_acos_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_acos_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s32x2_acos_
		} else if (S >= 2 && _simd_s32x2_acos_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_acos_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ACOS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ACOS> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_ATAN> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_atan_
		} else if (S >= 64 && _simd_s32x64_atan_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_atan_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s32x32_atan_
		} else if (S >= 32 && _simd_s32x32_atan_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_atan_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s32x16_atan_
		} else if (S >= 16 && _simd_s32x16_atan_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_atan_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s32x8_atan_
		} else if (S >= 8 && _simd_s32x8_atan_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_atan_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s32x4_atan_
		} else if (S >= 4 && _simd_s32x4_atan_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_atan_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s32x2_atan_
		} else if (S >= 2 && _simd_s32x2_atan_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_atan_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_ATAN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_ATAN> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SINH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sinh_
		} else if (S >= 64 && _simd_s32x64_sinh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_sinh_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s32x32_sinh_
		} else if (S >= 32 && _simd_s32x32_sinh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_sinh_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s32x16_sinh_
		} else if (S >= 16 && _simd_s32x16_sinh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_sinh_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s32x8_sinh_
		} else if (S >= 8 && _simd_s32x8_sinh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_sinh_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s32x4_sinh_
		} else if (S >= 4 && _simd_s32x4_sinh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_sinh_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s32x2_sinh_
		} else if (S >= 2 && _simd_s32x2_sinh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_sinh_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_SINH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_SINH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_COSH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cosh_
		} else if (S >= 64 && _simd_s32x64_cosh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cosh_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s32x32_cosh_
		} else if (S >= 32 && _simd_s32x32_cosh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cosh_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s32x16_cosh_
		} else if (S >= 16 && _simd_s32x16_cosh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cosh_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s32x8_cosh_
		} else if (S >= 8 && _simd_s32x8_cosh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cosh_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s32x4_cosh_
		} else if (S >= 4 && _simd_s32x4_cosh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cosh_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s32x2_cosh_
		} else if (S >= 2 && _simd_s32x2_cosh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cosh_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_COSH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_COSH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_TANH> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_tanh_
		} else if (S >= 64 && _simd_s32x64_tanh_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_tanh_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s32x32_tanh_
		} else if (S >= 32 && _simd_s32x32_tanh_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_tanh_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s32x16_tanh_
		} else if (S >= 16 && _simd_s32x16_tanh_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_tanh_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s32x8_tanh_
		} else if (S >= 8 && _simd_s32x8_tanh_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_tanh_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s32x4_tanh_
		} else if (S >= 4 && _simd_s32x4_tanh_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_tanh_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s32x2_tanh_
		} else if (S >= 2 && _simd_s32x2_tanh_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_tanh_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_TANH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_TANH> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_SQRT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_sqrt_
		} else if (S >= 64 && _simd_s32x64_sqrt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_sqrt_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s32x32_sqrt_
		} else if (S >= 32 && _simd_s32x32_sqrt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_sqrt_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s32x16_sqrt_
		} else if (S >= 16 && _simd_s32x16_sqrt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_sqrt_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s32x8_sqrt_
		} else if (S >= 8 && _simd_s32x8_sqrt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_sqrt_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s32x4_sqrt_
		} else if (S >= 4 && _simd_s32x4_sqrt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_sqrt_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s32x2_sqrt_
		} else if (S >= 2 && _simd_s32x2_sqrt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_sqrt_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_SQRT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_SQRT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s32x1, S, OP_CBRT> {
	typedef _simd_s32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s32x64_cbrt_
		} else if (S >= 64 && _simd_s32x64_cbrt_enable()) {
			typedef _simd_s32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x64_cbrt_(_simd_s32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s32x32_cbrt_
		} else if (S >= 32 && _simd_s32x32_cbrt_enable()) {
			typedef _simd_s32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x32_cbrt_(_simd_s32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s32x16_cbrt_
		} else if (S >= 16 && _simd_s32x16_cbrt_enable()) {
			typedef _simd_s32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x16_cbrt_(_simd_s32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s32x8_cbrt_
		} else if (S >= 8 && _simd_s32x8_cbrt_enable()) {
			typedef _simd_s32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x8_cbrt_(_simd_s32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s32x4_cbrt_
		} else if (S >= 4 && _simd_s32x4_cbrt_enable()) {
			typedef _simd_s32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x4_cbrt_(_simd_s32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s32x2_cbrt_
		} else if (S >= 2 && _simd_s32x2_cbrt_enable()) {
			typedef _simd_s32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s32x2_cbrt_(_simd_s32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s32x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 1, OP_CBRT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s32x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s32x1, 0, OP_CBRT> {
	typedef _simd_s32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S,OP_SUM> {
	typedef _simd_u32x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_add_
		} else if (S >= 64 && _simd_u32x64_add_enable()) {
			typedef _simd_u32x64 simd_t;
			simd_t tmp = _simd_u32x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x64_add_(tmp, _simd_u32x64_load_(o)); 
				o += 64;
			}
			return _simd_u32x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u32x32_add_
		} else if (S >= 32 && _simd_u32x32_add_enable()) {
			typedef _simd_u32x32 simd_t;
			simd_t tmp = _simd_u32x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x32_add_(tmp, _simd_u32x32_load_(o)); 
				o += 32;
			}
			return _simd_u32x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u32x16_add_
		} else if (S >= 16 && _simd_u32x16_add_enable()) {
			typedef _simd_u32x16 simd_t;
			simd_t tmp = _simd_u32x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x16_add_(tmp, _simd_u32x16_load_(o)); 
				o += 16;
			}
			return _simd_u32x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u32x8_add_
		} else if (S >= 8 && _simd_u32x8_add_enable()) {
			typedef _simd_u32x8 simd_t;
			simd_t tmp = _simd_u32x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x8_add_(tmp, _simd_u32x8_load_(o)); 
				o += 8;
			}
			return _simd_u32x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u32x4_add_
		} else if (S >= 4 && _simd_u32x4_add_enable()) {
			typedef _simd_u32x4 simd_t;
			simd_t tmp = _simd_u32x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x4_add_(tmp, _simd_u32x4_load_(o)); 
				o += 4;
			}
			return _simd_u32x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u32x2_add_
		} else if (S >= 2 && _simd_u32x2_add_enable()) {
			typedef _simd_u32x2 simd_t;
			simd_t tmp = _simd_u32x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u32x2_add_(tmp, _simd_u32x2_load_(o)); 
				o += 2;
			}
			return _simd_u32x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1,OP_SUM> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0,OP_SUM> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FILL0> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fill_zero_
		} else if (S >= 64 && _simd_u32x64_fill_zero_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u32x32_fill_zero_
		} else if (S >= 32 && _simd_u32x32_fill_zero_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u32x16_fill_zero_
		} else if (S >= 16 && _simd_u32x16_fill_zero_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u32x8_fill_zero_
		} else if (S >= 8 && _simd_u32x8_fill_zero_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u32x4_fill_zero_
		} else if (S >= 4 && _simd_u32x4_fill_zero_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u32x2_fill_zero_
		} else if (S >= 2 && _simd_u32x2_fill_zero_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FILLU> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FILLS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fill_scalar_
		} else if (S >= 64 && _simd_u32x64_fill_scalar_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u32x32_fill_scalar_
		} else if (S >= 32 && _simd_u32x32_fill_scalar_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u32x16_fill_scalar_
		} else if (S >= 16 && _simd_u32x16_fill_scalar_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u32x8_fill_scalar_
		} else if (S >= 8 && _simd_u32x8_fill_scalar_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u32x4_fill_scalar_
		} else if (S >= 4 && _simd_u32x4_fill_scalar_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u32x2_fill_scalar_
		} else if (S >= 2 && _simd_u32x2_fill_scalar_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FMA> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fma_
		} else if (S >= 64 && _simd_u32x64_fma_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_fma_(_simd_u32x64_load_(x),_simd_u32x64_load_(y),_simd_u32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x32_fma_
		} else if (S >= 32 && _simd_u32x32_fma_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_fma_(_simd_u32x32_load_(x),_simd_u32x32_load_(y),_simd_u32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x16_fma_
		} else if (S >= 16 && _simd_u32x16_fma_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_fma_(_simd_u32x16_load_(x),_simd_u32x16_load_(y),_simd_u32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x8_fma_
		} else if (S >= 8 && _simd_u32x8_fma_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_fma_(_simd_u32x8_load_(x),_simd_u32x8_load_(y),_simd_u32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x4_fma_
		} else if (S >= 4 && _simd_u32x4_fma_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_fma_(_simd_u32x4_load_(x),_simd_u32x4_load_(y),_simd_u32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x2_fma_
		} else if (S >= 2 && _simd_u32x2_fma_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_fma_(_simd_u32x2_load_(x),_simd_u32x2_load_(y),_simd_u32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_FMA> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u32x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_FMA> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FMS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_fms_
		} else if (S >= 64 && _simd_u32x64_fms_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_fms_(_simd_u32x64_load_(x),_simd_u32x64_load_(y),_simd_u32x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x32_fms_
		} else if (S >= 32 && _simd_u32x32_fms_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_fms_(_simd_u32x32_load_(x),_simd_u32x32_load_(y),_simd_u32x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x16_fms_
		} else if (S >= 16 && _simd_u32x16_fms_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_fms_(_simd_u32x16_load_(x),_simd_u32x16_load_(y),_simd_u32x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x8_fms_
		} else if (S >= 8 && _simd_u32x8_fms_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_fms_(_simd_u32x8_load_(x),_simd_u32x8_load_(y),_simd_u32x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x4_fms_
		} else if (S >= 4 && _simd_u32x4_fms_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_fms_(_simd_u32x4_load_(x),_simd_u32x4_load_(y),_simd_u32x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u32x2_fms_
		} else if (S >= 2 && _simd_u32x2_fms_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_fms_(_simd_u32x2_load_(x),_simd_u32x2_load_(y),_simd_u32x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_FMS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u32x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_FMS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ADD> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_add_
		} else if (S >= 64 && _simd_u32x64_add_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_add_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_add_
		} else if (S >= 32 && _simd_u32x32_add_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_add_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_add_
		} else if (S >= 16 && _simd_u32x16_add_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_add_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_add_
		} else if (S >= 8 && _simd_u32x8_add_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_add_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_add_
		} else if (S >= 4 && _simd_u32x4_add_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_add_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_add_
		} else if (S >= 2 && _simd_u32x2_add_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_add_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ADD> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ADD> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SUB> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sub_
		} else if (S >= 64 && _simd_u32x64_sub_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_sub_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_sub_
		} else if (S >= 32 && _simd_u32x32_sub_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_sub_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_sub_
		} else if (S >= 16 && _simd_u32x16_sub_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_sub_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_sub_
		} else if (S >= 8 && _simd_u32x8_sub_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_sub_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_sub_
		} else if (S >= 4 && _simd_u32x4_sub_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_sub_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_sub_
		} else if (S >= 2 && _simd_u32x2_sub_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_sub_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_SUB> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_SUB> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MUL> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_mul_
		} else if (S >= 64 && _simd_u32x64_mul_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_mul_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_mul_
		} else if (S >= 32 && _simd_u32x32_mul_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_mul_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_mul_
		} else if (S >= 16 && _simd_u32x16_mul_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_mul_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_mul_
		} else if (S >= 8 && _simd_u32x8_mul_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_mul_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_mul_
		} else if (S >= 4 && _simd_u32x4_mul_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_mul_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_mul_
		} else if (S >= 2 && _simd_u32x2_mul_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_mul_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_MUL> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_MUL> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_DIV> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_div_
		} else if (S >= 64 && _simd_u32x64_div_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_div_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_div_
		} else if (S >= 32 && _simd_u32x32_div_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_div_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_div_
		} else if (S >= 16 && _simd_u32x16_div_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_div_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_div_
		} else if (S >= 8 && _simd_u32x8_div_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_div_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_div_
		} else if (S >= 4 && _simd_u32x4_div_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_div_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_div_
		} else if (S >= 2 && _simd_u32x2_div_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_div_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_DIV> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_DIV> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_min_
		} else if (S >= 64 && _simd_u32x64_min_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_min_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_min_
		} else if (S >= 32 && _simd_u32x32_min_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_min_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_min_
		} else if (S >= 16 && _simd_u32x16_min_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_min_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_min_
		} else if (S >= 8 && _simd_u32x8_min_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_min_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_min_
		} else if (S >= 4 && _simd_u32x4_min_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_min_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_min_
		} else if (S >= 2 && _simd_u32x2_min_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_min_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_MIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_MIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_MAX> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_max_
		} else if (S >= 64 && _simd_u32x64_max_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_max_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_max_
		} else if (S >= 32 && _simd_u32x32_max_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_max_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_max_
		} else if (S >= 16 && _simd_u32x16_max_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_max_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_max_
		} else if (S >= 8 && _simd_u32x8_max_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_max_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_max_
		} else if (S >= 4 && _simd_u32x4_max_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_max_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_max_
		} else if (S >= 2 && _simd_u32x2_max_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_max_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_MAX> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_MAX> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPEQ> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpeq_
		} else if (S >= 64 && _simd_u32x64_cmpeq_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmpeq_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmpeq_
		} else if (S >= 32 && _simd_u32x32_cmpeq_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmpeq_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmpeq_
		} else if (S >= 16 && _simd_u32x16_cmpeq_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmpeq_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmpeq_
		} else if (S >= 8 && _simd_u32x8_cmpeq_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmpeq_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmpeq_
		} else if (S >= 4 && _simd_u32x4_cmpeq_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmpeq_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmpeq_
		} else if (S >= 2 && _simd_u32x2_cmpeq_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmpeq_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPEQ> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPEQ> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPNE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpne_
		} else if (S >= 64 && _simd_u32x64_cmpne_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmpne_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmpne_
		} else if (S >= 32 && _simd_u32x32_cmpne_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmpne_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmpne_
		} else if (S >= 16 && _simd_u32x16_cmpne_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmpne_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmpne_
		} else if (S >= 8 && _simd_u32x8_cmpne_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmpne_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmpne_
		} else if (S >= 4 && _simd_u32x4_cmpne_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmpne_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmpne_
		} else if (S >= 2 && _simd_u32x2_cmpne_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmpne_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPNE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPNE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPLT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmplt_
		} else if (S >= 64 && _simd_u32x64_cmplt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmplt_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmplt_
		} else if (S >= 32 && _simd_u32x32_cmplt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmplt_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmplt_
		} else if (S >= 16 && _simd_u32x16_cmplt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmplt_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmplt_
		} else if (S >= 8 && _simd_u32x8_cmplt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmplt_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmplt_
		} else if (S >= 4 && _simd_u32x4_cmplt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmplt_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmplt_
		} else if (S >= 2 && _simd_u32x2_cmplt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmplt_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPLT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPLT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPGT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpgt_
		} else if (S >= 64 && _simd_u32x64_cmpgt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmpgt_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmpgt_
		} else if (S >= 32 && _simd_u32x32_cmpgt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmpgt_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmpgt_
		} else if (S >= 16 && _simd_u32x16_cmpgt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmpgt_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmpgt_
		} else if (S >= 8 && _simd_u32x8_cmpgt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmpgt_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmpgt_
		} else if (S >= 4 && _simd_u32x4_cmpgt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmpgt_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmpgt_
		} else if (S >= 2 && _simd_u32x2_cmpgt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmpgt_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPGT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPGT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPLE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmple_
		} else if (S >= 64 && _simd_u32x64_cmple_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmple_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmple_
		} else if (S >= 32 && _simd_u32x32_cmple_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmple_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmple_
		} else if (S >= 16 && _simd_u32x16_cmple_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmple_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmple_
		} else if (S >= 8 && _simd_u32x8_cmple_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmple_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmple_
		} else if (S >= 4 && _simd_u32x4_cmple_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmple_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmple_
		} else if (S >= 2 && _simd_u32x2_cmple_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmple_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPLE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPLE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CMPGE> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cmpge_
		} else if (S >= 64 && _simd_u32x64_cmpge_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cmpge_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_cmpge_
		} else if (S >= 32 && _simd_u32x32_cmpge_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cmpge_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_cmpge_
		} else if (S >= 16 && _simd_u32x16_cmpge_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cmpge_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_cmpge_
		} else if (S >= 8 && _simd_u32x8_cmpge_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cmpge_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_cmpge_
		} else if (S >= 4 && _simd_u32x4_cmpge_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cmpge_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_cmpge_
		} else if (S >= 2 && _simd_u32x2_cmpge_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cmpge_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CMPGE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CMPGE> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_AND> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_and_
		} else if (S >= 64 && _simd_u32x64_and_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_and_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_and_
		} else if (S >= 32 && _simd_u32x32_and_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_and_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_and_
		} else if (S >= 16 && _simd_u32x16_and_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_and_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_and_
		} else if (S >= 8 && _simd_u32x8_and_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_and_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_and_
		} else if (S >= 4 && _simd_u32x4_and_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_and_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_and_
		} else if (S >= 2 && _simd_u32x2_and_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_and_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_AND> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_AND> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_OR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_or_
		} else if (S >= 64 && _simd_u32x64_or_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_or_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_or_
		} else if (S >= 32 && _simd_u32x32_or_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_or_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_or_
		} else if (S >= 16 && _simd_u32x16_or_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_or_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_or_
		} else if (S >= 8 && _simd_u32x8_or_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_or_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_or_
		} else if (S >= 4 && _simd_u32x4_or_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_or_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_or_
		} else if (S >= 2 && _simd_u32x2_or_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_or_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_OR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_OR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_XOR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_xor_
		} else if (S >= 64 && _simd_u32x64_xor_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_xor_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_xor_
		} else if (S >= 32 && _simd_u32x32_xor_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_xor_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_xor_
		} else if (S >= 16 && _simd_u32x16_xor_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_xor_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_xor_
		} else if (S >= 8 && _simd_u32x8_xor_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_xor_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_xor_
		} else if (S >= 4 && _simd_u32x4_xor_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_xor_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_xor_
		} else if (S >= 2 && _simd_u32x2_xor_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_xor_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_XOR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_XOR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_lshift_
		} else if (S >= 64 && _simd_u32x64_lshift_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_lshift_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_lshift_
		} else if (S >= 32 && _simd_u32x32_lshift_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_lshift_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_lshift_
		} else if (S >= 16 && _simd_u32x16_lshift_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_lshift_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_lshift_
		} else if (S >= 8 && _simd_u32x8_lshift_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_lshift_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_lshift_
		} else if (S >= 4 && _simd_u32x4_lshift_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_lshift_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_lshift_
		} else if (S >= 2 && _simd_u32x2_lshift_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_lshift_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_LSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_LSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_RSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_rshift_
		} else if (S >= 64 && _simd_u32x64_rshift_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_rshift_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_rshift_
		} else if (S >= 32 && _simd_u32x32_rshift_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_rshift_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_rshift_
		} else if (S >= 16 && _simd_u32x16_rshift_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_rshift_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_rshift_
		} else if (S >= 8 && _simd_u32x8_rshift_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_rshift_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_rshift_
		} else if (S >= 4 && _simd_u32x4_rshift_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_rshift_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_rshift_
		} else if (S >= 2 && _simd_u32x2_rshift_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_rshift_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_RSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_RSHIFT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ATAN2> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_atan2_
		} else if (S >= 64 && _simd_u32x64_atan2_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_atan2_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_atan2_
		} else if (S >= 32 && _simd_u32x32_atan2_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_atan2_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_atan2_
		} else if (S >= 16 && _simd_u32x16_atan2_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_atan2_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_atan2_
		} else if (S >= 8 && _simd_u32x8_atan2_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_atan2_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_atan2_
		} else if (S >= 4 && _simd_u32x4_atan2_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_atan2_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_atan2_
		} else if (S >= 2 && _simd_u32x2_atan2_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_atan2_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ATAN2> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ATAN2> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_POW> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_pow_
		} else if (S >= 64 && _simd_u32x64_pow_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_pow_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_pow_
		} else if (S >= 32 && _simd_u32x32_pow_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_pow_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_pow_
		} else if (S >= 16 && _simd_u32x16_pow_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_pow_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_pow_
		} else if (S >= 8 && _simd_u32x8_pow_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_pow_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_pow_
		} else if (S >= 4 && _simd_u32x4_pow_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_pow_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_pow_
		} else if (S >= 2 && _simd_u32x2_pow_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_pow_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_POW> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_POW> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_HYPOT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_hypot_
		} else if (S >= 64 && _simd_u32x64_hypot_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_hypot_(_simd_u32x64_load_(x),_simd_u32x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u32x32_hypot_
		} else if (S >= 32 && _simd_u32x32_hypot_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_hypot_(_simd_u32x32_load_(x),_simd_u32x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u32x16_hypot_
		} else if (S >= 16 && _simd_u32x16_hypot_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_hypot_(_simd_u32x16_load_(x),_simd_u32x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u32x8_hypot_
		} else if (S >= 8 && _simd_u32x8_hypot_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_hypot_(_simd_u32x8_load_(x),_simd_u32x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u32x4_hypot_
		} else if (S >= 4 && _simd_u32x4_hypot_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_hypot_(_simd_u32x4_load_(x),_simd_u32x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u32x2_hypot_
		} else if (S >= 2 && _simd_u32x2_hypot_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_hypot_(_simd_u32x2_load_(x),_simd_u32x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_HYPOT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u32x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_HYPOT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_NOT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_not_
		} else if (S >= 64 && _simd_u32x64_not_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_not_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u32x32_not_
		} else if (S >= 32 && _simd_u32x32_not_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_not_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u32x16_not_
		} else if (S >= 16 && _simd_u32x16_not_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_not_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u32x8_not_
		} else if (S >= 8 && _simd_u32x8_not_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_not_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u32x4_not_
		} else if (S >= 4 && _simd_u32x4_not_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_not_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u32x2_not_
		} else if (S >= 2 && _simd_u32x2_not_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_not_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_NOT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_NOT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ABS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_abs_
		} else if (S >= 64 && _simd_u32x64_abs_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_abs_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u32x32_abs_
		} else if (S >= 32 && _simd_u32x32_abs_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_abs_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u32x16_abs_
		} else if (S >= 16 && _simd_u32x16_abs_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_abs_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u32x8_abs_
		} else if (S >= 8 && _simd_u32x8_abs_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_abs_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u32x4_abs_
		} else if (S >= 4 && _simd_u32x4_abs_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_abs_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u32x2_abs_
		} else if (S >= 2 && _simd_u32x2_abs_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_abs_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ABS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ABS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_EXP> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_exp_
		} else if (S >= 64 && _simd_u32x64_exp_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_exp_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u32x32_exp_
		} else if (S >= 32 && _simd_u32x32_exp_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_exp_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u32x16_exp_
		} else if (S >= 16 && _simd_u32x16_exp_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_exp_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u32x8_exp_
		} else if (S >= 8 && _simd_u32x8_exp_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_exp_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u32x4_exp_
		} else if (S >= 4 && _simd_u32x4_exp_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_exp_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u32x2_exp_
		} else if (S >= 2 && _simd_u32x2_exp_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_exp_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_EXP> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_EXP> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log_
		} else if (S >= 64 && _simd_u32x64_log_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_log_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u32x32_log_
		} else if (S >= 32 && _simd_u32x32_log_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_log_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u32x16_log_
		} else if (S >= 16 && _simd_u32x16_log_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_log_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u32x8_log_
		} else if (S >= 8 && _simd_u32x8_log_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_log_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u32x4_log_
		} else if (S >= 4 && _simd_u32x4_log_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_log_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u32x2_log_
		} else if (S >= 2 && _simd_u32x2_log_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_log_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_LOG> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_LOG> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG2> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log2_
		} else if (S >= 64 && _simd_u32x64_log2_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_log2_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u32x32_log2_
		} else if (S >= 32 && _simd_u32x32_log2_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_log2_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u32x16_log2_
		} else if (S >= 16 && _simd_u32x16_log2_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_log2_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u32x8_log2_
		} else if (S >= 8 && _simd_u32x8_log2_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_log2_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u32x4_log2_
		} else if (S >= 4 && _simd_u32x4_log2_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_log2_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u32x2_log2_
		} else if (S >= 2 && _simd_u32x2_log2_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_log2_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_LOG2> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_LOG2> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_LOG10> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_log10_
		} else if (S >= 64 && _simd_u32x64_log10_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_log10_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u32x32_log10_
		} else if (S >= 32 && _simd_u32x32_log10_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_log10_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u32x16_log10_
		} else if (S >= 16 && _simd_u32x16_log10_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_log10_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u32x8_log10_
		} else if (S >= 8 && _simd_u32x8_log10_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_log10_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u32x4_log10_
		} else if (S >= 4 && _simd_u32x4_log10_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_log10_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u32x2_log10_
		} else if (S >= 2 && _simd_u32x2_log10_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_log10_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_LOG10> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_LOG10> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CEIL> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_ceil_
		} else if (S >= 64 && _simd_u32x64_ceil_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_ceil_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u32x32_ceil_
		} else if (S >= 32 && _simd_u32x32_ceil_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_ceil_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u32x16_ceil_
		} else if (S >= 16 && _simd_u32x16_ceil_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_ceil_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u32x8_ceil_
		} else if (S >= 8 && _simd_u32x8_ceil_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_ceil_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u32x4_ceil_
		} else if (S >= 4 && _simd_u32x4_ceil_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_ceil_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u32x2_ceil_
		} else if (S >= 2 && _simd_u32x2_ceil_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_ceil_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CEIL> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CEIL> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_FLOOR> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_floor_
		} else if (S >= 64 && _simd_u32x64_floor_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_floor_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u32x32_floor_
		} else if (S >= 32 && _simd_u32x32_floor_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_floor_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u32x16_floor_
		} else if (S >= 16 && _simd_u32x16_floor_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_floor_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u32x8_floor_
		} else if (S >= 8 && _simd_u32x8_floor_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_floor_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u32x4_floor_
		} else if (S >= 4 && _simd_u32x4_floor_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_floor_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u32x2_floor_
		} else if (S >= 2 && _simd_u32x2_floor_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_floor_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_FLOOR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_FLOOR> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ROUND> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_round_
		} else if (S >= 64 && _simd_u32x64_round_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_round_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u32x32_round_
		} else if (S >= 32 && _simd_u32x32_round_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_round_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u32x16_round_
		} else if (S >= 16 && _simd_u32x16_round_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_round_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u32x8_round_
		} else if (S >= 8 && _simd_u32x8_round_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_round_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u32x4_round_
		} else if (S >= 4 && _simd_u32x4_round_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_round_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u32x2_round_
		} else if (S >= 2 && _simd_u32x2_round_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_round_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ROUND> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ROUND> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sin_
		} else if (S >= 64 && _simd_u32x64_sin_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_sin_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u32x32_sin_
		} else if (S >= 32 && _simd_u32x32_sin_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_sin_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u32x16_sin_
		} else if (S >= 16 && _simd_u32x16_sin_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_sin_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u32x8_sin_
		} else if (S >= 8 && _simd_u32x8_sin_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_sin_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u32x4_sin_
		} else if (S >= 4 && _simd_u32x4_sin_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_sin_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u32x2_sin_
		} else if (S >= 2 && _simd_u32x2_sin_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_sin_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_SIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_SIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_COS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cos_
		} else if (S >= 64 && _simd_u32x64_cos_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cos_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u32x32_cos_
		} else if (S >= 32 && _simd_u32x32_cos_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cos_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u32x16_cos_
		} else if (S >= 16 && _simd_u32x16_cos_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cos_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u32x8_cos_
		} else if (S >= 8 && _simd_u32x8_cos_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cos_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u32x4_cos_
		} else if (S >= 4 && _simd_u32x4_cos_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cos_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u32x2_cos_
		} else if (S >= 2 && _simd_u32x2_cos_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cos_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_COS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_COS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_TAN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_tan_
		} else if (S >= 64 && _simd_u32x64_tan_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_tan_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u32x32_tan_
		} else if (S >= 32 && _simd_u32x32_tan_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_tan_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u32x16_tan_
		} else if (S >= 16 && _simd_u32x16_tan_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_tan_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u32x8_tan_
		} else if (S >= 8 && _simd_u32x8_tan_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_tan_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u32x4_tan_
		} else if (S >= 4 && _simd_u32x4_tan_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_tan_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u32x2_tan_
		} else if (S >= 2 && _simd_u32x2_tan_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_tan_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_TAN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_TAN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ASIN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_asin_
		} else if (S >= 64 && _simd_u32x64_asin_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_asin_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u32x32_asin_
		} else if (S >= 32 && _simd_u32x32_asin_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_asin_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u32x16_asin_
		} else if (S >= 16 && _simd_u32x16_asin_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_asin_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u32x8_asin_
		} else if (S >= 8 && _simd_u32x8_asin_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_asin_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u32x4_asin_
		} else if (S >= 4 && _simd_u32x4_asin_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_asin_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u32x2_asin_
		} else if (S >= 2 && _simd_u32x2_asin_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_asin_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ASIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ASIN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ACOS> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_acos_
		} else if (S >= 64 && _simd_u32x64_acos_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_acos_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u32x32_acos_
		} else if (S >= 32 && _simd_u32x32_acos_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_acos_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u32x16_acos_
		} else if (S >= 16 && _simd_u32x16_acos_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_acos_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u32x8_acos_
		} else if (S >= 8 && _simd_u32x8_acos_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_acos_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u32x4_acos_
		} else if (S >= 4 && _simd_u32x4_acos_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_acos_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u32x2_acos_
		} else if (S >= 2 && _simd_u32x2_acos_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_acos_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ACOS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ACOS> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_ATAN> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_atan_
		} else if (S >= 64 && _simd_u32x64_atan_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_atan_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u32x32_atan_
		} else if (S >= 32 && _simd_u32x32_atan_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_atan_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u32x16_atan_
		} else if (S >= 16 && _simd_u32x16_atan_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_atan_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u32x8_atan_
		} else if (S >= 8 && _simd_u32x8_atan_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_atan_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u32x4_atan_
		} else if (S >= 4 && _simd_u32x4_atan_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_atan_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u32x2_atan_
		} else if (S >= 2 && _simd_u32x2_atan_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_atan_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_ATAN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_ATAN> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SINH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sinh_
		} else if (S >= 64 && _simd_u32x64_sinh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_sinh_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u32x32_sinh_
		} else if (S >= 32 && _simd_u32x32_sinh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_sinh_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u32x16_sinh_
		} else if (S >= 16 && _simd_u32x16_sinh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_sinh_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u32x8_sinh_
		} else if (S >= 8 && _simd_u32x8_sinh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_sinh_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u32x4_sinh_
		} else if (S >= 4 && _simd_u32x4_sinh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_sinh_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u32x2_sinh_
		} else if (S >= 2 && _simd_u32x2_sinh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_sinh_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_SINH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_SINH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_COSH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cosh_
		} else if (S >= 64 && _simd_u32x64_cosh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cosh_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u32x32_cosh_
		} else if (S >= 32 && _simd_u32x32_cosh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cosh_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u32x16_cosh_
		} else if (S >= 16 && _simd_u32x16_cosh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cosh_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u32x8_cosh_
		} else if (S >= 8 && _simd_u32x8_cosh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cosh_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u32x4_cosh_
		} else if (S >= 4 && _simd_u32x4_cosh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cosh_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u32x2_cosh_
		} else if (S >= 2 && _simd_u32x2_cosh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cosh_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_COSH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_COSH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_TANH> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_tanh_
		} else if (S >= 64 && _simd_u32x64_tanh_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_tanh_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u32x32_tanh_
		} else if (S >= 32 && _simd_u32x32_tanh_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_tanh_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u32x16_tanh_
		} else if (S >= 16 && _simd_u32x16_tanh_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_tanh_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u32x8_tanh_
		} else if (S >= 8 && _simd_u32x8_tanh_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_tanh_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u32x4_tanh_
		} else if (S >= 4 && _simd_u32x4_tanh_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_tanh_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u32x2_tanh_
		} else if (S >= 2 && _simd_u32x2_tanh_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_tanh_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_TANH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_TANH> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_SQRT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_sqrt_
		} else if (S >= 64 && _simd_u32x64_sqrt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_sqrt_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u32x32_sqrt_
		} else if (S >= 32 && _simd_u32x32_sqrt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_sqrt_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u32x16_sqrt_
		} else if (S >= 16 && _simd_u32x16_sqrt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_sqrt_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u32x8_sqrt_
		} else if (S >= 8 && _simd_u32x8_sqrt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_sqrt_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u32x4_sqrt_
		} else if (S >= 4 && _simd_u32x4_sqrt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_sqrt_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u32x2_sqrt_
		} else if (S >= 2 && _simd_u32x2_sqrt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_sqrt_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_SQRT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_SQRT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u32x1, S, OP_CBRT> {
	typedef _simd_u32x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u32x64_cbrt_
		} else if (S >= 64 && _simd_u32x64_cbrt_enable()) {
			typedef _simd_u32x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x64_cbrt_(_simd_u32x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u32x32_cbrt_
		} else if (S >= 32 && _simd_u32x32_cbrt_enable()) {
			typedef _simd_u32x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x32_cbrt_(_simd_u32x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u32x16_cbrt_
		} else if (S >= 16 && _simd_u32x16_cbrt_enable()) {
			typedef _simd_u32x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x16_cbrt_(_simd_u32x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u32x8_cbrt_
		} else if (S >= 8 && _simd_u32x8_cbrt_enable()) {
			typedef _simd_u32x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x8_cbrt_(_simd_u32x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u32x4_cbrt_
		} else if (S >= 4 && _simd_u32x4_cbrt_enable()) {
			typedef _simd_u32x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x4_cbrt_(_simd_u32x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u32x2_cbrt_
		} else if (S >= 2 && _simd_u32x2_cbrt_enable()) {
			typedef _simd_u32x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u32x2_cbrt_(_simd_u32x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u32x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 1, OP_CBRT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u32x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u32x1, 0, OP_CBRT> {
	typedef _simd_u32x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S,OP_SUM> {
	typedef _simd_s16x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_add_
		} else if (S >= 64 && _simd_s16x64_add_enable()) {
			typedef _simd_s16x64 simd_t;
			simd_t tmp = _simd_s16x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x64_add_(tmp, _simd_s16x64_load_(o)); 
				o += 64;
			}
			return _simd_s16x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s16x32_add_
		} else if (S >= 32 && _simd_s16x32_add_enable()) {
			typedef _simd_s16x32 simd_t;
			simd_t tmp = _simd_s16x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x32_add_(tmp, _simd_s16x32_load_(o)); 
				o += 32;
			}
			return _simd_s16x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s16x16_add_
		} else if (S >= 16 && _simd_s16x16_add_enable()) {
			typedef _simd_s16x16 simd_t;
			simd_t tmp = _simd_s16x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x16_add_(tmp, _simd_s16x16_load_(o)); 
				o += 16;
			}
			return _simd_s16x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s16x8_add_
		} else if (S >= 8 && _simd_s16x8_add_enable()) {
			typedef _simd_s16x8 simd_t;
			simd_t tmp = _simd_s16x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x8_add_(tmp, _simd_s16x8_load_(o)); 
				o += 8;
			}
			return _simd_s16x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s16x4_add_
		} else if (S >= 4 && _simd_s16x4_add_enable()) {
			typedef _simd_s16x4 simd_t;
			simd_t tmp = _simd_s16x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x4_add_(tmp, _simd_s16x4_load_(o)); 
				o += 4;
			}
			return _simd_s16x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s16x2_add_
		} else if (S >= 2 && _simd_s16x2_add_enable()) {
			typedef _simd_s16x2 simd_t;
			simd_t tmp = _simd_s16x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s16x2_add_(tmp, _simd_s16x2_load_(o)); 
				o += 2;
			}
			return _simd_s16x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1,OP_SUM> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0,OP_SUM> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FILL0> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fill_zero_
		} else if (S >= 64 && _simd_s16x64_fill_zero_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s16x32_fill_zero_
		} else if (S >= 32 && _simd_s16x32_fill_zero_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s16x16_fill_zero_
		} else if (S >= 16 && _simd_s16x16_fill_zero_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s16x8_fill_zero_
		} else if (S >= 8 && _simd_s16x8_fill_zero_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s16x4_fill_zero_
		} else if (S >= 4 && _simd_s16x4_fill_zero_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s16x2_fill_zero_
		} else if (S >= 2 && _simd_s16x2_fill_zero_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FILLU> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FILLS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fill_scalar_
		} else if (S >= 64 && _simd_s16x64_fill_scalar_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s16x32_fill_scalar_
		} else if (S >= 32 && _simd_s16x32_fill_scalar_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s16x16_fill_scalar_
		} else if (S >= 16 && _simd_s16x16_fill_scalar_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s16x8_fill_scalar_
		} else if (S >= 8 && _simd_s16x8_fill_scalar_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s16x4_fill_scalar_
		} else if (S >= 4 && _simd_s16x4_fill_scalar_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s16x2_fill_scalar_
		} else if (S >= 2 && _simd_s16x2_fill_scalar_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FMA> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fma_
		} else if (S >= 64 && _simd_s16x64_fma_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_fma_(_simd_s16x64_load_(x),_simd_s16x64_load_(y),_simd_s16x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x32_fma_
		} else if (S >= 32 && _simd_s16x32_fma_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_fma_(_simd_s16x32_load_(x),_simd_s16x32_load_(y),_simd_s16x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x16_fma_
		} else if (S >= 16 && _simd_s16x16_fma_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_fma_(_simd_s16x16_load_(x),_simd_s16x16_load_(y),_simd_s16x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x8_fma_
		} else if (S >= 8 && _simd_s16x8_fma_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_fma_(_simd_s16x8_load_(x),_simd_s16x8_load_(y),_simd_s16x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x4_fma_
		} else if (S >= 4 && _simd_s16x4_fma_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_fma_(_simd_s16x4_load_(x),_simd_s16x4_load_(y),_simd_s16x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x2_fma_
		} else if (S >= 2 && _simd_s16x2_fma_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_fma_(_simd_s16x2_load_(x),_simd_s16x2_load_(y),_simd_s16x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_FMA> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s16x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_FMA> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FMS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_fms_
		} else if (S >= 64 && _simd_s16x64_fms_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_fms_(_simd_s16x64_load_(x),_simd_s16x64_load_(y),_simd_s16x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x32_fms_
		} else if (S >= 32 && _simd_s16x32_fms_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_fms_(_simd_s16x32_load_(x),_simd_s16x32_load_(y),_simd_s16x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x16_fms_
		} else if (S >= 16 && _simd_s16x16_fms_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_fms_(_simd_s16x16_load_(x),_simd_s16x16_load_(y),_simd_s16x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x8_fms_
		} else if (S >= 8 && _simd_s16x8_fms_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_fms_(_simd_s16x8_load_(x),_simd_s16x8_load_(y),_simd_s16x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x4_fms_
		} else if (S >= 4 && _simd_s16x4_fms_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_fms_(_simd_s16x4_load_(x),_simd_s16x4_load_(y),_simd_s16x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s16x2_fms_
		} else if (S >= 2 && _simd_s16x2_fms_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_fms_(_simd_s16x2_load_(x),_simd_s16x2_load_(y),_simd_s16x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_FMS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s16x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_FMS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ADD> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_add_
		} else if (S >= 64 && _simd_s16x64_add_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_add_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_add_
		} else if (S >= 32 && _simd_s16x32_add_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_add_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_add_
		} else if (S >= 16 && _simd_s16x16_add_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_add_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_add_
		} else if (S >= 8 && _simd_s16x8_add_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_add_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_add_
		} else if (S >= 4 && _simd_s16x4_add_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_add_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_add_
		} else if (S >= 2 && _simd_s16x2_add_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_add_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ADD> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ADD> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SUB> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sub_
		} else if (S >= 64 && _simd_s16x64_sub_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_sub_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_sub_
		} else if (S >= 32 && _simd_s16x32_sub_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_sub_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_sub_
		} else if (S >= 16 && _simd_s16x16_sub_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_sub_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_sub_
		} else if (S >= 8 && _simd_s16x8_sub_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_sub_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_sub_
		} else if (S >= 4 && _simd_s16x4_sub_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_sub_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_sub_
		} else if (S >= 2 && _simd_s16x2_sub_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_sub_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_SUB> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_SUB> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MUL> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_mul_
		} else if (S >= 64 && _simd_s16x64_mul_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_mul_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_mul_
		} else if (S >= 32 && _simd_s16x32_mul_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_mul_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_mul_
		} else if (S >= 16 && _simd_s16x16_mul_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_mul_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_mul_
		} else if (S >= 8 && _simd_s16x8_mul_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_mul_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_mul_
		} else if (S >= 4 && _simd_s16x4_mul_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_mul_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_mul_
		} else if (S >= 2 && _simd_s16x2_mul_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_mul_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_MUL> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_MUL> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_DIV> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_div_
		} else if (S >= 64 && _simd_s16x64_div_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_div_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_div_
		} else if (S >= 32 && _simd_s16x32_div_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_div_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_div_
		} else if (S >= 16 && _simd_s16x16_div_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_div_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_div_
		} else if (S >= 8 && _simd_s16x8_div_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_div_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_div_
		} else if (S >= 4 && _simd_s16x4_div_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_div_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_div_
		} else if (S >= 2 && _simd_s16x2_div_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_div_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_DIV> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_DIV> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_min_
		} else if (S >= 64 && _simd_s16x64_min_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_min_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_min_
		} else if (S >= 32 && _simd_s16x32_min_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_min_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_min_
		} else if (S >= 16 && _simd_s16x16_min_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_min_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_min_
		} else if (S >= 8 && _simd_s16x8_min_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_min_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_min_
		} else if (S >= 4 && _simd_s16x4_min_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_min_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_min_
		} else if (S >= 2 && _simd_s16x2_min_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_min_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_MIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_MIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_MAX> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_max_
		} else if (S >= 64 && _simd_s16x64_max_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_max_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_max_
		} else if (S >= 32 && _simd_s16x32_max_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_max_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_max_
		} else if (S >= 16 && _simd_s16x16_max_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_max_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_max_
		} else if (S >= 8 && _simd_s16x8_max_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_max_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_max_
		} else if (S >= 4 && _simd_s16x4_max_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_max_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_max_
		} else if (S >= 2 && _simd_s16x2_max_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_max_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_MAX> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_MAX> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPEQ> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpeq_
		} else if (S >= 64 && _simd_s16x64_cmpeq_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmpeq_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmpeq_
		} else if (S >= 32 && _simd_s16x32_cmpeq_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmpeq_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmpeq_
		} else if (S >= 16 && _simd_s16x16_cmpeq_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmpeq_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmpeq_
		} else if (S >= 8 && _simd_s16x8_cmpeq_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmpeq_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmpeq_
		} else if (S >= 4 && _simd_s16x4_cmpeq_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmpeq_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmpeq_
		} else if (S >= 2 && _simd_s16x2_cmpeq_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmpeq_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPEQ> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPEQ> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPNE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpne_
		} else if (S >= 64 && _simd_s16x64_cmpne_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmpne_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmpne_
		} else if (S >= 32 && _simd_s16x32_cmpne_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmpne_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmpne_
		} else if (S >= 16 && _simd_s16x16_cmpne_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmpne_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmpne_
		} else if (S >= 8 && _simd_s16x8_cmpne_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmpne_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmpne_
		} else if (S >= 4 && _simd_s16x4_cmpne_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmpne_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmpne_
		} else if (S >= 2 && _simd_s16x2_cmpne_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmpne_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPNE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPNE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPLT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmplt_
		} else if (S >= 64 && _simd_s16x64_cmplt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmplt_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmplt_
		} else if (S >= 32 && _simd_s16x32_cmplt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmplt_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmplt_
		} else if (S >= 16 && _simd_s16x16_cmplt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmplt_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmplt_
		} else if (S >= 8 && _simd_s16x8_cmplt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmplt_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmplt_
		} else if (S >= 4 && _simd_s16x4_cmplt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmplt_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmplt_
		} else if (S >= 2 && _simd_s16x2_cmplt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmplt_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPLT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPLT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPGT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpgt_
		} else if (S >= 64 && _simd_s16x64_cmpgt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmpgt_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmpgt_
		} else if (S >= 32 && _simd_s16x32_cmpgt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmpgt_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmpgt_
		} else if (S >= 16 && _simd_s16x16_cmpgt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmpgt_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmpgt_
		} else if (S >= 8 && _simd_s16x8_cmpgt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmpgt_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmpgt_
		} else if (S >= 4 && _simd_s16x4_cmpgt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmpgt_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmpgt_
		} else if (S >= 2 && _simd_s16x2_cmpgt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmpgt_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPGT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPGT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPLE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmple_
		} else if (S >= 64 && _simd_s16x64_cmple_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmple_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmple_
		} else if (S >= 32 && _simd_s16x32_cmple_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmple_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmple_
		} else if (S >= 16 && _simd_s16x16_cmple_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmple_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmple_
		} else if (S >= 8 && _simd_s16x8_cmple_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmple_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmple_
		} else if (S >= 4 && _simd_s16x4_cmple_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmple_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmple_
		} else if (S >= 2 && _simd_s16x2_cmple_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmple_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPLE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPLE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CMPGE> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cmpge_
		} else if (S >= 64 && _simd_s16x64_cmpge_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cmpge_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_cmpge_
		} else if (S >= 32 && _simd_s16x32_cmpge_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cmpge_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_cmpge_
		} else if (S >= 16 && _simd_s16x16_cmpge_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cmpge_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_cmpge_
		} else if (S >= 8 && _simd_s16x8_cmpge_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cmpge_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_cmpge_
		} else if (S >= 4 && _simd_s16x4_cmpge_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cmpge_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_cmpge_
		} else if (S >= 2 && _simd_s16x2_cmpge_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cmpge_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CMPGE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CMPGE> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_AND> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_and_
		} else if (S >= 64 && _simd_s16x64_and_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_and_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_and_
		} else if (S >= 32 && _simd_s16x32_and_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_and_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_and_
		} else if (S >= 16 && _simd_s16x16_and_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_and_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_and_
		} else if (S >= 8 && _simd_s16x8_and_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_and_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_and_
		} else if (S >= 4 && _simd_s16x4_and_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_and_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_and_
		} else if (S >= 2 && _simd_s16x2_and_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_and_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_AND> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_AND> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_OR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_or_
		} else if (S >= 64 && _simd_s16x64_or_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_or_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_or_
		} else if (S >= 32 && _simd_s16x32_or_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_or_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_or_
		} else if (S >= 16 && _simd_s16x16_or_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_or_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_or_
		} else if (S >= 8 && _simd_s16x8_or_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_or_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_or_
		} else if (S >= 4 && _simd_s16x4_or_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_or_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_or_
		} else if (S >= 2 && _simd_s16x2_or_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_or_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_OR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_OR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_XOR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_xor_
		} else if (S >= 64 && _simd_s16x64_xor_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_xor_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_xor_
		} else if (S >= 32 && _simd_s16x32_xor_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_xor_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_xor_
		} else if (S >= 16 && _simd_s16x16_xor_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_xor_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_xor_
		} else if (S >= 8 && _simd_s16x8_xor_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_xor_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_xor_
		} else if (S >= 4 && _simd_s16x4_xor_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_xor_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_xor_
		} else if (S >= 2 && _simd_s16x2_xor_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_xor_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_XOR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_XOR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_lshift_
		} else if (S >= 64 && _simd_s16x64_lshift_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_lshift_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_lshift_
		} else if (S >= 32 && _simd_s16x32_lshift_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_lshift_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_lshift_
		} else if (S >= 16 && _simd_s16x16_lshift_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_lshift_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_lshift_
		} else if (S >= 8 && _simd_s16x8_lshift_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_lshift_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_lshift_
		} else if (S >= 4 && _simd_s16x4_lshift_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_lshift_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_lshift_
		} else if (S >= 2 && _simd_s16x2_lshift_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_lshift_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_LSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_LSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_RSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_rshift_
		} else if (S >= 64 && _simd_s16x64_rshift_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_rshift_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_rshift_
		} else if (S >= 32 && _simd_s16x32_rshift_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_rshift_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_rshift_
		} else if (S >= 16 && _simd_s16x16_rshift_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_rshift_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_rshift_
		} else if (S >= 8 && _simd_s16x8_rshift_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_rshift_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_rshift_
		} else if (S >= 4 && _simd_s16x4_rshift_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_rshift_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_rshift_
		} else if (S >= 2 && _simd_s16x2_rshift_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_rshift_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_RSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_RSHIFT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ATAN2> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_atan2_
		} else if (S >= 64 && _simd_s16x64_atan2_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_atan2_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_atan2_
		} else if (S >= 32 && _simd_s16x32_atan2_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_atan2_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_atan2_
		} else if (S >= 16 && _simd_s16x16_atan2_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_atan2_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_atan2_
		} else if (S >= 8 && _simd_s16x8_atan2_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_atan2_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_atan2_
		} else if (S >= 4 && _simd_s16x4_atan2_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_atan2_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_atan2_
		} else if (S >= 2 && _simd_s16x2_atan2_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_atan2_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ATAN2> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ATAN2> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_POW> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_pow_
		} else if (S >= 64 && _simd_s16x64_pow_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_pow_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_pow_
		} else if (S >= 32 && _simd_s16x32_pow_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_pow_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_pow_
		} else if (S >= 16 && _simd_s16x16_pow_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_pow_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_pow_
		} else if (S >= 8 && _simd_s16x8_pow_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_pow_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_pow_
		} else if (S >= 4 && _simd_s16x4_pow_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_pow_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_pow_
		} else if (S >= 2 && _simd_s16x2_pow_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_pow_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_POW> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_POW> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_HYPOT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_hypot_
		} else if (S >= 64 && _simd_s16x64_hypot_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_hypot_(_simd_s16x64_load_(x),_simd_s16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s16x32_hypot_
		} else if (S >= 32 && _simd_s16x32_hypot_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_hypot_(_simd_s16x32_load_(x),_simd_s16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s16x16_hypot_
		} else if (S >= 16 && _simd_s16x16_hypot_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_hypot_(_simd_s16x16_load_(x),_simd_s16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s16x8_hypot_
		} else if (S >= 8 && _simd_s16x8_hypot_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_hypot_(_simd_s16x8_load_(x),_simd_s16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s16x4_hypot_
		} else if (S >= 4 && _simd_s16x4_hypot_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_hypot_(_simd_s16x4_load_(x),_simd_s16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s16x2_hypot_
		} else if (S >= 2 && _simd_s16x2_hypot_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_hypot_(_simd_s16x2_load_(x),_simd_s16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_HYPOT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s16x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_HYPOT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_NOT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_not_
		} else if (S >= 64 && _simd_s16x64_not_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_not_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s16x32_not_
		} else if (S >= 32 && _simd_s16x32_not_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_not_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s16x16_not_
		} else if (S >= 16 && _simd_s16x16_not_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_not_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s16x8_not_
		} else if (S >= 8 && _simd_s16x8_not_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_not_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s16x4_not_
		} else if (S >= 4 && _simd_s16x4_not_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_not_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s16x2_not_
		} else if (S >= 2 && _simd_s16x2_not_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_not_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_NOT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_NOT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ABS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_abs_
		} else if (S >= 64 && _simd_s16x64_abs_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_abs_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s16x32_abs_
		} else if (S >= 32 && _simd_s16x32_abs_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_abs_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s16x16_abs_
		} else if (S >= 16 && _simd_s16x16_abs_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_abs_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s16x8_abs_
		} else if (S >= 8 && _simd_s16x8_abs_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_abs_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s16x4_abs_
		} else if (S >= 4 && _simd_s16x4_abs_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_abs_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s16x2_abs_
		} else if (S >= 2 && _simd_s16x2_abs_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_abs_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ABS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ABS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_EXP> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_exp_
		} else if (S >= 64 && _simd_s16x64_exp_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_exp_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s16x32_exp_
		} else if (S >= 32 && _simd_s16x32_exp_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_exp_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s16x16_exp_
		} else if (S >= 16 && _simd_s16x16_exp_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_exp_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s16x8_exp_
		} else if (S >= 8 && _simd_s16x8_exp_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_exp_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s16x4_exp_
		} else if (S >= 4 && _simd_s16x4_exp_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_exp_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s16x2_exp_
		} else if (S >= 2 && _simd_s16x2_exp_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_exp_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_EXP> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_EXP> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log_
		} else if (S >= 64 && _simd_s16x64_log_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_log_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s16x32_log_
		} else if (S >= 32 && _simd_s16x32_log_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_log_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s16x16_log_
		} else if (S >= 16 && _simd_s16x16_log_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_log_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s16x8_log_
		} else if (S >= 8 && _simd_s16x8_log_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_log_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s16x4_log_
		} else if (S >= 4 && _simd_s16x4_log_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_log_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s16x2_log_
		} else if (S >= 2 && _simd_s16x2_log_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_log_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_LOG> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_LOG> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG2> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log2_
		} else if (S >= 64 && _simd_s16x64_log2_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_log2_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s16x32_log2_
		} else if (S >= 32 && _simd_s16x32_log2_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_log2_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s16x16_log2_
		} else if (S >= 16 && _simd_s16x16_log2_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_log2_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s16x8_log2_
		} else if (S >= 8 && _simd_s16x8_log2_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_log2_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s16x4_log2_
		} else if (S >= 4 && _simd_s16x4_log2_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_log2_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s16x2_log2_
		} else if (S >= 2 && _simd_s16x2_log2_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_log2_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_LOG2> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_LOG2> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_LOG10> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_log10_
		} else if (S >= 64 && _simd_s16x64_log10_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_log10_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s16x32_log10_
		} else if (S >= 32 && _simd_s16x32_log10_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_log10_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s16x16_log10_
		} else if (S >= 16 && _simd_s16x16_log10_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_log10_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s16x8_log10_
		} else if (S >= 8 && _simd_s16x8_log10_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_log10_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s16x4_log10_
		} else if (S >= 4 && _simd_s16x4_log10_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_log10_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s16x2_log10_
		} else if (S >= 2 && _simd_s16x2_log10_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_log10_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_LOG10> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_LOG10> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CEIL> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_ceil_
		} else if (S >= 64 && _simd_s16x64_ceil_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_ceil_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s16x32_ceil_
		} else if (S >= 32 && _simd_s16x32_ceil_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_ceil_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s16x16_ceil_
		} else if (S >= 16 && _simd_s16x16_ceil_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_ceil_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s16x8_ceil_
		} else if (S >= 8 && _simd_s16x8_ceil_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_ceil_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s16x4_ceil_
		} else if (S >= 4 && _simd_s16x4_ceil_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_ceil_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s16x2_ceil_
		} else if (S >= 2 && _simd_s16x2_ceil_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_ceil_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CEIL> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CEIL> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_FLOOR> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_floor_
		} else if (S >= 64 && _simd_s16x64_floor_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_floor_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s16x32_floor_
		} else if (S >= 32 && _simd_s16x32_floor_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_floor_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s16x16_floor_
		} else if (S >= 16 && _simd_s16x16_floor_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_floor_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s16x8_floor_
		} else if (S >= 8 && _simd_s16x8_floor_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_floor_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s16x4_floor_
		} else if (S >= 4 && _simd_s16x4_floor_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_floor_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s16x2_floor_
		} else if (S >= 2 && _simd_s16x2_floor_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_floor_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_FLOOR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_FLOOR> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ROUND> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_round_
		} else if (S >= 64 && _simd_s16x64_round_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_round_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s16x32_round_
		} else if (S >= 32 && _simd_s16x32_round_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_round_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s16x16_round_
		} else if (S >= 16 && _simd_s16x16_round_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_round_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s16x8_round_
		} else if (S >= 8 && _simd_s16x8_round_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_round_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s16x4_round_
		} else if (S >= 4 && _simd_s16x4_round_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_round_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s16x2_round_
		} else if (S >= 2 && _simd_s16x2_round_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_round_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ROUND> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ROUND> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sin_
		} else if (S >= 64 && _simd_s16x64_sin_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_sin_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s16x32_sin_
		} else if (S >= 32 && _simd_s16x32_sin_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_sin_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s16x16_sin_
		} else if (S >= 16 && _simd_s16x16_sin_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_sin_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s16x8_sin_
		} else if (S >= 8 && _simd_s16x8_sin_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_sin_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s16x4_sin_
		} else if (S >= 4 && _simd_s16x4_sin_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_sin_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s16x2_sin_
		} else if (S >= 2 && _simd_s16x2_sin_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_sin_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_SIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_SIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_COS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cos_
		} else if (S >= 64 && _simd_s16x64_cos_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cos_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s16x32_cos_
		} else if (S >= 32 && _simd_s16x32_cos_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cos_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s16x16_cos_
		} else if (S >= 16 && _simd_s16x16_cos_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cos_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s16x8_cos_
		} else if (S >= 8 && _simd_s16x8_cos_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cos_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s16x4_cos_
		} else if (S >= 4 && _simd_s16x4_cos_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cos_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s16x2_cos_
		} else if (S >= 2 && _simd_s16x2_cos_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cos_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_COS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_COS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_TAN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_tan_
		} else if (S >= 64 && _simd_s16x64_tan_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_tan_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s16x32_tan_
		} else if (S >= 32 && _simd_s16x32_tan_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_tan_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s16x16_tan_
		} else if (S >= 16 && _simd_s16x16_tan_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_tan_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s16x8_tan_
		} else if (S >= 8 && _simd_s16x8_tan_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_tan_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s16x4_tan_
		} else if (S >= 4 && _simd_s16x4_tan_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_tan_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s16x2_tan_
		} else if (S >= 2 && _simd_s16x2_tan_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_tan_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_TAN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_TAN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ASIN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_asin_
		} else if (S >= 64 && _simd_s16x64_asin_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_asin_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s16x32_asin_
		} else if (S >= 32 && _simd_s16x32_asin_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_asin_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s16x16_asin_
		} else if (S >= 16 && _simd_s16x16_asin_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_asin_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s16x8_asin_
		} else if (S >= 8 && _simd_s16x8_asin_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_asin_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s16x4_asin_
		} else if (S >= 4 && _simd_s16x4_asin_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_asin_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s16x2_asin_
		} else if (S >= 2 && _simd_s16x2_asin_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_asin_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ASIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ASIN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ACOS> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_acos_
		} else if (S >= 64 && _simd_s16x64_acos_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_acos_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s16x32_acos_
		} else if (S >= 32 && _simd_s16x32_acos_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_acos_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s16x16_acos_
		} else if (S >= 16 && _simd_s16x16_acos_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_acos_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s16x8_acos_
		} else if (S >= 8 && _simd_s16x8_acos_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_acos_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s16x4_acos_
		} else if (S >= 4 && _simd_s16x4_acos_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_acos_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s16x2_acos_
		} else if (S >= 2 && _simd_s16x2_acos_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_acos_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ACOS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ACOS> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_ATAN> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_atan_
		} else if (S >= 64 && _simd_s16x64_atan_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_atan_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s16x32_atan_
		} else if (S >= 32 && _simd_s16x32_atan_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_atan_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s16x16_atan_
		} else if (S >= 16 && _simd_s16x16_atan_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_atan_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s16x8_atan_
		} else if (S >= 8 && _simd_s16x8_atan_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_atan_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s16x4_atan_
		} else if (S >= 4 && _simd_s16x4_atan_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_atan_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s16x2_atan_
		} else if (S >= 2 && _simd_s16x2_atan_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_atan_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_ATAN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_ATAN> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SINH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sinh_
		} else if (S >= 64 && _simd_s16x64_sinh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_sinh_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s16x32_sinh_
		} else if (S >= 32 && _simd_s16x32_sinh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_sinh_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s16x16_sinh_
		} else if (S >= 16 && _simd_s16x16_sinh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_sinh_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s16x8_sinh_
		} else if (S >= 8 && _simd_s16x8_sinh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_sinh_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s16x4_sinh_
		} else if (S >= 4 && _simd_s16x4_sinh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_sinh_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s16x2_sinh_
		} else if (S >= 2 && _simd_s16x2_sinh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_sinh_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_SINH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_SINH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_COSH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cosh_
		} else if (S >= 64 && _simd_s16x64_cosh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cosh_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s16x32_cosh_
		} else if (S >= 32 && _simd_s16x32_cosh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cosh_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s16x16_cosh_
		} else if (S >= 16 && _simd_s16x16_cosh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cosh_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s16x8_cosh_
		} else if (S >= 8 && _simd_s16x8_cosh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cosh_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s16x4_cosh_
		} else if (S >= 4 && _simd_s16x4_cosh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cosh_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s16x2_cosh_
		} else if (S >= 2 && _simd_s16x2_cosh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cosh_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_COSH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_COSH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_TANH> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_tanh_
		} else if (S >= 64 && _simd_s16x64_tanh_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_tanh_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s16x32_tanh_
		} else if (S >= 32 && _simd_s16x32_tanh_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_tanh_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s16x16_tanh_
		} else if (S >= 16 && _simd_s16x16_tanh_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_tanh_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s16x8_tanh_
		} else if (S >= 8 && _simd_s16x8_tanh_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_tanh_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s16x4_tanh_
		} else if (S >= 4 && _simd_s16x4_tanh_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_tanh_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s16x2_tanh_
		} else if (S >= 2 && _simd_s16x2_tanh_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_tanh_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_TANH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_TANH> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_SQRT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_sqrt_
		} else if (S >= 64 && _simd_s16x64_sqrt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_sqrt_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s16x32_sqrt_
		} else if (S >= 32 && _simd_s16x32_sqrt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_sqrt_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s16x16_sqrt_
		} else if (S >= 16 && _simd_s16x16_sqrt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_sqrt_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s16x8_sqrt_
		} else if (S >= 8 && _simd_s16x8_sqrt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_sqrt_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s16x4_sqrt_
		} else if (S >= 4 && _simd_s16x4_sqrt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_sqrt_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s16x2_sqrt_
		} else if (S >= 2 && _simd_s16x2_sqrt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_sqrt_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_SQRT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_SQRT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s16x1, S, OP_CBRT> {
	typedef _simd_s16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s16x64_cbrt_
		} else if (S >= 64 && _simd_s16x64_cbrt_enable()) {
			typedef _simd_s16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x64_cbrt_(_simd_s16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s16x32_cbrt_
		} else if (S >= 32 && _simd_s16x32_cbrt_enable()) {
			typedef _simd_s16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x32_cbrt_(_simd_s16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s16x16_cbrt_
		} else if (S >= 16 && _simd_s16x16_cbrt_enable()) {
			typedef _simd_s16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x16_cbrt_(_simd_s16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s16x8_cbrt_
		} else if (S >= 8 && _simd_s16x8_cbrt_enable()) {
			typedef _simd_s16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x8_cbrt_(_simd_s16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s16x4_cbrt_
		} else if (S >= 4 && _simd_s16x4_cbrt_enable()) {
			typedef _simd_s16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x4_cbrt_(_simd_s16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s16x2_cbrt_
		} else if (S >= 2 && _simd_s16x2_cbrt_enable()) {
			typedef _simd_s16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s16x2_cbrt_(_simd_s16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s16x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 1, OP_CBRT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s16x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s16x1, 0, OP_CBRT> {
	typedef _simd_s16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S,OP_SUM> {
	typedef _simd_u16x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_add_
		} else if (S >= 64 && _simd_u16x64_add_enable()) {
			typedef _simd_u16x64 simd_t;
			simd_t tmp = _simd_u16x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x64_add_(tmp, _simd_u16x64_load_(o)); 
				o += 64;
			}
			return _simd_u16x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u16x32_add_
		} else if (S >= 32 && _simd_u16x32_add_enable()) {
			typedef _simd_u16x32 simd_t;
			simd_t tmp = _simd_u16x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x32_add_(tmp, _simd_u16x32_load_(o)); 
				o += 32;
			}
			return _simd_u16x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u16x16_add_
		} else if (S >= 16 && _simd_u16x16_add_enable()) {
			typedef _simd_u16x16 simd_t;
			simd_t tmp = _simd_u16x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x16_add_(tmp, _simd_u16x16_load_(o)); 
				o += 16;
			}
			return _simd_u16x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u16x8_add_
		} else if (S >= 8 && _simd_u16x8_add_enable()) {
			typedef _simd_u16x8 simd_t;
			simd_t tmp = _simd_u16x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x8_add_(tmp, _simd_u16x8_load_(o)); 
				o += 8;
			}
			return _simd_u16x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u16x4_add_
		} else if (S >= 4 && _simd_u16x4_add_enable()) {
			typedef _simd_u16x4 simd_t;
			simd_t tmp = _simd_u16x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x4_add_(tmp, _simd_u16x4_load_(o)); 
				o += 4;
			}
			return _simd_u16x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u16x2_add_
		} else if (S >= 2 && _simd_u16x2_add_enable()) {
			typedef _simd_u16x2 simd_t;
			simd_t tmp = _simd_u16x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u16x2_add_(tmp, _simd_u16x2_load_(o)); 
				o += 2;
			}
			return _simd_u16x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1,OP_SUM> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0,OP_SUM> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FILL0> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fill_zero_
		} else if (S >= 64 && _simd_u16x64_fill_zero_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u16x32_fill_zero_
		} else if (S >= 32 && _simd_u16x32_fill_zero_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u16x16_fill_zero_
		} else if (S >= 16 && _simd_u16x16_fill_zero_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u16x8_fill_zero_
		} else if (S >= 8 && _simd_u16x8_fill_zero_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u16x4_fill_zero_
		} else if (S >= 4 && _simd_u16x4_fill_zero_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u16x2_fill_zero_
		} else if (S >= 2 && _simd_u16x2_fill_zero_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FILLU> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FILLS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fill_scalar_
		} else if (S >= 64 && _simd_u16x64_fill_scalar_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u16x32_fill_scalar_
		} else if (S >= 32 && _simd_u16x32_fill_scalar_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u16x16_fill_scalar_
		} else if (S >= 16 && _simd_u16x16_fill_scalar_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u16x8_fill_scalar_
		} else if (S >= 8 && _simd_u16x8_fill_scalar_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u16x4_fill_scalar_
		} else if (S >= 4 && _simd_u16x4_fill_scalar_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u16x2_fill_scalar_
		} else if (S >= 2 && _simd_u16x2_fill_scalar_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FMA> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fma_
		} else if (S >= 64 && _simd_u16x64_fma_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_fma_(_simd_u16x64_load_(x),_simd_u16x64_load_(y),_simd_u16x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x32_fma_
		} else if (S >= 32 && _simd_u16x32_fma_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_fma_(_simd_u16x32_load_(x),_simd_u16x32_load_(y),_simd_u16x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x16_fma_
		} else if (S >= 16 && _simd_u16x16_fma_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_fma_(_simd_u16x16_load_(x),_simd_u16x16_load_(y),_simd_u16x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x8_fma_
		} else if (S >= 8 && _simd_u16x8_fma_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_fma_(_simd_u16x8_load_(x),_simd_u16x8_load_(y),_simd_u16x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x4_fma_
		} else if (S >= 4 && _simd_u16x4_fma_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_fma_(_simd_u16x4_load_(x),_simd_u16x4_load_(y),_simd_u16x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x2_fma_
		} else if (S >= 2 && _simd_u16x2_fma_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_fma_(_simd_u16x2_load_(x),_simd_u16x2_load_(y),_simd_u16x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_FMA> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u16x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_FMA> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FMS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_fms_
		} else if (S >= 64 && _simd_u16x64_fms_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_fms_(_simd_u16x64_load_(x),_simd_u16x64_load_(y),_simd_u16x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x32_fms_
		} else if (S >= 32 && _simd_u16x32_fms_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_fms_(_simd_u16x32_load_(x),_simd_u16x32_load_(y),_simd_u16x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x16_fms_
		} else if (S >= 16 && _simd_u16x16_fms_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_fms_(_simd_u16x16_load_(x),_simd_u16x16_load_(y),_simd_u16x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x8_fms_
		} else if (S >= 8 && _simd_u16x8_fms_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_fms_(_simd_u16x8_load_(x),_simd_u16x8_load_(y),_simd_u16x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x4_fms_
		} else if (S >= 4 && _simd_u16x4_fms_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_fms_(_simd_u16x4_load_(x),_simd_u16x4_load_(y),_simd_u16x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u16x2_fms_
		} else if (S >= 2 && _simd_u16x2_fms_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_fms_(_simd_u16x2_load_(x),_simd_u16x2_load_(y),_simd_u16x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_FMS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u16x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_FMS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ADD> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_add_
		} else if (S >= 64 && _simd_u16x64_add_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_add_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_add_
		} else if (S >= 32 && _simd_u16x32_add_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_add_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_add_
		} else if (S >= 16 && _simd_u16x16_add_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_add_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_add_
		} else if (S >= 8 && _simd_u16x8_add_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_add_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_add_
		} else if (S >= 4 && _simd_u16x4_add_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_add_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_add_
		} else if (S >= 2 && _simd_u16x2_add_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_add_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ADD> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ADD> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SUB> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sub_
		} else if (S >= 64 && _simd_u16x64_sub_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_sub_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_sub_
		} else if (S >= 32 && _simd_u16x32_sub_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_sub_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_sub_
		} else if (S >= 16 && _simd_u16x16_sub_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_sub_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_sub_
		} else if (S >= 8 && _simd_u16x8_sub_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_sub_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_sub_
		} else if (S >= 4 && _simd_u16x4_sub_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_sub_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_sub_
		} else if (S >= 2 && _simd_u16x2_sub_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_sub_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_SUB> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_SUB> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MUL> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_mul_
		} else if (S >= 64 && _simd_u16x64_mul_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_mul_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_mul_
		} else if (S >= 32 && _simd_u16x32_mul_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_mul_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_mul_
		} else if (S >= 16 && _simd_u16x16_mul_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_mul_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_mul_
		} else if (S >= 8 && _simd_u16x8_mul_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_mul_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_mul_
		} else if (S >= 4 && _simd_u16x4_mul_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_mul_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_mul_
		} else if (S >= 2 && _simd_u16x2_mul_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_mul_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_MUL> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_MUL> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_DIV> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_div_
		} else if (S >= 64 && _simd_u16x64_div_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_div_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_div_
		} else if (S >= 32 && _simd_u16x32_div_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_div_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_div_
		} else if (S >= 16 && _simd_u16x16_div_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_div_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_div_
		} else if (S >= 8 && _simd_u16x8_div_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_div_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_div_
		} else if (S >= 4 && _simd_u16x4_div_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_div_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_div_
		} else if (S >= 2 && _simd_u16x2_div_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_div_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_DIV> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_DIV> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_min_
		} else if (S >= 64 && _simd_u16x64_min_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_min_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_min_
		} else if (S >= 32 && _simd_u16x32_min_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_min_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_min_
		} else if (S >= 16 && _simd_u16x16_min_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_min_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_min_
		} else if (S >= 8 && _simd_u16x8_min_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_min_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_min_
		} else if (S >= 4 && _simd_u16x4_min_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_min_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_min_
		} else if (S >= 2 && _simd_u16x2_min_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_min_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_MIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_MIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_MAX> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_max_
		} else if (S >= 64 && _simd_u16x64_max_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_max_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_max_
		} else if (S >= 32 && _simd_u16x32_max_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_max_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_max_
		} else if (S >= 16 && _simd_u16x16_max_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_max_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_max_
		} else if (S >= 8 && _simd_u16x8_max_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_max_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_max_
		} else if (S >= 4 && _simd_u16x4_max_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_max_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_max_
		} else if (S >= 2 && _simd_u16x2_max_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_max_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_MAX> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_MAX> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPEQ> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpeq_
		} else if (S >= 64 && _simd_u16x64_cmpeq_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmpeq_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmpeq_
		} else if (S >= 32 && _simd_u16x32_cmpeq_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmpeq_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmpeq_
		} else if (S >= 16 && _simd_u16x16_cmpeq_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmpeq_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmpeq_
		} else if (S >= 8 && _simd_u16x8_cmpeq_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmpeq_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmpeq_
		} else if (S >= 4 && _simd_u16x4_cmpeq_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmpeq_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmpeq_
		} else if (S >= 2 && _simd_u16x2_cmpeq_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmpeq_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPEQ> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPEQ> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPNE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpne_
		} else if (S >= 64 && _simd_u16x64_cmpne_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmpne_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmpne_
		} else if (S >= 32 && _simd_u16x32_cmpne_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmpne_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmpne_
		} else if (S >= 16 && _simd_u16x16_cmpne_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmpne_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmpne_
		} else if (S >= 8 && _simd_u16x8_cmpne_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmpne_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmpne_
		} else if (S >= 4 && _simd_u16x4_cmpne_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmpne_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmpne_
		} else if (S >= 2 && _simd_u16x2_cmpne_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmpne_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPNE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPNE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPLT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmplt_
		} else if (S >= 64 && _simd_u16x64_cmplt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmplt_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmplt_
		} else if (S >= 32 && _simd_u16x32_cmplt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmplt_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmplt_
		} else if (S >= 16 && _simd_u16x16_cmplt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmplt_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmplt_
		} else if (S >= 8 && _simd_u16x8_cmplt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmplt_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmplt_
		} else if (S >= 4 && _simd_u16x4_cmplt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmplt_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmplt_
		} else if (S >= 2 && _simd_u16x2_cmplt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmplt_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPLT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPLT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPGT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpgt_
		} else if (S >= 64 && _simd_u16x64_cmpgt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmpgt_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmpgt_
		} else if (S >= 32 && _simd_u16x32_cmpgt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmpgt_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmpgt_
		} else if (S >= 16 && _simd_u16x16_cmpgt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmpgt_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmpgt_
		} else if (S >= 8 && _simd_u16x8_cmpgt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmpgt_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmpgt_
		} else if (S >= 4 && _simd_u16x4_cmpgt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmpgt_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmpgt_
		} else if (S >= 2 && _simd_u16x2_cmpgt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmpgt_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPGT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPGT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPLE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmple_
		} else if (S >= 64 && _simd_u16x64_cmple_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmple_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmple_
		} else if (S >= 32 && _simd_u16x32_cmple_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmple_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmple_
		} else if (S >= 16 && _simd_u16x16_cmple_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmple_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmple_
		} else if (S >= 8 && _simd_u16x8_cmple_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmple_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmple_
		} else if (S >= 4 && _simd_u16x4_cmple_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmple_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmple_
		} else if (S >= 2 && _simd_u16x2_cmple_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmple_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPLE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPLE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CMPGE> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cmpge_
		} else if (S >= 64 && _simd_u16x64_cmpge_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cmpge_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_cmpge_
		} else if (S >= 32 && _simd_u16x32_cmpge_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cmpge_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_cmpge_
		} else if (S >= 16 && _simd_u16x16_cmpge_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cmpge_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_cmpge_
		} else if (S >= 8 && _simd_u16x8_cmpge_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cmpge_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_cmpge_
		} else if (S >= 4 && _simd_u16x4_cmpge_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cmpge_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_cmpge_
		} else if (S >= 2 && _simd_u16x2_cmpge_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cmpge_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CMPGE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CMPGE> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_AND> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_and_
		} else if (S >= 64 && _simd_u16x64_and_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_and_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_and_
		} else if (S >= 32 && _simd_u16x32_and_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_and_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_and_
		} else if (S >= 16 && _simd_u16x16_and_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_and_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_and_
		} else if (S >= 8 && _simd_u16x8_and_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_and_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_and_
		} else if (S >= 4 && _simd_u16x4_and_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_and_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_and_
		} else if (S >= 2 && _simd_u16x2_and_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_and_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_AND> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_AND> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_OR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_or_
		} else if (S >= 64 && _simd_u16x64_or_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_or_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_or_
		} else if (S >= 32 && _simd_u16x32_or_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_or_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_or_
		} else if (S >= 16 && _simd_u16x16_or_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_or_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_or_
		} else if (S >= 8 && _simd_u16x8_or_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_or_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_or_
		} else if (S >= 4 && _simd_u16x4_or_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_or_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_or_
		} else if (S >= 2 && _simd_u16x2_or_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_or_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_OR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_OR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_XOR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_xor_
		} else if (S >= 64 && _simd_u16x64_xor_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_xor_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_xor_
		} else if (S >= 32 && _simd_u16x32_xor_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_xor_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_xor_
		} else if (S >= 16 && _simd_u16x16_xor_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_xor_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_xor_
		} else if (S >= 8 && _simd_u16x8_xor_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_xor_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_xor_
		} else if (S >= 4 && _simd_u16x4_xor_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_xor_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_xor_
		} else if (S >= 2 && _simd_u16x2_xor_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_xor_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_XOR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_XOR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_lshift_
		} else if (S >= 64 && _simd_u16x64_lshift_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_lshift_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_lshift_
		} else if (S >= 32 && _simd_u16x32_lshift_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_lshift_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_lshift_
		} else if (S >= 16 && _simd_u16x16_lshift_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_lshift_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_lshift_
		} else if (S >= 8 && _simd_u16x8_lshift_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_lshift_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_lshift_
		} else if (S >= 4 && _simd_u16x4_lshift_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_lshift_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_lshift_
		} else if (S >= 2 && _simd_u16x2_lshift_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_lshift_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_LSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_LSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_RSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_rshift_
		} else if (S >= 64 && _simd_u16x64_rshift_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_rshift_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_rshift_
		} else if (S >= 32 && _simd_u16x32_rshift_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_rshift_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_rshift_
		} else if (S >= 16 && _simd_u16x16_rshift_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_rshift_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_rshift_
		} else if (S >= 8 && _simd_u16x8_rshift_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_rshift_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_rshift_
		} else if (S >= 4 && _simd_u16x4_rshift_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_rshift_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_rshift_
		} else if (S >= 2 && _simd_u16x2_rshift_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_rshift_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_RSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_RSHIFT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ATAN2> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_atan2_
		} else if (S >= 64 && _simd_u16x64_atan2_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_atan2_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_atan2_
		} else if (S >= 32 && _simd_u16x32_atan2_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_atan2_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_atan2_
		} else if (S >= 16 && _simd_u16x16_atan2_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_atan2_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_atan2_
		} else if (S >= 8 && _simd_u16x8_atan2_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_atan2_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_atan2_
		} else if (S >= 4 && _simd_u16x4_atan2_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_atan2_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_atan2_
		} else if (S >= 2 && _simd_u16x2_atan2_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_atan2_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ATAN2> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ATAN2> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_POW> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_pow_
		} else if (S >= 64 && _simd_u16x64_pow_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_pow_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_pow_
		} else if (S >= 32 && _simd_u16x32_pow_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_pow_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_pow_
		} else if (S >= 16 && _simd_u16x16_pow_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_pow_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_pow_
		} else if (S >= 8 && _simd_u16x8_pow_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_pow_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_pow_
		} else if (S >= 4 && _simd_u16x4_pow_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_pow_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_pow_
		} else if (S >= 2 && _simd_u16x2_pow_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_pow_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_POW> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_POW> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_HYPOT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_hypot_
		} else if (S >= 64 && _simd_u16x64_hypot_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_hypot_(_simd_u16x64_load_(x),_simd_u16x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u16x32_hypot_
		} else if (S >= 32 && _simd_u16x32_hypot_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_hypot_(_simd_u16x32_load_(x),_simd_u16x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u16x16_hypot_
		} else if (S >= 16 && _simd_u16x16_hypot_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_hypot_(_simd_u16x16_load_(x),_simd_u16x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u16x8_hypot_
		} else if (S >= 8 && _simd_u16x8_hypot_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_hypot_(_simd_u16x8_load_(x),_simd_u16x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u16x4_hypot_
		} else if (S >= 4 && _simd_u16x4_hypot_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_hypot_(_simd_u16x4_load_(x),_simd_u16x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u16x2_hypot_
		} else if (S >= 2 && _simd_u16x2_hypot_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_hypot_(_simd_u16x2_load_(x),_simd_u16x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_HYPOT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u16x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_HYPOT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_NOT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_not_
		} else if (S >= 64 && _simd_u16x64_not_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_not_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u16x32_not_
		} else if (S >= 32 && _simd_u16x32_not_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_not_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u16x16_not_
		} else if (S >= 16 && _simd_u16x16_not_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_not_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u16x8_not_
		} else if (S >= 8 && _simd_u16x8_not_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_not_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u16x4_not_
		} else if (S >= 4 && _simd_u16x4_not_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_not_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u16x2_not_
		} else if (S >= 2 && _simd_u16x2_not_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_not_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_NOT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_NOT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ABS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_abs_
		} else if (S >= 64 && _simd_u16x64_abs_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_abs_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u16x32_abs_
		} else if (S >= 32 && _simd_u16x32_abs_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_abs_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u16x16_abs_
		} else if (S >= 16 && _simd_u16x16_abs_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_abs_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u16x8_abs_
		} else if (S >= 8 && _simd_u16x8_abs_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_abs_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u16x4_abs_
		} else if (S >= 4 && _simd_u16x4_abs_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_abs_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u16x2_abs_
		} else if (S >= 2 && _simd_u16x2_abs_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_abs_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ABS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ABS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_EXP> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_exp_
		} else if (S >= 64 && _simd_u16x64_exp_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_exp_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u16x32_exp_
		} else if (S >= 32 && _simd_u16x32_exp_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_exp_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u16x16_exp_
		} else if (S >= 16 && _simd_u16x16_exp_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_exp_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u16x8_exp_
		} else if (S >= 8 && _simd_u16x8_exp_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_exp_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u16x4_exp_
		} else if (S >= 4 && _simd_u16x4_exp_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_exp_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u16x2_exp_
		} else if (S >= 2 && _simd_u16x2_exp_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_exp_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_EXP> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_EXP> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log_
		} else if (S >= 64 && _simd_u16x64_log_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_log_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u16x32_log_
		} else if (S >= 32 && _simd_u16x32_log_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_log_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u16x16_log_
		} else if (S >= 16 && _simd_u16x16_log_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_log_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u16x8_log_
		} else if (S >= 8 && _simd_u16x8_log_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_log_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u16x4_log_
		} else if (S >= 4 && _simd_u16x4_log_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_log_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u16x2_log_
		} else if (S >= 2 && _simd_u16x2_log_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_log_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_LOG> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_LOG> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG2> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log2_
		} else if (S >= 64 && _simd_u16x64_log2_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_log2_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u16x32_log2_
		} else if (S >= 32 && _simd_u16x32_log2_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_log2_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u16x16_log2_
		} else if (S >= 16 && _simd_u16x16_log2_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_log2_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u16x8_log2_
		} else if (S >= 8 && _simd_u16x8_log2_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_log2_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u16x4_log2_
		} else if (S >= 4 && _simd_u16x4_log2_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_log2_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u16x2_log2_
		} else if (S >= 2 && _simd_u16x2_log2_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_log2_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_LOG2> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_LOG2> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_LOG10> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_log10_
		} else if (S >= 64 && _simd_u16x64_log10_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_log10_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u16x32_log10_
		} else if (S >= 32 && _simd_u16x32_log10_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_log10_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u16x16_log10_
		} else if (S >= 16 && _simd_u16x16_log10_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_log10_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u16x8_log10_
		} else if (S >= 8 && _simd_u16x8_log10_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_log10_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u16x4_log10_
		} else if (S >= 4 && _simd_u16x4_log10_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_log10_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u16x2_log10_
		} else if (S >= 2 && _simd_u16x2_log10_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_log10_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_LOG10> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_LOG10> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CEIL> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_ceil_
		} else if (S >= 64 && _simd_u16x64_ceil_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_ceil_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u16x32_ceil_
		} else if (S >= 32 && _simd_u16x32_ceil_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_ceil_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u16x16_ceil_
		} else if (S >= 16 && _simd_u16x16_ceil_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_ceil_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u16x8_ceil_
		} else if (S >= 8 && _simd_u16x8_ceil_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_ceil_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u16x4_ceil_
		} else if (S >= 4 && _simd_u16x4_ceil_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_ceil_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u16x2_ceil_
		} else if (S >= 2 && _simd_u16x2_ceil_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_ceil_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CEIL> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CEIL> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_FLOOR> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_floor_
		} else if (S >= 64 && _simd_u16x64_floor_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_floor_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u16x32_floor_
		} else if (S >= 32 && _simd_u16x32_floor_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_floor_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u16x16_floor_
		} else if (S >= 16 && _simd_u16x16_floor_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_floor_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u16x8_floor_
		} else if (S >= 8 && _simd_u16x8_floor_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_floor_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u16x4_floor_
		} else if (S >= 4 && _simd_u16x4_floor_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_floor_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u16x2_floor_
		} else if (S >= 2 && _simd_u16x2_floor_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_floor_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_FLOOR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_FLOOR> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ROUND> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_round_
		} else if (S >= 64 && _simd_u16x64_round_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_round_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u16x32_round_
		} else if (S >= 32 && _simd_u16x32_round_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_round_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u16x16_round_
		} else if (S >= 16 && _simd_u16x16_round_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_round_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u16x8_round_
		} else if (S >= 8 && _simd_u16x8_round_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_round_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u16x4_round_
		} else if (S >= 4 && _simd_u16x4_round_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_round_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u16x2_round_
		} else if (S >= 2 && _simd_u16x2_round_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_round_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ROUND> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ROUND> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sin_
		} else if (S >= 64 && _simd_u16x64_sin_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_sin_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u16x32_sin_
		} else if (S >= 32 && _simd_u16x32_sin_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_sin_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u16x16_sin_
		} else if (S >= 16 && _simd_u16x16_sin_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_sin_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u16x8_sin_
		} else if (S >= 8 && _simd_u16x8_sin_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_sin_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u16x4_sin_
		} else if (S >= 4 && _simd_u16x4_sin_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_sin_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u16x2_sin_
		} else if (S >= 2 && _simd_u16x2_sin_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_sin_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_SIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_SIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_COS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cos_
		} else if (S >= 64 && _simd_u16x64_cos_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cos_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u16x32_cos_
		} else if (S >= 32 && _simd_u16x32_cos_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cos_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u16x16_cos_
		} else if (S >= 16 && _simd_u16x16_cos_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cos_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u16x8_cos_
		} else if (S >= 8 && _simd_u16x8_cos_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cos_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u16x4_cos_
		} else if (S >= 4 && _simd_u16x4_cos_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cos_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u16x2_cos_
		} else if (S >= 2 && _simd_u16x2_cos_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cos_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_COS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_COS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_TAN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_tan_
		} else if (S >= 64 && _simd_u16x64_tan_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_tan_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u16x32_tan_
		} else if (S >= 32 && _simd_u16x32_tan_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_tan_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u16x16_tan_
		} else if (S >= 16 && _simd_u16x16_tan_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_tan_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u16x8_tan_
		} else if (S >= 8 && _simd_u16x8_tan_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_tan_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u16x4_tan_
		} else if (S >= 4 && _simd_u16x4_tan_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_tan_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u16x2_tan_
		} else if (S >= 2 && _simd_u16x2_tan_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_tan_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_TAN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_TAN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ASIN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_asin_
		} else if (S >= 64 && _simd_u16x64_asin_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_asin_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u16x32_asin_
		} else if (S >= 32 && _simd_u16x32_asin_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_asin_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u16x16_asin_
		} else if (S >= 16 && _simd_u16x16_asin_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_asin_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u16x8_asin_
		} else if (S >= 8 && _simd_u16x8_asin_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_asin_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u16x4_asin_
		} else if (S >= 4 && _simd_u16x4_asin_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_asin_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u16x2_asin_
		} else if (S >= 2 && _simd_u16x2_asin_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_asin_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ASIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ASIN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ACOS> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_acos_
		} else if (S >= 64 && _simd_u16x64_acos_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_acos_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u16x32_acos_
		} else if (S >= 32 && _simd_u16x32_acos_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_acos_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u16x16_acos_
		} else if (S >= 16 && _simd_u16x16_acos_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_acos_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u16x8_acos_
		} else if (S >= 8 && _simd_u16x8_acos_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_acos_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u16x4_acos_
		} else if (S >= 4 && _simd_u16x4_acos_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_acos_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u16x2_acos_
		} else if (S >= 2 && _simd_u16x2_acos_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_acos_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ACOS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ACOS> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_ATAN> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_atan_
		} else if (S >= 64 && _simd_u16x64_atan_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_atan_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u16x32_atan_
		} else if (S >= 32 && _simd_u16x32_atan_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_atan_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u16x16_atan_
		} else if (S >= 16 && _simd_u16x16_atan_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_atan_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u16x8_atan_
		} else if (S >= 8 && _simd_u16x8_atan_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_atan_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u16x4_atan_
		} else if (S >= 4 && _simd_u16x4_atan_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_atan_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u16x2_atan_
		} else if (S >= 2 && _simd_u16x2_atan_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_atan_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_ATAN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_ATAN> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SINH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sinh_
		} else if (S >= 64 && _simd_u16x64_sinh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_sinh_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u16x32_sinh_
		} else if (S >= 32 && _simd_u16x32_sinh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_sinh_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u16x16_sinh_
		} else if (S >= 16 && _simd_u16x16_sinh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_sinh_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u16x8_sinh_
		} else if (S >= 8 && _simd_u16x8_sinh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_sinh_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u16x4_sinh_
		} else if (S >= 4 && _simd_u16x4_sinh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_sinh_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u16x2_sinh_
		} else if (S >= 2 && _simd_u16x2_sinh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_sinh_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_SINH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_SINH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_COSH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cosh_
		} else if (S >= 64 && _simd_u16x64_cosh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cosh_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u16x32_cosh_
		} else if (S >= 32 && _simd_u16x32_cosh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cosh_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u16x16_cosh_
		} else if (S >= 16 && _simd_u16x16_cosh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cosh_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u16x8_cosh_
		} else if (S >= 8 && _simd_u16x8_cosh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cosh_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u16x4_cosh_
		} else if (S >= 4 && _simd_u16x4_cosh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cosh_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u16x2_cosh_
		} else if (S >= 2 && _simd_u16x2_cosh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cosh_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_COSH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_COSH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_TANH> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_tanh_
		} else if (S >= 64 && _simd_u16x64_tanh_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_tanh_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u16x32_tanh_
		} else if (S >= 32 && _simd_u16x32_tanh_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_tanh_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u16x16_tanh_
		} else if (S >= 16 && _simd_u16x16_tanh_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_tanh_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u16x8_tanh_
		} else if (S >= 8 && _simd_u16x8_tanh_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_tanh_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u16x4_tanh_
		} else if (S >= 4 && _simd_u16x4_tanh_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_tanh_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u16x2_tanh_
		} else if (S >= 2 && _simd_u16x2_tanh_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_tanh_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_TANH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_TANH> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_SQRT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_sqrt_
		} else if (S >= 64 && _simd_u16x64_sqrt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_sqrt_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u16x32_sqrt_
		} else if (S >= 32 && _simd_u16x32_sqrt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_sqrt_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u16x16_sqrt_
		} else if (S >= 16 && _simd_u16x16_sqrt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_sqrt_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u16x8_sqrt_
		} else if (S >= 8 && _simd_u16x8_sqrt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_sqrt_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u16x4_sqrt_
		} else if (S >= 4 && _simd_u16x4_sqrt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_sqrt_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u16x2_sqrt_
		} else if (S >= 2 && _simd_u16x2_sqrt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_sqrt_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_SQRT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_SQRT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u16x1, S, OP_CBRT> {
	typedef _simd_u16x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u16x64_cbrt_
		} else if (S >= 64 && _simd_u16x64_cbrt_enable()) {
			typedef _simd_u16x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x64_cbrt_(_simd_u16x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u16x32_cbrt_
		} else if (S >= 32 && _simd_u16x32_cbrt_enable()) {
			typedef _simd_u16x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x32_cbrt_(_simd_u16x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u16x16_cbrt_
		} else if (S >= 16 && _simd_u16x16_cbrt_enable()) {
			typedef _simd_u16x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x16_cbrt_(_simd_u16x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u16x8_cbrt_
		} else if (S >= 8 && _simd_u16x8_cbrt_enable()) {
			typedef _simd_u16x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x8_cbrt_(_simd_u16x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u16x4_cbrt_
		} else if (S >= 4 && _simd_u16x4_cbrt_enable()) {
			typedef _simd_u16x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x4_cbrt_(_simd_u16x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u16x2_cbrt_
		} else if (S >= 2 && _simd_u16x2_cbrt_enable()) {
			typedef _simd_u16x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u16x2_cbrt_(_simd_u16x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u16x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 1, OP_CBRT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u16x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u16x1, 0, OP_CBRT> {
	typedef _simd_u16x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S,OP_SUM> {
	typedef _simd_s8x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_add_
		} else if (S >= 64 && _simd_s8x64_add_enable()) {
			typedef _simd_s8x64 simd_t;
			simd_t tmp = _simd_s8x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x64_add_(tmp, _simd_s8x64_load_(o)); 
				o += 64;
			}
			return _simd_s8x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s8x32_add_
		} else if (S >= 32 && _simd_s8x32_add_enable()) {
			typedef _simd_s8x32 simd_t;
			simd_t tmp = _simd_s8x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x32_add_(tmp, _simd_s8x32_load_(o)); 
				o += 32;
			}
			return _simd_s8x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s8x16_add_
		} else if (S >= 16 && _simd_s8x16_add_enable()) {
			typedef _simd_s8x16 simd_t;
			simd_t tmp = _simd_s8x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x16_add_(tmp, _simd_s8x16_load_(o)); 
				o += 16;
			}
			return _simd_s8x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s8x8_add_
		} else if (S >= 8 && _simd_s8x8_add_enable()) {
			typedef _simd_s8x8 simd_t;
			simd_t tmp = _simd_s8x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x8_add_(tmp, _simd_s8x8_load_(o)); 
				o += 8;
			}
			return _simd_s8x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s8x4_add_
		} else if (S >= 4 && _simd_s8x4_add_enable()) {
			typedef _simd_s8x4 simd_t;
			simd_t tmp = _simd_s8x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x4_add_(tmp, _simd_s8x4_load_(o)); 
				o += 4;
			}
			return _simd_s8x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_s8x2_add_
		} else if (S >= 2 && _simd_s8x2_add_enable()) {
			typedef _simd_s8x2 simd_t;
			simd_t tmp = _simd_s8x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_s8x2_add_(tmp, _simd_s8x2_load_(o)); 
				o += 2;
			}
			return _simd_s8x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1,OP_SUM> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0,OP_SUM> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FILL0> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fill_zero_
		} else if (S >= 64 && _simd_s8x64_fill_zero_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s8x32_fill_zero_
		} else if (S >= 32 && _simd_s8x32_fill_zero_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s8x16_fill_zero_
		} else if (S >= 16 && _simd_s8x16_fill_zero_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s8x8_fill_zero_
		} else if (S >= 8 && _simd_s8x8_fill_zero_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s8x4_fill_zero_
		} else if (S >= 4 && _simd_s8x4_fill_zero_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_s8x2_fill_zero_
		} else if (S >= 2 && _simd_s8x2_fill_zero_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FILLU> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FILLS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fill_scalar_
		} else if (S >= 64 && _simd_s8x64_fill_scalar_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s8x32_fill_scalar_
		} else if (S >= 32 && _simd_s8x32_fill_scalar_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s8x16_fill_scalar_
		} else if (S >= 16 && _simd_s8x16_fill_scalar_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s8x8_fill_scalar_
		} else if (S >= 8 && _simd_s8x8_fill_scalar_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s8x4_fill_scalar_
		} else if (S >= 4 && _simd_s8x4_fill_scalar_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_s8x2_fill_scalar_
		} else if (S >= 2 && _simd_s8x2_fill_scalar_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FMA> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fma_
		} else if (S >= 64 && _simd_s8x64_fma_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_fma_(_simd_s8x64_load_(x),_simd_s8x64_load_(y),_simd_s8x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x32_fma_
		} else if (S >= 32 && _simd_s8x32_fma_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_fma_(_simd_s8x32_load_(x),_simd_s8x32_load_(y),_simd_s8x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x16_fma_
		} else if (S >= 16 && _simd_s8x16_fma_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_fma_(_simd_s8x16_load_(x),_simd_s8x16_load_(y),_simd_s8x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x8_fma_
		} else if (S >= 8 && _simd_s8x8_fma_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_fma_(_simd_s8x8_load_(x),_simd_s8x8_load_(y),_simd_s8x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x4_fma_
		} else if (S >= 4 && _simd_s8x4_fma_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_fma_(_simd_s8x4_load_(x),_simd_s8x4_load_(y),_simd_s8x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x2_fma_
		} else if (S >= 2 && _simd_s8x2_fma_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_fma_(_simd_s8x2_load_(x),_simd_s8x2_load_(y),_simd_s8x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_FMA> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s8x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_FMA> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FMS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_fms_
		} else if (S >= 64 && _simd_s8x64_fms_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_fms_(_simd_s8x64_load_(x),_simd_s8x64_load_(y),_simd_s8x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x32_fms_
		} else if (S >= 32 && _simd_s8x32_fms_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_fms_(_simd_s8x32_load_(x),_simd_s8x32_load_(y),_simd_s8x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x16_fms_
		} else if (S >= 16 && _simd_s8x16_fms_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_fms_(_simd_s8x16_load_(x),_simd_s8x16_load_(y),_simd_s8x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x8_fms_
		} else if (S >= 8 && _simd_s8x8_fms_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_fms_(_simd_s8x8_load_(x),_simd_s8x8_load_(y),_simd_s8x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x4_fms_
		} else if (S >= 4 && _simd_s8x4_fms_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_fms_(_simd_s8x4_load_(x),_simd_s8x4_load_(y),_simd_s8x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_s8x2_fms_
		} else if (S >= 2 && _simd_s8x2_fms_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_fms_(_simd_s8x2_load_(x),_simd_s8x2_load_(y),_simd_s8x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_FMS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_s8x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_FMS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ADD> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_add_
		} else if (S >= 64 && _simd_s8x64_add_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_add_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_add_
		} else if (S >= 32 && _simd_s8x32_add_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_add_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_add_
		} else if (S >= 16 && _simd_s8x16_add_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_add_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_add_
		} else if (S >= 8 && _simd_s8x8_add_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_add_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_add_
		} else if (S >= 4 && _simd_s8x4_add_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_add_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_add_
		} else if (S >= 2 && _simd_s8x2_add_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_add_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ADD> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ADD> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SUB> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sub_
		} else if (S >= 64 && _simd_s8x64_sub_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_sub_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_sub_
		} else if (S >= 32 && _simd_s8x32_sub_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_sub_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_sub_
		} else if (S >= 16 && _simd_s8x16_sub_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_sub_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_sub_
		} else if (S >= 8 && _simd_s8x8_sub_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_sub_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_sub_
		} else if (S >= 4 && _simd_s8x4_sub_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_sub_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_sub_
		} else if (S >= 2 && _simd_s8x2_sub_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_sub_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_SUB> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_SUB> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MUL> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_mul_
		} else if (S >= 64 && _simd_s8x64_mul_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_mul_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_mul_
		} else if (S >= 32 && _simd_s8x32_mul_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_mul_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_mul_
		} else if (S >= 16 && _simd_s8x16_mul_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_mul_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_mul_
		} else if (S >= 8 && _simd_s8x8_mul_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_mul_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_mul_
		} else if (S >= 4 && _simd_s8x4_mul_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_mul_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_mul_
		} else if (S >= 2 && _simd_s8x2_mul_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_mul_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_MUL> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_MUL> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_DIV> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_div_
		} else if (S >= 64 && _simd_s8x64_div_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_div_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_div_
		} else if (S >= 32 && _simd_s8x32_div_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_div_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_div_
		} else if (S >= 16 && _simd_s8x16_div_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_div_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_div_
		} else if (S >= 8 && _simd_s8x8_div_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_div_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_div_
		} else if (S >= 4 && _simd_s8x4_div_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_div_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_div_
		} else if (S >= 2 && _simd_s8x2_div_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_div_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_DIV> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_DIV> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_min_
		} else if (S >= 64 && _simd_s8x64_min_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_min_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_min_
		} else if (S >= 32 && _simd_s8x32_min_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_min_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_min_
		} else if (S >= 16 && _simd_s8x16_min_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_min_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_min_
		} else if (S >= 8 && _simd_s8x8_min_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_min_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_min_
		} else if (S >= 4 && _simd_s8x4_min_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_min_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_min_
		} else if (S >= 2 && _simd_s8x2_min_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_min_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_MIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_MIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_MAX> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_max_
		} else if (S >= 64 && _simd_s8x64_max_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_max_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_max_
		} else if (S >= 32 && _simd_s8x32_max_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_max_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_max_
		} else if (S >= 16 && _simd_s8x16_max_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_max_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_max_
		} else if (S >= 8 && _simd_s8x8_max_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_max_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_max_
		} else if (S >= 4 && _simd_s8x4_max_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_max_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_max_
		} else if (S >= 2 && _simd_s8x2_max_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_max_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_MAX> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_MAX> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPEQ> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpeq_
		} else if (S >= 64 && _simd_s8x64_cmpeq_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmpeq_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmpeq_
		} else if (S >= 32 && _simd_s8x32_cmpeq_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmpeq_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmpeq_
		} else if (S >= 16 && _simd_s8x16_cmpeq_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmpeq_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmpeq_
		} else if (S >= 8 && _simd_s8x8_cmpeq_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmpeq_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmpeq_
		} else if (S >= 4 && _simd_s8x4_cmpeq_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmpeq_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmpeq_
		} else if (S >= 2 && _simd_s8x2_cmpeq_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmpeq_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPEQ> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPEQ> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPNE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpne_
		} else if (S >= 64 && _simd_s8x64_cmpne_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmpne_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmpne_
		} else if (S >= 32 && _simd_s8x32_cmpne_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmpne_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmpne_
		} else if (S >= 16 && _simd_s8x16_cmpne_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmpne_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmpne_
		} else if (S >= 8 && _simd_s8x8_cmpne_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmpne_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmpne_
		} else if (S >= 4 && _simd_s8x4_cmpne_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmpne_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmpne_
		} else if (S >= 2 && _simd_s8x2_cmpne_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmpne_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPNE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPNE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPLT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmplt_
		} else if (S >= 64 && _simd_s8x64_cmplt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmplt_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmplt_
		} else if (S >= 32 && _simd_s8x32_cmplt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmplt_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmplt_
		} else if (S >= 16 && _simd_s8x16_cmplt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmplt_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmplt_
		} else if (S >= 8 && _simd_s8x8_cmplt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmplt_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmplt_
		} else if (S >= 4 && _simd_s8x4_cmplt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmplt_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmplt_
		} else if (S >= 2 && _simd_s8x2_cmplt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmplt_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPLT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPLT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPGT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpgt_
		} else if (S >= 64 && _simd_s8x64_cmpgt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmpgt_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmpgt_
		} else if (S >= 32 && _simd_s8x32_cmpgt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmpgt_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmpgt_
		} else if (S >= 16 && _simd_s8x16_cmpgt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmpgt_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmpgt_
		} else if (S >= 8 && _simd_s8x8_cmpgt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmpgt_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmpgt_
		} else if (S >= 4 && _simd_s8x4_cmpgt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmpgt_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmpgt_
		} else if (S >= 2 && _simd_s8x2_cmpgt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmpgt_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPGT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPGT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPLE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmple_
		} else if (S >= 64 && _simd_s8x64_cmple_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmple_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmple_
		} else if (S >= 32 && _simd_s8x32_cmple_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmple_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmple_
		} else if (S >= 16 && _simd_s8x16_cmple_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmple_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmple_
		} else if (S >= 8 && _simd_s8x8_cmple_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmple_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmple_
		} else if (S >= 4 && _simd_s8x4_cmple_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmple_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmple_
		} else if (S >= 2 && _simd_s8x2_cmple_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmple_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPLE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPLE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CMPGE> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cmpge_
		} else if (S >= 64 && _simd_s8x64_cmpge_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cmpge_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_cmpge_
		} else if (S >= 32 && _simd_s8x32_cmpge_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cmpge_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_cmpge_
		} else if (S >= 16 && _simd_s8x16_cmpge_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cmpge_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_cmpge_
		} else if (S >= 8 && _simd_s8x8_cmpge_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cmpge_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_cmpge_
		} else if (S >= 4 && _simd_s8x4_cmpge_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cmpge_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_cmpge_
		} else if (S >= 2 && _simd_s8x2_cmpge_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cmpge_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CMPGE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CMPGE> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_AND> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_and_
		} else if (S >= 64 && _simd_s8x64_and_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_and_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_and_
		} else if (S >= 32 && _simd_s8x32_and_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_and_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_and_
		} else if (S >= 16 && _simd_s8x16_and_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_and_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_and_
		} else if (S >= 8 && _simd_s8x8_and_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_and_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_and_
		} else if (S >= 4 && _simd_s8x4_and_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_and_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_and_
		} else if (S >= 2 && _simd_s8x2_and_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_and_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_AND> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_AND> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_OR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_or_
		} else if (S >= 64 && _simd_s8x64_or_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_or_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_or_
		} else if (S >= 32 && _simd_s8x32_or_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_or_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_or_
		} else if (S >= 16 && _simd_s8x16_or_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_or_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_or_
		} else if (S >= 8 && _simd_s8x8_or_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_or_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_or_
		} else if (S >= 4 && _simd_s8x4_or_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_or_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_or_
		} else if (S >= 2 && _simd_s8x2_or_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_or_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_OR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_OR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_XOR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_xor_
		} else if (S >= 64 && _simd_s8x64_xor_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_xor_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_xor_
		} else if (S >= 32 && _simd_s8x32_xor_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_xor_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_xor_
		} else if (S >= 16 && _simd_s8x16_xor_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_xor_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_xor_
		} else if (S >= 8 && _simd_s8x8_xor_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_xor_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_xor_
		} else if (S >= 4 && _simd_s8x4_xor_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_xor_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_xor_
		} else if (S >= 2 && _simd_s8x2_xor_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_xor_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_XOR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_XOR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_lshift_
		} else if (S >= 64 && _simd_s8x64_lshift_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_lshift_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_lshift_
		} else if (S >= 32 && _simd_s8x32_lshift_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_lshift_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_lshift_
		} else if (S >= 16 && _simd_s8x16_lshift_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_lshift_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_lshift_
		} else if (S >= 8 && _simd_s8x8_lshift_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_lshift_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_lshift_
		} else if (S >= 4 && _simd_s8x4_lshift_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_lshift_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_lshift_
		} else if (S >= 2 && _simd_s8x2_lshift_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_lshift_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_LSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_LSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_RSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_rshift_
		} else if (S >= 64 && _simd_s8x64_rshift_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_rshift_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_rshift_
		} else if (S >= 32 && _simd_s8x32_rshift_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_rshift_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_rshift_
		} else if (S >= 16 && _simd_s8x16_rshift_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_rshift_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_rshift_
		} else if (S >= 8 && _simd_s8x8_rshift_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_rshift_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_rshift_
		} else if (S >= 4 && _simd_s8x4_rshift_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_rshift_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_rshift_
		} else if (S >= 2 && _simd_s8x2_rshift_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_rshift_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_RSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_RSHIFT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ATAN2> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_atan2_
		} else if (S >= 64 && _simd_s8x64_atan2_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_atan2_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_atan2_
		} else if (S >= 32 && _simd_s8x32_atan2_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_atan2_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_atan2_
		} else if (S >= 16 && _simd_s8x16_atan2_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_atan2_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_atan2_
		} else if (S >= 8 && _simd_s8x8_atan2_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_atan2_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_atan2_
		} else if (S >= 4 && _simd_s8x4_atan2_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_atan2_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_atan2_
		} else if (S >= 2 && _simd_s8x2_atan2_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_atan2_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ATAN2> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ATAN2> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_POW> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_pow_
		} else if (S >= 64 && _simd_s8x64_pow_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_pow_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_pow_
		} else if (S >= 32 && _simd_s8x32_pow_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_pow_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_pow_
		} else if (S >= 16 && _simd_s8x16_pow_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_pow_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_pow_
		} else if (S >= 8 && _simd_s8x8_pow_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_pow_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_pow_
		} else if (S >= 4 && _simd_s8x4_pow_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_pow_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_pow_
		} else if (S >= 2 && _simd_s8x2_pow_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_pow_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_POW> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_POW> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_HYPOT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_hypot_
		} else if (S >= 64 && _simd_s8x64_hypot_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_hypot_(_simd_s8x64_load_(x),_simd_s8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s8x32_hypot_
		} else if (S >= 32 && _simd_s8x32_hypot_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_hypot_(_simd_s8x32_load_(x),_simd_s8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s8x16_hypot_
		} else if (S >= 16 && _simd_s8x16_hypot_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_hypot_(_simd_s8x16_load_(x),_simd_s8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s8x8_hypot_
		} else if (S >= 8 && _simd_s8x8_hypot_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_hypot_(_simd_s8x8_load_(x),_simd_s8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s8x4_hypot_
		} else if (S >= 4 && _simd_s8x4_hypot_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_hypot_(_simd_s8x4_load_(x),_simd_s8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_s8x2_hypot_
		} else if (S >= 2 && _simd_s8x2_hypot_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_hypot_(_simd_s8x2_load_(x),_simd_s8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_HYPOT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_s8x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_HYPOT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_NOT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_not_
		} else if (S >= 64 && _simd_s8x64_not_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_not_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s8x32_not_
		} else if (S >= 32 && _simd_s8x32_not_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_not_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s8x16_not_
		} else if (S >= 16 && _simd_s8x16_not_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_not_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s8x8_not_
		} else if (S >= 8 && _simd_s8x8_not_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_not_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s8x4_not_
		} else if (S >= 4 && _simd_s8x4_not_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_not_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_s8x2_not_
		} else if (S >= 2 && _simd_s8x2_not_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_not_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_NOT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_NOT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ABS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_abs_
		} else if (S >= 64 && _simd_s8x64_abs_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_abs_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s8x32_abs_
		} else if (S >= 32 && _simd_s8x32_abs_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_abs_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s8x16_abs_
		} else if (S >= 16 && _simd_s8x16_abs_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_abs_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s8x8_abs_
		} else if (S >= 8 && _simd_s8x8_abs_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_abs_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s8x4_abs_
		} else if (S >= 4 && _simd_s8x4_abs_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_abs_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_s8x2_abs_
		} else if (S >= 2 && _simd_s8x2_abs_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_abs_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ABS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ABS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_EXP> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_exp_
		} else if (S >= 64 && _simd_s8x64_exp_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_exp_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s8x32_exp_
		} else if (S >= 32 && _simd_s8x32_exp_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_exp_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s8x16_exp_
		} else if (S >= 16 && _simd_s8x16_exp_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_exp_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s8x8_exp_
		} else if (S >= 8 && _simd_s8x8_exp_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_exp_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s8x4_exp_
		} else if (S >= 4 && _simd_s8x4_exp_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_exp_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_s8x2_exp_
		} else if (S >= 2 && _simd_s8x2_exp_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_exp_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_EXP> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_EXP> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log_
		} else if (S >= 64 && _simd_s8x64_log_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_log_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s8x32_log_
		} else if (S >= 32 && _simd_s8x32_log_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_log_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s8x16_log_
		} else if (S >= 16 && _simd_s8x16_log_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_log_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s8x8_log_
		} else if (S >= 8 && _simd_s8x8_log_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_log_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s8x4_log_
		} else if (S >= 4 && _simd_s8x4_log_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_log_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_s8x2_log_
		} else if (S >= 2 && _simd_s8x2_log_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_log_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_LOG> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_LOG> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG2> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log2_
		} else if (S >= 64 && _simd_s8x64_log2_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_log2_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s8x32_log2_
		} else if (S >= 32 && _simd_s8x32_log2_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_log2_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s8x16_log2_
		} else if (S >= 16 && _simd_s8x16_log2_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_log2_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s8x8_log2_
		} else if (S >= 8 && _simd_s8x8_log2_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_log2_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s8x4_log2_
		} else if (S >= 4 && _simd_s8x4_log2_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_log2_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_s8x2_log2_
		} else if (S >= 2 && _simd_s8x2_log2_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_log2_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_LOG2> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_LOG2> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_LOG10> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_log10_
		} else if (S >= 64 && _simd_s8x64_log10_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_log10_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s8x32_log10_
		} else if (S >= 32 && _simd_s8x32_log10_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_log10_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s8x16_log10_
		} else if (S >= 16 && _simd_s8x16_log10_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_log10_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s8x8_log10_
		} else if (S >= 8 && _simd_s8x8_log10_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_log10_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s8x4_log10_
		} else if (S >= 4 && _simd_s8x4_log10_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_log10_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_s8x2_log10_
		} else if (S >= 2 && _simd_s8x2_log10_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_log10_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_LOG10> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_LOG10> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CEIL> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_ceil_
		} else if (S >= 64 && _simd_s8x64_ceil_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_ceil_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s8x32_ceil_
		} else if (S >= 32 && _simd_s8x32_ceil_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_ceil_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s8x16_ceil_
		} else if (S >= 16 && _simd_s8x16_ceil_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_ceil_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s8x8_ceil_
		} else if (S >= 8 && _simd_s8x8_ceil_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_ceil_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s8x4_ceil_
		} else if (S >= 4 && _simd_s8x4_ceil_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_ceil_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_s8x2_ceil_
		} else if (S >= 2 && _simd_s8x2_ceil_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_ceil_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CEIL> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CEIL> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_FLOOR> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_floor_
		} else if (S >= 64 && _simd_s8x64_floor_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_floor_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s8x32_floor_
		} else if (S >= 32 && _simd_s8x32_floor_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_floor_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s8x16_floor_
		} else if (S >= 16 && _simd_s8x16_floor_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_floor_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s8x8_floor_
		} else if (S >= 8 && _simd_s8x8_floor_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_floor_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s8x4_floor_
		} else if (S >= 4 && _simd_s8x4_floor_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_floor_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_s8x2_floor_
		} else if (S >= 2 && _simd_s8x2_floor_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_floor_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_FLOOR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_FLOOR> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ROUND> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_round_
		} else if (S >= 64 && _simd_s8x64_round_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_round_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s8x32_round_
		} else if (S >= 32 && _simd_s8x32_round_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_round_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s8x16_round_
		} else if (S >= 16 && _simd_s8x16_round_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_round_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s8x8_round_
		} else if (S >= 8 && _simd_s8x8_round_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_round_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s8x4_round_
		} else if (S >= 4 && _simd_s8x4_round_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_round_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_s8x2_round_
		} else if (S >= 2 && _simd_s8x2_round_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_round_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ROUND> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ROUND> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sin_
		} else if (S >= 64 && _simd_s8x64_sin_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_sin_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s8x32_sin_
		} else if (S >= 32 && _simd_s8x32_sin_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_sin_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s8x16_sin_
		} else if (S >= 16 && _simd_s8x16_sin_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_sin_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s8x8_sin_
		} else if (S >= 8 && _simd_s8x8_sin_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_sin_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s8x4_sin_
		} else if (S >= 4 && _simd_s8x4_sin_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_sin_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_s8x2_sin_
		} else if (S >= 2 && _simd_s8x2_sin_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_sin_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_SIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_SIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_COS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cos_
		} else if (S >= 64 && _simd_s8x64_cos_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cos_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s8x32_cos_
		} else if (S >= 32 && _simd_s8x32_cos_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cos_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s8x16_cos_
		} else if (S >= 16 && _simd_s8x16_cos_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cos_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s8x8_cos_
		} else if (S >= 8 && _simd_s8x8_cos_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cos_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s8x4_cos_
		} else if (S >= 4 && _simd_s8x4_cos_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cos_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_s8x2_cos_
		} else if (S >= 2 && _simd_s8x2_cos_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cos_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_COS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_COS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_TAN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_tan_
		} else if (S >= 64 && _simd_s8x64_tan_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_tan_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s8x32_tan_
		} else if (S >= 32 && _simd_s8x32_tan_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_tan_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s8x16_tan_
		} else if (S >= 16 && _simd_s8x16_tan_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_tan_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s8x8_tan_
		} else if (S >= 8 && _simd_s8x8_tan_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_tan_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s8x4_tan_
		} else if (S >= 4 && _simd_s8x4_tan_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_tan_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_s8x2_tan_
		} else if (S >= 2 && _simd_s8x2_tan_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_tan_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_TAN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_TAN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ASIN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_asin_
		} else if (S >= 64 && _simd_s8x64_asin_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_asin_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s8x32_asin_
		} else if (S >= 32 && _simd_s8x32_asin_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_asin_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s8x16_asin_
		} else if (S >= 16 && _simd_s8x16_asin_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_asin_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s8x8_asin_
		} else if (S >= 8 && _simd_s8x8_asin_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_asin_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s8x4_asin_
		} else if (S >= 4 && _simd_s8x4_asin_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_asin_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_s8x2_asin_
		} else if (S >= 2 && _simd_s8x2_asin_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_asin_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ASIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ASIN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ACOS> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_acos_
		} else if (S >= 64 && _simd_s8x64_acos_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_acos_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s8x32_acos_
		} else if (S >= 32 && _simd_s8x32_acos_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_acos_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s8x16_acos_
		} else if (S >= 16 && _simd_s8x16_acos_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_acos_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s8x8_acos_
		} else if (S >= 8 && _simd_s8x8_acos_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_acos_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s8x4_acos_
		} else if (S >= 4 && _simd_s8x4_acos_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_acos_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_s8x2_acos_
		} else if (S >= 2 && _simd_s8x2_acos_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_acos_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ACOS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ACOS> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_ATAN> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_atan_
		} else if (S >= 64 && _simd_s8x64_atan_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_atan_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s8x32_atan_
		} else if (S >= 32 && _simd_s8x32_atan_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_atan_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s8x16_atan_
		} else if (S >= 16 && _simd_s8x16_atan_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_atan_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s8x8_atan_
		} else if (S >= 8 && _simd_s8x8_atan_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_atan_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s8x4_atan_
		} else if (S >= 4 && _simd_s8x4_atan_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_atan_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_s8x2_atan_
		} else if (S >= 2 && _simd_s8x2_atan_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_atan_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_ATAN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_ATAN> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SINH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sinh_
		} else if (S >= 64 && _simd_s8x64_sinh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_sinh_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s8x32_sinh_
		} else if (S >= 32 && _simd_s8x32_sinh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_sinh_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s8x16_sinh_
		} else if (S >= 16 && _simd_s8x16_sinh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_sinh_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s8x8_sinh_
		} else if (S >= 8 && _simd_s8x8_sinh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_sinh_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s8x4_sinh_
		} else if (S >= 4 && _simd_s8x4_sinh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_sinh_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_s8x2_sinh_
		} else if (S >= 2 && _simd_s8x2_sinh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_sinh_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_SINH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_SINH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_COSH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cosh_
		} else if (S >= 64 && _simd_s8x64_cosh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cosh_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s8x32_cosh_
		} else if (S >= 32 && _simd_s8x32_cosh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cosh_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s8x16_cosh_
		} else if (S >= 16 && _simd_s8x16_cosh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cosh_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s8x8_cosh_
		} else if (S >= 8 && _simd_s8x8_cosh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cosh_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s8x4_cosh_
		} else if (S >= 4 && _simd_s8x4_cosh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cosh_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_s8x2_cosh_
		} else if (S >= 2 && _simd_s8x2_cosh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cosh_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_COSH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_COSH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_TANH> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_tanh_
		} else if (S >= 64 && _simd_s8x64_tanh_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_tanh_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s8x32_tanh_
		} else if (S >= 32 && _simd_s8x32_tanh_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_tanh_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s8x16_tanh_
		} else if (S >= 16 && _simd_s8x16_tanh_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_tanh_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s8x8_tanh_
		} else if (S >= 8 && _simd_s8x8_tanh_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_tanh_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s8x4_tanh_
		} else if (S >= 4 && _simd_s8x4_tanh_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_tanh_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_s8x2_tanh_
		} else if (S >= 2 && _simd_s8x2_tanh_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_tanh_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_TANH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_TANH> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_SQRT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_sqrt_
		} else if (S >= 64 && _simd_s8x64_sqrt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_sqrt_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s8x32_sqrt_
		} else if (S >= 32 && _simd_s8x32_sqrt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_sqrt_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s8x16_sqrt_
		} else if (S >= 16 && _simd_s8x16_sqrt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_sqrt_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s8x8_sqrt_
		} else if (S >= 8 && _simd_s8x8_sqrt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_sqrt_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s8x4_sqrt_
		} else if (S >= 4 && _simd_s8x4_sqrt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_sqrt_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_s8x2_sqrt_
		} else if (S >= 2 && _simd_s8x2_sqrt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_sqrt_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_SQRT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_SQRT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_s8x1, S, OP_CBRT> {
	typedef _simd_s8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_s8x64_cbrt_
		} else if (S >= 64 && _simd_s8x64_cbrt_enable()) {
			typedef _simd_s8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x64_cbrt_(_simd_s8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s8x32_cbrt_
		} else if (S >= 32 && _simd_s8x32_cbrt_enable()) {
			typedef _simd_s8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x32_cbrt_(_simd_s8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s8x16_cbrt_
		} else if (S >= 16 && _simd_s8x16_cbrt_enable()) {
			typedef _simd_s8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x16_cbrt_(_simd_s8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s8x8_cbrt_
		} else if (S >= 8 && _simd_s8x8_cbrt_enable()) {
			typedef _simd_s8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x8_cbrt_(_simd_s8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s8x4_cbrt_
		} else if (S >= 4 && _simd_s8x4_cbrt_enable()) {
			typedef _simd_s8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x4_cbrt_(_simd_s8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_s8x2_cbrt_
		} else if (S >= 2 && _simd_s8x2_cbrt_enable()) {
			typedef _simd_s8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_s8x2_cbrt_(_simd_s8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_s8x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 1, OP_CBRT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_s8x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_s8x1, 0, OP_CBRT> {
	typedef _simd_s8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S,OP_SUM> {
	typedef _simd_u8x1 scalar_t;

	static scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_add_
		} else if (S >= 64 && _simd_u8x64_add_enable()) {
			typedef _simd_u8x64 simd_t;
			simd_t tmp = _simd_u8x64_fill_zero();
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x64_add_(tmp, _simd_u8x64_load_(o)); 
				o += 64;
			}
			return _simd_u8x64_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u8x32_add_
		} else if (S >= 32 && _simd_u8x32_add_enable()) {
			typedef _simd_u8x32 simd_t;
			simd_t tmp = _simd_u8x32_fill_zero();
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x32_add_(tmp, _simd_u8x32_load_(o)); 
				o += 32;
			}
			return _simd_u8x32_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u8x16_add_
		} else if (S >= 16 && _simd_u8x16_add_enable()) {
			typedef _simd_u8x16 simd_t;
			simd_t tmp = _simd_u8x16_fill_zero();
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x16_add_(tmp, _simd_u8x16_load_(o)); 
				o += 16;
			}
			return _simd_u8x16_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u8x8_add_
		} else if (S >= 8 && _simd_u8x8_add_enable()) {
			typedef _simd_u8x8 simd_t;
			simd_t tmp = _simd_u8x8_fill_zero();
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x8_add_(tmp, _simd_u8x8_load_(o)); 
				o += 8;
			}
			return _simd_u8x8_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u8x4_add_
		} else if (S >= 4 && _simd_u8x4_add_enable()) {
			typedef _simd_u8x4 simd_t;
			simd_t tmp = _simd_u8x4_fill_zero();
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x4_add_(tmp, _simd_u8x4_load_(o)); 
				o += 4;
			}
			return _simd_u8x4_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
#ifdef _simd_u8x2_add_
		} else if (S >= 2 && _simd_u8x2_add_enable()) {
			typedef _simd_u8x2 simd_t;
			simd_t tmp = _simd_u8x2_fill_zero();
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				tmp = _simd_u8x2_add_(tmp, _simd_u8x2_load_(o)); 
				o += 2;
			}
			return _simd_u8x2_sum(tmp) + OperationDispatcher<scalar_t, remainder, OP_SUM>::execute(o); 
#endif
		} else {
			scalar_t tmp = static_cast<scalar_t>(0);
			for(int i = 0; i < S; ++i) tmp += o[i];
			return tmp;
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1,OP_SUM> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return *o;
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0,OP_SUM> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE scalar_t ANVIL_SIMD_CALL execute(const scalar_t* o) {
		return static_cast<scalar_t>(0);
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FILL0> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fill_zero_
		} else if (S >= 64 && _simd_u8x64_fill_zero_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_fill_zero_();
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u8x32_fill_zero_
		} else if (S >= 32 && _simd_u8x32_fill_zero_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_fill_zero_();
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u8x16_fill_zero_
		} else if (S >= 16 && _simd_u8x16_fill_zero_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_fill_zero_();
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u8x8_fill_zero_
		} else if (S >= 8 && _simd_u8x8_fill_zero_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_fill_zero_();
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u8x4_fill_zero_
		} else if (S >= 4 && _simd_u8x4_fill_zero_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_fill_zero_();
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
#ifdef _simd_u8x2_fill_zero_
		} else if (S >= 2 && _simd_u8x2_fill_zero_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_fill_zero_();
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILL0>::execute(o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FILLU> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FILLS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(scalar_t val, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fill_scalar_
		} else if (S >= 64 && _simd_u8x64_fill_scalar_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_fill_scalar_(val);
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u8x32_fill_scalar_
		} else if (S >= 32 && _simd_u8x32_fill_scalar_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_fill_scalar_(val);
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u8x16_fill_scalar_
		} else if (S >= 16 && _simd_u8x16_fill_scalar_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_fill_scalar_(val);
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u8x8_fill_scalar_
		} else if (S >= 8 && _simd_u8x8_fill_scalar_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_fill_scalar_(val);
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u8x4_fill_scalar_
		} else if (S >= 4 && _simd_u8x4_fill_scalar_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_fill_scalar_(val);
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
#ifdef _simd_u8x2_fill_scalar_
		} else if (S >= 2 && _simd_u8x2_fill_scalar_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_fill_scalar_(val);
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FILLS>::execute(val, o);
#endif
		} else {
			memset(o, 0, sizeof(scalar_t) * S);
		}
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FMA> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fma_
		} else if (S >= 64 && _simd_u8x64_fma_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_fma_(_simd_u8x64_load_(x),_simd_u8x64_load_(y),_simd_u8x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x32_fma_
		} else if (S >= 32 && _simd_u8x32_fma_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_fma_(_simd_u8x32_load_(x),_simd_u8x32_load_(y),_simd_u8x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x16_fma_
		} else if (S >= 16 && _simd_u8x16_fma_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_fma_(_simd_u8x16_load_(x),_simd_u8x16_load_(y),_simd_u8x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x8_fma_
		} else if (S >= 8 && _simd_u8x8_fma_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_fma_(_simd_u8x8_load_(x),_simd_u8x8_load_(y),_simd_u8x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x4_fma_
		} else if (S >= 4 && _simd_u8x4_fma_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_fma_(_simd_u8x4_load_(x),_simd_u8x4_load_(y),_simd_u8x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x2_fma_
		} else if (S >= 2 && _simd_u8x2_fma_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_fma_(_simd_u8x2_load_(x),_simd_u8x2_load_(y),_simd_u8x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMA>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_fma_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_FMA> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u8x1_fma_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_FMA> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FMS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_fms_
		} else if (S >= 64 && _simd_u8x64_fms_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_fms_(_simd_u8x64_load_(x),_simd_u8x64_load_(y),_simd_u8x64_load_(z));
				x += 64;
				y += 64;
				z += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x32_fms_
		} else if (S >= 32 && _simd_u8x32_fms_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_fms_(_simd_u8x32_load_(x),_simd_u8x32_load_(y),_simd_u8x32_load_(z));
				x += 32;
				y += 32;
				z += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x16_fms_
		} else if (S >= 16 && _simd_u8x16_fms_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_fms_(_simd_u8x16_load_(x),_simd_u8x16_load_(y),_simd_u8x16_load_(z));
				x += 16;
				y += 16;
				z += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x8_fms_
		} else if (S >= 8 && _simd_u8x8_fms_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_fms_(_simd_u8x8_load_(x),_simd_u8x8_load_(y),_simd_u8x8_load_(z));
				x += 8;
				y += 8;
				z += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x4_fms_
		} else if (S >= 4 && _simd_u8x4_fms_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_fms_(_simd_u8x4_load_(x),_simd_u8x4_load_(y),_simd_u8x4_load_(z));
				x += 4;
				y += 4;
				z += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
#ifdef _simd_u8x2_fms_
		} else if (S >= 2 && _simd_u8x2_fms_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_fms_(_simd_u8x2_load_(x),_simd_u8x2_load_(y),_simd_u8x2_load_(z));
				x += 2;
				y += 2;
				z += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FMS>::execute(x,y,z,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_fms_safe(x[i],y[i],z[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_FMS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
		*o = _simd_u8x1_fms_safe(*x,*y,*z);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_FMS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, const scalar_t* z, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ADD> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_add_
		} else if (S >= 64 && _simd_u8x64_add_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_add_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_add_
		} else if (S >= 32 && _simd_u8x32_add_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_add_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_add_
		} else if (S >= 16 && _simd_u8x16_add_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_add_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_add_
		} else if (S >= 8 && _simd_u8x8_add_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_add_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_add_
		} else if (S >= 4 && _simd_u8x4_add_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_add_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_add_
		} else if (S >= 2 && _simd_u8x2_add_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_add_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ADD>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_add_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ADD> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_add_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ADD> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SUB> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sub_
		} else if (S >= 64 && _simd_u8x64_sub_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_sub_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_sub_
		} else if (S >= 32 && _simd_u8x32_sub_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_sub_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_sub_
		} else if (S >= 16 && _simd_u8x16_sub_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_sub_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_sub_
		} else if (S >= 8 && _simd_u8x8_sub_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_sub_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_sub_
		} else if (S >= 4 && _simd_u8x4_sub_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_sub_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_sub_
		} else if (S >= 2 && _simd_u8x2_sub_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_sub_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SUB>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sub_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_SUB> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_sub_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_SUB> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MUL> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_mul_
		} else if (S >= 64 && _simd_u8x64_mul_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_mul_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_mul_
		} else if (S >= 32 && _simd_u8x32_mul_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_mul_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_mul_
		} else if (S >= 16 && _simd_u8x16_mul_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_mul_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_mul_
		} else if (S >= 8 && _simd_u8x8_mul_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_mul_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_mul_
		} else if (S >= 4 && _simd_u8x4_mul_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_mul_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_mul_
		} else if (S >= 2 && _simd_u8x2_mul_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_mul_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MUL>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_mul_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_MUL> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_mul_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_MUL> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_DIV> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_div_
		} else if (S >= 64 && _simd_u8x64_div_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_div_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_div_
		} else if (S >= 32 && _simd_u8x32_div_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_div_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_div_
		} else if (S >= 16 && _simd_u8x16_div_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_div_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_div_
		} else if (S >= 8 && _simd_u8x8_div_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_div_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_div_
		} else if (S >= 4 && _simd_u8x4_div_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_div_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_div_
		} else if (S >= 2 && _simd_u8x2_div_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_div_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_DIV>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_div_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_DIV> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_div_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_DIV> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_min_
		} else if (S >= 64 && _simd_u8x64_min_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_min_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_min_
		} else if (S >= 32 && _simd_u8x32_min_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_min_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_min_
		} else if (S >= 16 && _simd_u8x16_min_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_min_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_min_
		} else if (S >= 8 && _simd_u8x8_min_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_min_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_min_
		} else if (S >= 4 && _simd_u8x4_min_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_min_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_min_
		} else if (S >= 2 && _simd_u8x2_min_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_min_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MIN>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_min_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_MIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_min_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_MIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_MAX> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_max_
		} else if (S >= 64 && _simd_u8x64_max_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_max_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_max_
		} else if (S >= 32 && _simd_u8x32_max_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_max_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_max_
		} else if (S >= 16 && _simd_u8x16_max_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_max_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_max_
		} else if (S >= 8 && _simd_u8x8_max_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_max_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_max_
		} else if (S >= 4 && _simd_u8x4_max_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_max_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_max_
		} else if (S >= 2 && _simd_u8x2_max_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_max_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_MAX>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_max_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_MAX> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_max_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_MAX> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPEQ> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpeq_
		} else if (S >= 64 && _simd_u8x64_cmpeq_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmpeq_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmpeq_
		} else if (S >= 32 && _simd_u8x32_cmpeq_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmpeq_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmpeq_
		} else if (S >= 16 && _simd_u8x16_cmpeq_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmpeq_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmpeq_
		} else if (S >= 8 && _simd_u8x8_cmpeq_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmpeq_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmpeq_
		} else if (S >= 4 && _simd_u8x4_cmpeq_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmpeq_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmpeq_
		} else if (S >= 2 && _simd_u8x2_cmpeq_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmpeq_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPEQ>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpeq_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPEQ> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmpeq_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPEQ> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPNE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpne_
		} else if (S >= 64 && _simd_u8x64_cmpne_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmpne_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmpne_
		} else if (S >= 32 && _simd_u8x32_cmpne_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmpne_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmpne_
		} else if (S >= 16 && _simd_u8x16_cmpne_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmpne_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmpne_
		} else if (S >= 8 && _simd_u8x8_cmpne_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmpne_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmpne_
		} else if (S >= 4 && _simd_u8x4_cmpne_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmpne_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmpne_
		} else if (S >= 2 && _simd_u8x2_cmpne_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmpne_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPNE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpne_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPNE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmpne_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPNE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPLT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmplt_
		} else if (S >= 64 && _simd_u8x64_cmplt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmplt_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmplt_
		} else if (S >= 32 && _simd_u8x32_cmplt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmplt_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmplt_
		} else if (S >= 16 && _simd_u8x16_cmplt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmplt_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmplt_
		} else if (S >= 8 && _simd_u8x8_cmplt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmplt_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmplt_
		} else if (S >= 4 && _simd_u8x4_cmplt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmplt_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmplt_
		} else if (S >= 2 && _simd_u8x2_cmplt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmplt_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmplt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPLT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmplt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPLT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPGT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpgt_
		} else if (S >= 64 && _simd_u8x64_cmpgt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmpgt_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmpgt_
		} else if (S >= 32 && _simd_u8x32_cmpgt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmpgt_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmpgt_
		} else if (S >= 16 && _simd_u8x16_cmpgt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmpgt_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmpgt_
		} else if (S >= 8 && _simd_u8x8_cmpgt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmpgt_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmpgt_
		} else if (S >= 4 && _simd_u8x4_cmpgt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmpgt_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmpgt_
		} else if (S >= 2 && _simd_u8x2_cmpgt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmpgt_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpgt_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPGT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmpgt_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPGT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPLE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmple_
		} else if (S >= 64 && _simd_u8x64_cmple_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmple_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmple_
		} else if (S >= 32 && _simd_u8x32_cmple_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmple_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmple_
		} else if (S >= 16 && _simd_u8x16_cmple_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmple_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmple_
		} else if (S >= 8 && _simd_u8x8_cmple_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmple_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmple_
		} else if (S >= 4 && _simd_u8x4_cmple_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmple_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmple_
		} else if (S >= 2 && _simd_u8x2_cmple_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmple_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPLE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmple_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPLE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmple_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPLE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CMPGE> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cmpge_
		} else if (S >= 64 && _simd_u8x64_cmpge_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cmpge_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_cmpge_
		} else if (S >= 32 && _simd_u8x32_cmpge_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cmpge_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_cmpge_
		} else if (S >= 16 && _simd_u8x16_cmpge_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cmpge_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_cmpge_
		} else if (S >= 8 && _simd_u8x8_cmpge_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cmpge_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_cmpge_
		} else if (S >= 4 && _simd_u8x4_cmpge_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cmpge_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_cmpge_
		} else if (S >= 2 && _simd_u8x2_cmpge_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cmpge_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CMPGE>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cmpge_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CMPGE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_cmpge_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CMPGE> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_AND> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_and_
		} else if (S >= 64 && _simd_u8x64_and_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_and_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_and_
		} else if (S >= 32 && _simd_u8x32_and_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_and_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_and_
		} else if (S >= 16 && _simd_u8x16_and_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_and_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_and_
		} else if (S >= 8 && _simd_u8x8_and_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_and_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_and_
		} else if (S >= 4 && _simd_u8x4_and_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_and_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_and_
		} else if (S >= 2 && _simd_u8x2_and_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_and_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_AND>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_and_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_AND> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_and_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_AND> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_OR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_or_
		} else if (S >= 64 && _simd_u8x64_or_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_or_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_or_
		} else if (S >= 32 && _simd_u8x32_or_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_or_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_or_
		} else if (S >= 16 && _simd_u8x16_or_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_or_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_or_
		} else if (S >= 8 && _simd_u8x8_or_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_or_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_or_
		} else if (S >= 4 && _simd_u8x4_or_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_or_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_or_
		} else if (S >= 2 && _simd_u8x2_or_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_or_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_OR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_or_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_OR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_or_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_OR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_XOR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_xor_
		} else if (S >= 64 && _simd_u8x64_xor_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_xor_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_xor_
		} else if (S >= 32 && _simd_u8x32_xor_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_xor_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_xor_
		} else if (S >= 16 && _simd_u8x16_xor_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_xor_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_xor_
		} else if (S >= 8 && _simd_u8x8_xor_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_xor_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_xor_
		} else if (S >= 4 && _simd_u8x4_xor_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_xor_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_xor_
		} else if (S >= 2 && _simd_u8x2_xor_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_xor_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_XOR>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_xor_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_XOR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_xor_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_XOR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_lshift_
		} else if (S >= 64 && _simd_u8x64_lshift_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_lshift_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_lshift_
		} else if (S >= 32 && _simd_u8x32_lshift_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_lshift_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_lshift_
		} else if (S >= 16 && _simd_u8x16_lshift_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_lshift_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_lshift_
		} else if (S >= 8 && _simd_u8x8_lshift_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_lshift_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_lshift_
		} else if (S >= 4 && _simd_u8x4_lshift_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_lshift_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_lshift_
		} else if (S >= 2 && _simd_u8x2_lshift_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_lshift_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_lshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_LSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_lshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_LSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_RSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_rshift_
		} else if (S >= 64 && _simd_u8x64_rshift_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_rshift_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_rshift_
		} else if (S >= 32 && _simd_u8x32_rshift_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_rshift_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_rshift_
		} else if (S >= 16 && _simd_u8x16_rshift_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_rshift_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_rshift_
		} else if (S >= 8 && _simd_u8x8_rshift_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_rshift_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_rshift_
		} else if (S >= 4 && _simd_u8x4_rshift_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_rshift_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_rshift_
		} else if (S >= 2 && _simd_u8x2_rshift_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_rshift_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_RSHIFT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_rshift_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_RSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_rshift_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_RSHIFT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ATAN2> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_atan2_
		} else if (S >= 64 && _simd_u8x64_atan2_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_atan2_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_atan2_
		} else if (S >= 32 && _simd_u8x32_atan2_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_atan2_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_atan2_
		} else if (S >= 16 && _simd_u8x16_atan2_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_atan2_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_atan2_
		} else if (S >= 8 && _simd_u8x8_atan2_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_atan2_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_atan2_
		} else if (S >= 4 && _simd_u8x4_atan2_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_atan2_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_atan2_
		} else if (S >= 2 && _simd_u8x2_atan2_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_atan2_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN2>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_atan2_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ATAN2> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_atan2_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ATAN2> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_POW> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_pow_
		} else if (S >= 64 && _simd_u8x64_pow_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_pow_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_pow_
		} else if (S >= 32 && _simd_u8x32_pow_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_pow_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_pow_
		} else if (S >= 16 && _simd_u8x16_pow_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_pow_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_pow_
		} else if (S >= 8 && _simd_u8x8_pow_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_pow_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_pow_
		} else if (S >= 4 && _simd_u8x4_pow_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_pow_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_pow_
		} else if (S >= 2 && _simd_u8x2_pow_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_pow_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_POW>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_pow_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_POW> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_pow_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_POW> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_HYPOT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_hypot_
		} else if (S >= 64 && _simd_u8x64_hypot_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_hypot_(_simd_u8x64_load_(x),_simd_u8x64_load_(y));
				x += 64;
				y += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u8x32_hypot_
		} else if (S >= 32 && _simd_u8x32_hypot_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_hypot_(_simd_u8x32_load_(x),_simd_u8x32_load_(y));
				x += 32;
				y += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u8x16_hypot_
		} else if (S >= 16 && _simd_u8x16_hypot_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_hypot_(_simd_u8x16_load_(x),_simd_u8x16_load_(y));
				x += 16;
				y += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u8x8_hypot_
		} else if (S >= 8 && _simd_u8x8_hypot_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_hypot_(_simd_u8x8_load_(x),_simd_u8x8_load_(y));
				x += 8;
				y += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u8x4_hypot_
		} else if (S >= 4 && _simd_u8x4_hypot_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_hypot_(_simd_u8x4_load_(x),_simd_u8x4_load_(y));
				x += 4;
				y += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
#ifdef _simd_u8x2_hypot_
		} else if (S >= 2 && _simd_u8x2_hypot_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_hypot_(_simd_u8x2_load_(x),_simd_u8x2_load_(y));
				x += 2;
				y += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_HYPOT>::execute(x,y,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_hypot_safe(x[i],y[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_HYPOT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
		*o = _simd_u8x1_hypot_safe(*x,*y);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_HYPOT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, const scalar_t* y, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_NOT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_not_
		} else if (S >= 64 && _simd_u8x64_not_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_not_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u8x32_not_
		} else if (S >= 32 && _simd_u8x32_not_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_not_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u8x16_not_
		} else if (S >= 16 && _simd_u8x16_not_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_not_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u8x8_not_
		} else if (S >= 8 && _simd_u8x8_not_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_not_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u8x4_not_
		} else if (S >= 4 && _simd_u8x4_not_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_not_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
#ifdef _simd_u8x2_not_
		} else if (S >= 2 && _simd_u8x2_not_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_not_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_NOT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_not_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_NOT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_not_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_NOT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ABS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_abs_
		} else if (S >= 64 && _simd_u8x64_abs_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_abs_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u8x32_abs_
		} else if (S >= 32 && _simd_u8x32_abs_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_abs_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u8x16_abs_
		} else if (S >= 16 && _simd_u8x16_abs_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_abs_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u8x8_abs_
		} else if (S >= 8 && _simd_u8x8_abs_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_abs_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u8x4_abs_
		} else if (S >= 4 && _simd_u8x4_abs_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_abs_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
#ifdef _simd_u8x2_abs_
		} else if (S >= 2 && _simd_u8x2_abs_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_abs_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ABS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_abs_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ABS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_abs_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ABS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_EXP> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_exp_
		} else if (S >= 64 && _simd_u8x64_exp_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_exp_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u8x32_exp_
		} else if (S >= 32 && _simd_u8x32_exp_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_exp_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u8x16_exp_
		} else if (S >= 16 && _simd_u8x16_exp_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_exp_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u8x8_exp_
		} else if (S >= 8 && _simd_u8x8_exp_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_exp_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u8x4_exp_
		} else if (S >= 4 && _simd_u8x4_exp_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_exp_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
#ifdef _simd_u8x2_exp_
		} else if (S >= 2 && _simd_u8x2_exp_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_exp_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_EXP>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_exp_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_EXP> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_exp_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_EXP> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log_
		} else if (S >= 64 && _simd_u8x64_log_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_log_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u8x32_log_
		} else if (S >= 32 && _simd_u8x32_log_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_log_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u8x16_log_
		} else if (S >= 16 && _simd_u8x16_log_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_log_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u8x8_log_
		} else if (S >= 8 && _simd_u8x8_log_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_log_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u8x4_log_
		} else if (S >= 4 && _simd_u8x4_log_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_log_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
#ifdef _simd_u8x2_log_
		} else if (S >= 2 && _simd_u8x2_log_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_log_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_LOG> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_log_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_LOG> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG2> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log2_
		} else if (S >= 64 && _simd_u8x64_log2_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_log2_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u8x32_log2_
		} else if (S >= 32 && _simd_u8x32_log2_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_log2_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u8x16_log2_
		} else if (S >= 16 && _simd_u8x16_log2_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_log2_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u8x8_log2_
		} else if (S >= 8 && _simd_u8x8_log2_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_log2_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u8x4_log2_
		} else if (S >= 4 && _simd_u8x4_log2_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_log2_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
#ifdef _simd_u8x2_log2_
		} else if (S >= 2 && _simd_u8x2_log2_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_log2_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG2>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log2_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_LOG2> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_log2_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_LOG2> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_LOG10> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_log10_
		} else if (S >= 64 && _simd_u8x64_log10_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_log10_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u8x32_log10_
		} else if (S >= 32 && _simd_u8x32_log10_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_log10_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u8x16_log10_
		} else if (S >= 16 && _simd_u8x16_log10_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_log10_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u8x8_log10_
		} else if (S >= 8 && _simd_u8x8_log10_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_log10_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u8x4_log10_
		} else if (S >= 4 && _simd_u8x4_log10_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_log10_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
#ifdef _simd_u8x2_log10_
		} else if (S >= 2 && _simd_u8x2_log10_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_log10_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_LOG10>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_log10_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_LOG10> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_log10_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_LOG10> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CEIL> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_ceil_
		} else if (S >= 64 && _simd_u8x64_ceil_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_ceil_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u8x32_ceil_
		} else if (S >= 32 && _simd_u8x32_ceil_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_ceil_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u8x16_ceil_
		} else if (S >= 16 && _simd_u8x16_ceil_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_ceil_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u8x8_ceil_
		} else if (S >= 8 && _simd_u8x8_ceil_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_ceil_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u8x4_ceil_
		} else if (S >= 4 && _simd_u8x4_ceil_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_ceil_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
#ifdef _simd_u8x2_ceil_
		} else if (S >= 2 && _simd_u8x2_ceil_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_ceil_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CEIL>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_ceil_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CEIL> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_ceil_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CEIL> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_FLOOR> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_floor_
		} else if (S >= 64 && _simd_u8x64_floor_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_floor_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u8x32_floor_
		} else if (S >= 32 && _simd_u8x32_floor_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_floor_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u8x16_floor_
		} else if (S >= 16 && _simd_u8x16_floor_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_floor_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u8x8_floor_
		} else if (S >= 8 && _simd_u8x8_floor_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_floor_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u8x4_floor_
		} else if (S >= 4 && _simd_u8x4_floor_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_floor_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
#ifdef _simd_u8x2_floor_
		} else if (S >= 2 && _simd_u8x2_floor_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_floor_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_FLOOR>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_floor_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_FLOOR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_floor_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_FLOOR> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ROUND> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_round_
		} else if (S >= 64 && _simd_u8x64_round_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_round_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u8x32_round_
		} else if (S >= 32 && _simd_u8x32_round_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_round_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u8x16_round_
		} else if (S >= 16 && _simd_u8x16_round_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_round_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u8x8_round_
		} else if (S >= 8 && _simd_u8x8_round_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_round_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u8x4_round_
		} else if (S >= 4 && _simd_u8x4_round_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_round_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
#ifdef _simd_u8x2_round_
		} else if (S >= 2 && _simd_u8x2_round_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_round_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ROUND>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_round_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ROUND> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_round_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ROUND> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sin_
		} else if (S >= 64 && _simd_u8x64_sin_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_sin_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u8x32_sin_
		} else if (S >= 32 && _simd_u8x32_sin_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_sin_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u8x16_sin_
		} else if (S >= 16 && _simd_u8x16_sin_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_sin_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u8x8_sin_
		} else if (S >= 8 && _simd_u8x8_sin_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_sin_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u8x4_sin_
		} else if (S >= 4 && _simd_u8x4_sin_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_sin_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
#ifdef _simd_u8x2_sin_
		} else if (S >= 2 && _simd_u8x2_sin_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_sin_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_SIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_sin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_SIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_COS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cos_
		} else if (S >= 64 && _simd_u8x64_cos_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cos_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u8x32_cos_
		} else if (S >= 32 && _simd_u8x32_cos_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cos_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u8x16_cos_
		} else if (S >= 16 && _simd_u8x16_cos_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cos_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u8x8_cos_
		} else if (S >= 8 && _simd_u8x8_cos_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cos_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u8x4_cos_
		} else if (S >= 4 && _simd_u8x4_cos_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cos_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
#ifdef _simd_u8x2_cos_
		} else if (S >= 2 && _simd_u8x2_cos_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cos_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_COS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_cos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_COS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_TAN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_tan_
		} else if (S >= 64 && _simd_u8x64_tan_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_tan_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u8x32_tan_
		} else if (S >= 32 && _simd_u8x32_tan_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_tan_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u8x16_tan_
		} else if (S >= 16 && _simd_u8x16_tan_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_tan_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u8x8_tan_
		} else if (S >= 8 && _simd_u8x8_tan_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_tan_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u8x4_tan_
		} else if (S >= 4 && _simd_u8x4_tan_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_tan_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
#ifdef _simd_u8x2_tan_
		} else if (S >= 2 && _simd_u8x2_tan_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_tan_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_tan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_TAN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_tan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_TAN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ASIN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_asin_
		} else if (S >= 64 && _simd_u8x64_asin_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_asin_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u8x32_asin_
		} else if (S >= 32 && _simd_u8x32_asin_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_asin_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u8x16_asin_
		} else if (S >= 16 && _simd_u8x16_asin_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_asin_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u8x8_asin_
		} else if (S >= 8 && _simd_u8x8_asin_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_asin_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u8x4_asin_
		} else if (S >= 4 && _simd_u8x4_asin_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_asin_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
#ifdef _simd_u8x2_asin_
		} else if (S >= 2 && _simd_u8x2_asin_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_asin_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ASIN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_asin_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ASIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_asin_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ASIN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ACOS> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_acos_
		} else if (S >= 64 && _simd_u8x64_acos_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_acos_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u8x32_acos_
		} else if (S >= 32 && _simd_u8x32_acos_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_acos_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u8x16_acos_
		} else if (S >= 16 && _simd_u8x16_acos_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_acos_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u8x8_acos_
		} else if (S >= 8 && _simd_u8x8_acos_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_acos_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u8x4_acos_
		} else if (S >= 4 && _simd_u8x4_acos_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_acos_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
#ifdef _simd_u8x2_acos_
		} else if (S >= 2 && _simd_u8x2_acos_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_acos_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ACOS>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_acos_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ACOS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_acos_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ACOS> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_ATAN> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_atan_
		} else if (S >= 64 && _simd_u8x64_atan_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_atan_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u8x32_atan_
		} else if (S >= 32 && _simd_u8x32_atan_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_atan_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u8x16_atan_
		} else if (S >= 16 && _simd_u8x16_atan_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_atan_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u8x8_atan_
		} else if (S >= 8 && _simd_u8x8_atan_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_atan_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u8x4_atan_
		} else if (S >= 4 && _simd_u8x4_atan_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_atan_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
#ifdef _simd_u8x2_atan_
		} else if (S >= 2 && _simd_u8x2_atan_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_atan_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_ATAN>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_atan_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_ATAN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_atan_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_ATAN> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SINH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sinh_
		} else if (S >= 64 && _simd_u8x64_sinh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_sinh_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u8x32_sinh_
		} else if (S >= 32 && _simd_u8x32_sinh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_sinh_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u8x16_sinh_
		} else if (S >= 16 && _simd_u8x16_sinh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_sinh_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u8x8_sinh_
		} else if (S >= 8 && _simd_u8x8_sinh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_sinh_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u8x4_sinh_
		} else if (S >= 4 && _simd_u8x4_sinh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_sinh_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
#ifdef _simd_u8x2_sinh_
		} else if (S >= 2 && _simd_u8x2_sinh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_sinh_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SINH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sinh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_SINH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_sinh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_SINH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_COSH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cosh_
		} else if (S >= 64 && _simd_u8x64_cosh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cosh_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u8x32_cosh_
		} else if (S >= 32 && _simd_u8x32_cosh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cosh_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u8x16_cosh_
		} else if (S >= 16 && _simd_u8x16_cosh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cosh_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u8x8_cosh_
		} else if (S >= 8 && _simd_u8x8_cosh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cosh_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u8x4_cosh_
		} else if (S >= 4 && _simd_u8x4_cosh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cosh_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
#ifdef _simd_u8x2_cosh_
		} else if (S >= 2 && _simd_u8x2_cosh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cosh_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_COSH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cosh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_COSH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_cosh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_COSH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_TANH> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_tanh_
		} else if (S >= 64 && _simd_u8x64_tanh_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_tanh_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u8x32_tanh_
		} else if (S >= 32 && _simd_u8x32_tanh_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_tanh_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u8x16_tanh_
		} else if (S >= 16 && _simd_u8x16_tanh_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_tanh_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u8x8_tanh_
		} else if (S >= 8 && _simd_u8x8_tanh_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_tanh_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u8x4_tanh_
		} else if (S >= 4 && _simd_u8x4_tanh_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_tanh_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
#ifdef _simd_u8x2_tanh_
		} else if (S >= 2 && _simd_u8x2_tanh_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_tanh_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_TANH>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_tanh_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_TANH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_tanh_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_TANH> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_SQRT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_sqrt_
		} else if (S >= 64 && _simd_u8x64_sqrt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_sqrt_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u8x32_sqrt_
		} else if (S >= 32 && _simd_u8x32_sqrt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_sqrt_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u8x16_sqrt_
		} else if (S >= 16 && _simd_u8x16_sqrt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_sqrt_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u8x8_sqrt_
		} else if (S >= 8 && _simd_u8x8_sqrt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_sqrt_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u8x4_sqrt_
		} else if (S >= 4 && _simd_u8x4_sqrt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_sqrt_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
#ifdef _simd_u8x2_sqrt_
		} else if (S >= 2 && _simd_u8x2_sqrt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_sqrt_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_SQRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_sqrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_SQRT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_sqrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_SQRT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

template<size_t S>
struct OperationDispatcher<_simd_u8x1, S, OP_CBRT> {
	typedef _simd_u8x1 scalar_t;

	static void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		if (false) {
#ifdef _simd_u8x64_cbrt_
		} else if (S >= 64 && _simd_u8x64_cbrt_enable()) {
			typedef _simd_u8x64 simd_t;
			enum {loop = S / 64, remainder = S % 64 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x64_cbrt_(_simd_u8x64_load_(x));
				x += 64;
				o += 64;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u8x32_cbrt_
		} else if (S >= 32 && _simd_u8x32_cbrt_enable()) {
			typedef _simd_u8x32 simd_t;
			enum {loop = S / 32, remainder = S % 32 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x32_cbrt_(_simd_u8x32_load_(x));
				x += 32;
				o += 32;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u8x16_cbrt_
		} else if (S >= 16 && _simd_u8x16_cbrt_enable()) {
			typedef _simd_u8x16 simd_t;
			enum {loop = S / 16, remainder = S % 16 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x16_cbrt_(_simd_u8x16_load_(x));
				x += 16;
				o += 16;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u8x8_cbrt_
		} else if (S >= 8 && _simd_u8x8_cbrt_enable()) {
			typedef _simd_u8x8 simd_t;
			enum {loop = S / 8, remainder = S % 8 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x8_cbrt_(_simd_u8x8_load_(x));
				x += 8;
				o += 8;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u8x4_cbrt_
		} else if (S >= 4 && _simd_u8x4_cbrt_enable()) {
			typedef _simd_u8x4 simd_t;
			enum {loop = S / 4, remainder = S % 4 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x4_cbrt_(_simd_u8x4_load_(x));
				x += 4;
				o += 4;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
#ifdef _simd_u8x2_cbrt_
		} else if (S >= 2 && _simd_u8x2_cbrt_enable()) {
			typedef _simd_u8x2 simd_t;
			enum {loop = S / 2, remainder = S % 2 };
			for (size_t i = 0; i < loop; ++i) {
				*reinterpret_cast<simd_t*>(o) = _simd_u8x2_cbrt_(_simd_u8x2_load_(x));
				x += 2;
				o += 2;
			}
			OperationDispatcher<scalar_t, remainder, OP_CBRT>::execute(x,o);
#endif
		} else {
			for(int i = 0; i < S; ++i) o[i] = _simd_u8x1_cbrt_safe(x[i]);
		}
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 1, OP_CBRT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
		*o = _simd_u8x1_cbrt_safe(*x);
	}
};

template<>
struct OperationDispatcher<_simd_u8x1, 0, OP_CBRT> {
	typedef _simd_u8x1 scalar_t;

	static ANVIL_STRONG_INLINE void ANVIL_SIMD_CALL execute(const scalar_t* x, scalar_t* o) {
	}
};

